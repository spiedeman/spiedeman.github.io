<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陋室</title>
  
  <subtitle>Colin McGuire&#39;Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://spiedeman.github.io/"/>
  <updated>2021-09-18T02:10:59.612Z</updated>
  <id>http://spiedeman.github.io/</id>
  
  <author>
    <name>Colin McGuire</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://spiedeman.github.io/posts/1243066710/"/>
    <id>http://spiedeman.github.io/posts/1243066710/</id>
    <published>2021-09-18T02:10:59.612Z</published>
    <updated>2021-09-18T02:10:59.612Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>在Ubuntu中使用Citrix Workspace App办公</title>
    <link href="http://spiedeman.github.io/posts/c80075c3/"/>
    <id>http://spiedeman.github.io/posts/c80075c3/</id>
    <published>2020-10-24T03:04:17.000Z</published>
    <updated>2021-09-18T02:10:59.602Z</updated>
    
    <content type="html"><![CDATA[<h1 id="远程办公">远程办公</h1><p>在家里办公需要下载<code>Citrix Reciver</code>远程连接公司服务器。Google之后发现在Linux平台上， <code>Citrix Workspace APP</code>已经取代前者并提供兼容性支持，因此将选择它进行安装。</p><h1 id="安装使用">安装使用</h1><h2 id="下载安装包">下载安装包</h2><p>在最新版本所在 <a href="https://www.citrix.com/downloads/workspace-app/linux/workspace-app-for-linux-latest.html" target="_blank" rel="noopener">页面</a> 根据Linux发行版找到相应的安装包并下载。</p><h2 id="遇到的问题">遇到的问题</h2><p>安装完成后，启动程序并填入服务器地址进行连接，发现缺少SSL证书导致连接失败。 网上搜索之后找到解决办法，如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将证书软链接至相应目录</span></span><br><span class="line">sudo ln -s /usr/share/ca-certificates/mozilla/GlobalSign_Root_CA.crt /opt/Citrix/ICAClient/keystore/cacerts/</span><br><span class="line"><span class="comment"># 更新证书记录</span></span><br><span class="line">sudo c_rehash /opt/Citrix/ICAClient/keystore/cacerts</span><br></pre></td></tr></table></figure><p>由于本人所用笔记本屏幕分辨率较高<code>2560x1600</code>，打开远程桌面后，字体很小，眼睛累。公司用的服务器系统是<code>window server 2008</code>， 调整字体大小为<code>150%</code>之后，基本解决问题。不过这只是治标，治本得等Linux客户端程序提供功能改进了。</p><blockquote><p>使用体验暂时OK，仍然不用切换到Windows办公，就这样！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;远程办公&quot;&gt;远程办公&lt;/h1&gt;&lt;p&gt;在家里办公需要下载&lt;code&gt;Citrix Reciver&lt;/code&gt;远程连接公司服务器。Google之后发现在Linux平台上， &lt;code&gt;Citrix Workspace APP&lt;/code&gt;已经取代前者并提供兼容性支持
      
    
    </summary>
    
      <category term="工作" scheme="http://spiedeman.github.io/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="远程办公" scheme="http://spiedeman.github.io/tags/%E8%BF%9C%E7%A8%8B%E5%8A%9E%E5%85%AC/"/>
    
  </entry>
  
  <entry>
    <title>Mukhanov-Sasaki 方程</title>
    <link href="http://spiedeman.github.io/posts/579653d0/"/>
    <id>http://spiedeman.github.io/posts/579653d0/</id>
    <published>2020-06-18T11:28:55.000Z</published>
    <updated>2021-09-18T02:10:59.612Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标量扰动">标量扰动</h2><p>记录一下宇宙学中<strong>规范扰动理论</strong>中的<strong>Mukhanov-Sasaki(MS)</strong>方程。</p><p><span class="math display">\[ \begin{equation} \label{eq:ms-equation} u^{\pprime}-c_s^2\Delta u - \frac{\theta^{\pprime}}{\theta}u = 0. \end{equation} \]</span></p><p>以标量扰动以及完美流体为例，验证<strong>MS方程</strong><span class="math inline">\(\eqref{eq:ms-equation}\)</span>。</p><p>为了叙述方便，以下将<strong>规范扰动</strong>简称为<strong>扰动</strong>，在物理量上添加横线代表相对应的规范不变量，若不至于产生误解，则省略横线。</p><p>完美流体的能动张量为 <span class="math display">\[ \begin{equation} \label{eq:perfect-fluid-energy-mommentum-tensor} T^{\alpha}_{\ \beta} = (\varepsilon + p) u^{\alpha}u_{\beta}-p\delta^{\alpha}_{\ \beta}. \end{equation} \]</span> 相应的一阶扰动为 <span class="math display">\[ \begin{equation} \label{eq:guage-invariant-perturbation-for-perfect-fluid} \overline{\delta T}^{0}_0 = \overline{\delta\varepsilon},\quad \overline{\delta T}^{0}_i = \frac{1}{a}(\varepsilon_0+p_0)(\overline{\delta u}_{\parallel i}+\overline{\delta u}_{\bot i}), \quad \overline{\delta T}^i_j = -\overline{\delta p}\delta^i_j. \end{equation} \]</span> 其中<span class="math inline">\(\overline{\delta\varepsilon},\overline{\delta u}_{\parallel i},\overline{\delta p}\)</span>对应标量扰动，而<span class="math inline">\(\overline{\delta u}_{\bot i}\)</span>有旋无源，贡献为矢量扰动。</p><p>因为<span class="math inline">\(\delta T^i_{\ j}=0\)</span>，当<span class="math inline">\(i\ne j\)</span>。因而<span class="math inline">\((ij)\)</span>分量对应的标量扰动方程约化为 <span class="math display">\[ \begin{equation} (\Phi-\Psi)_{,ij} = 0 \qquad (i\ne j). \end{equation} \]</span> 因而有<span class="math inline">\(\Phi = \Psi\)</span>。故而标量扰动满足的规范方程组的形式具体如下 <span class="math display">\[ \begin{align} \Delta \Phi - 3\mathcal{H}(\Phi^{\prime}+\mathcal{H}\Phi) =4\pi Ga^2\overline{\delta\varepsilon}, \label{eq:scalar-guage-invariant-perturbation-equations-00} \\ (a\Phi)_{,}^{\prime}=4\pi Ga^2(\varepsilon_0+p_0)\overline{\delta u}_{\parallel i}, \label{eq:scalar-guage-invariant-perturbation-equations-0i} \\ \Phi^{\pprime}+3\mathcal{H}\Phi^{\prime}+(2\mathcal{H^\prime+H^2}\Phi) = 4\pi Ga^2\overline{\delta p}. \label{eq:scalar-guage-invariant-perturbation-equations-ij} \end{align} \]</span> 根据热力学可知压强为内能和熵的函数，<span class="math inline">\(p=p(\varepsilon, S)\)</span>。压强的涨落<span class="math inline">\(\overline{\delta p}\)</span>可以表示为 <span class="math display">\[ \begin{equation} \label{eq:sound-speed} \overline{\delta p}=c_s^2\overline{\delta\varepsilon}+\tau\delta S. \end{equation} \]</span> 这里只考虑绝热扰动（<span class="math inline">\(\delta S=0\)</span>），故<span class="math inline">\(\overline{\delta p}=c_s^2\overline{\delta\varepsilon}\)</span>。 联合方程<span class="math inline">\(\eqref{eq:scalar-guage-invariant-perturbation-equations-00}\)</span>和<span class="math inline">\(\eqref{eq:scalar-guage-invariant-perturbation-equations-ij}\)</span> 得到引力势<span class="math inline">\(\Phi\)</span>满足的动力学方程 <span class="math display">\[ \begin{equation} \label{eq:bardeen-equation} \Phi^{\pprime}+3(1+c_s^2)\mathcal{H}\Phi^{\prime}-c_s^2\Delta\Phi+\lrp{2\mathcal{H^\prime}+(1+3 c_s^2)\mathcal{H^2}}\Phi = 0 \end{equation} \]</span> 方程<span class="math inline">\(\eqref{eq:bardeen-equation}\)</span>称为<strong>bardeen</strong>方程，这个方程并不总是存在解析解。 不过有可能得到长波极限和短波极限下的渐进解。这可以通过引入新变量，改写方程形式消灭其中的摩擦项做到。</p><p><span class="math display">\[ \begin{equation} \begin{aligned} u&amp;\equiv \exp\lrp{\frac{3}{2}\int (1+c_s^2)\mathcal{H}d\eta}\Phi \\ &amp;=\exp\lrp{-\frac{1}{2}\int \lrp{1+\frac{p_0^{\prime}}{\varepsilon_0^{\prime}}} \frac{\varepsilon_0^{\prime}}{\varepsilon_0+p_0}d\eta}\Phi \\ &amp;=\frac{\Phi}{(\varepsilon_0+p_0)^{1/2}}. \end{aligned} \end{equation} \]</span> 其中用到了<span class="math inline">\(c_s^2=p_0^{\prime}/\varepsilon_0^{\prime}\)</span>，连续性方程 <span class="math inline">\(\varepsilon_0^{\prime}=-3\mathcal{H}(\varepsilon_0+p_0)\)</span> 。以及 <span class="math display">\[ \begin{equation} \theta\equiv \frac{1}{a}\lrp{1+\frac{p_0}{\varepsilon_0}}^{-1/2} =\frac{1}{a}\lrp{\frac{2}{3}\lrp{1-\frac{\mathcal{H^{\prime}}}{\mathcal{H^2}}}}^{-1/2}. \end{equation} \]</span> 其中用到了背景方程 <span class="math display">\[ \begin{equation} \label{eq:background-equation} \mathcal{H^2}=\frac{8\pi G}{3}a^2\varepsilon_0,\quad \mathcal{H^2-H^\prime}=4\pi Ga^2(\varepsilon_0+p_0). \end{equation} \]</span> 经过复杂的计算，<strong>bardeen方程</strong><span class="math inline">\(\eqref{eq:bardeen-equation}\)</span>可以重写为不含摩擦项的<strong>MS方程</strong> <span class="math display">\[ \begin{equation} u^{\pprime}-c_s^2\Delta u-\frac{\theta^{\pprime}}{\theta} u = 0. \end{equation} \]</span></p><p>接下来，只进行验证<strong>MS方程</strong>和<strong>bardeen方程</strong><span class="math inline">\(\eqref{eq:bardeen-equation}\)</span>等价。</p><p>首先注意到 <span class="math display">\[ \begin{equation} \begin{aligned} u^{\pprime}-\frac{\theta^{\pprime}}{\theta}u &amp;= \lrp{\frac{u}{\theta}}^{\pprime}\theta+2\lrp{\frac{u}{\theta}}^{\prime}\theta^{\prime} \\ &amp;=\lrp{\lrp{\frac{u}{\theta}}^{\prime}\theta}^{\prime} + \lrp{\frac{u}{\theta}}^{\prime}\theta^{\prime} \\ &amp;= v^{\prime} + v\frac{\theta^{\prime}}{\theta}. \quad \text{令}(v=\lrp{\frac{u}{\theta}}^{\prime}\theta). \end{aligned} \end{equation} \]</span> 故<strong>MS方程</strong>等价于 <span class="math display">\[ \begin{equation} c_s^2\Delta u=v^{\prime}+v\frac{\theta^{\prime}}{\theta}. \end{equation} \]</span> <span class="math inline">\(v\)</span>和<span class="math inline">\(v^{\prime}\)</span>的表达式分别为 <span class="math display">\[ \begin{equation} \begin{aligned} &amp;\begin{aligned} v\equiv \lrp{\frac{u}{\theta}}^{\prime}\theta &amp;= \frac{1}{\lrp{\varepsilon_0+p_0}^{1/2}}\lrp{\Phi^{\prime}+\Phi\lrp{\mathcal{H}-\frac{1}{2}\frac{\varepsilon_0^{\prime}}{\varepsilon_0}}} \\ &amp;= \frac{1}{\lrp{\varepsilon_0+p_0}^{1/2}} f. \end{aligned} \\ &amp;\begin{aligned} v^{\prime}=\frac{1}{\lrp{\varepsilon_0+p_0}^{1/2}}\lrp{f^{\prime}-\frac{1}{2} f\frac{\lrp{\varepsilon_0+p_0}^{\prime}}{\varepsilon_0+p_0}}. \end{aligned} \end{aligned} \end{equation} \]</span></p><p>故<strong>MS方程</strong>等价于 <span class="math display">\[ \begin{equation} c_s^2\Delta u = \frac{1}{\lrp{\varepsilon_0+p_0}^{1/2}}\lrp{f^{\prime} +f\lrp{\frac{\theta^{\prime}}{\theta}-\frac{1}{2} \frac{\lrp{\varepsilon_0+p_0}^{\prime}}{\varepsilon_0+p_0}}}. \end{equation} \]</span> 为了后续计算方便，先计算几个表达式 <span class="math display">\[ \begin{align} &amp;\frac{\theta^{\prime}}{\theta} = \frac{\mathcal{H}}{2}(1+3 c_s^2)+\frac{1}{2}\frac{\varepsilon_0^{\prime}}{\varepsilon_0}, \\ &amp;\frac{\lrp{\varepsilon_0^{\prime}}}{\varepsilon_0+p_0} =\frac{\lrp{1+\frac{p_0^{\prime}}{\varepsilon_0^{\prime}}}\varepsilon_0^{\prime}}{\varepsilon_0+p_0} =-3\mathcal{H}(1+c_s^2), \\ &amp;\frac{\varepsilon_0^{\prime}}{\varepsilon_0} =-3\mathcal{H}\lrp{1+\frac{p_0}{\varepsilon_0}} =-2\mathcal{H}\lrp{1-\frac{\mathcal{H}^{\prime}}{\mathcal{H}^2}}, \\ &amp;\lrp{\frac{\varepsilon_0^{\prime}}{\varepsilon_0}}^{\prime} =\frac{\varepsilon_0^{\prime}}{\varepsilon_0} \lrp{\mathcal{\frac{H^{\prime}}{H}}-3\mathcal{H}(1+c_s^2)- \frac{\varepsilon_0^{\prime}}{\varepsilon_0}}. \end{align} \]</span></p><p>故<strong>MS方程</strong>等价于 <span class="math display">\[ \begin{equation} \begin{aligned} c_s^2\Delta\Phi &amp;= f^{\prime} + f\lrp{\frac{\theta^{\prime}}{\theta}-\frac{1}{2} \frac{\lrp{\varepsilon_0+p_0}^{\prime}}{\varepsilon_0+p_0}} \\ &amp;= \Phi^{\pprime}+\Phi^{\prime}\lrp{\mathcal{H}-\frac{1}{2}\frac{\varepsilon_0^{\prime}}{\varepsilon_0}} +\Phi\lrp{\mathcal{H}-\frac{1}{2}\frac{\varepsilon_0^{\prime}}{\varepsilon_0}}^{\prime} \\ &amp;\ +\lrp{\Phi^{\prime}+\Phi\lrp{\mathcal{H}-\frac{1}{2}\frac{\varepsilon_0^{\prime}}{\varepsilon_0}}} \lrp{\mathcal{H}\lrp{2+3 c_s^2}+\frac{1}{2}\frac{\varepsilon_0^{\prime}}{\varepsilon_0}} \\ &amp;=\Phi^{\pprime} + 3\mathcal{H}(1+3 c_s^2)\Phi^{\prime} \\ &amp;\ +\Phi\lrp{\mathcal{H^{\prime}}-\lrp{\frac{1}{2} \frac{\varepsilon_0^{\prime}}{\varepsilon_0}}^{\prime} +\lrp{\mathcal{H}-\frac{1}{2}\frac{\varepsilon_0^{\prime}}{\varepsilon_0}} \lrp{\mathcal{H}\lrp{2+3 c_s^2}+\frac{1}{2}\frac{\varepsilon_0^{\prime}}{\varepsilon_0}}}, \end{aligned} \end{equation} \]</span></p><p>经过简单但复杂的计算，上式最后一行中的括号为 <span class="math display">\[ \begin{equation} 2\mathcal{H^{\prime}}+\mathcal{H^2}\lrp{1+3 c_s^2}, \end{equation} \]</span> 故<strong>MS方程</strong>确实等价于<strong>bardeen方程</strong>。显然<strong>MS方程</strong>是<strong>规范不变方程</strong>，引入的变量 <span class="math inline">\(u\)</span>和<span class="math inline">\(\theta\)</span>均为<strong>规范不变量</strong>。</p><h2 id="曲率扰动">曲率扰动</h2><p><strong>MS方程</strong>能够被写成更紧凑的形式 <span class="math display">\[ \begin{equation} \lrb{\lrp{\frac{u}{\theta}}^{\prime}\theta^2}^{\prime} = c_s^2\theta\Delta u \end{equation} \]</span> 在<strong>长波极限</strong>下，散度项<span class="math inline">\(\Delta u\)</span>可以被忽略，故而我们找到了一个在超视界区域为常数的规范不变量 <span class="math display">\[ \begin{equation} \label{eq:curvature-perturbation} \begin{aligned} \zeta &amp;\equiv \frac{2}{3}\lrp{\frac{u}{\theta}}^{\prime}\theta^2 \\ &amp;= \frac{v}{z} \end{aligned} \end{equation} \]</span> 其中 <span class="math display">\[ \begin{equation} v=\lrp{\frac{u}{\theta}}^{\prime}\theta,\quad z = \frac{1}{\theta}. \end{equation} \]</span> 该变量即是文献中常见的标量曲率扰动<span class="math inline">\(\mathcal{R}\)</span>，通常在暴胀过程中会计算<span class="math inline">\(\mathcal{R}\)</span>的功率谱<span class="math inline">\(P_{\mathcal{R}}(k)\)</span>。</p><p>前面验证<strong>MS方程</strong>的过程中从数学的角度看，构造出的四个规范不变量<span class="math inline">\(u,v,\theta,z\)</span> 满足了如下两个方程 <span class="math display">\[ \begin{equation} \label{eq:middle-equations} c_s^2\Delta u=z\lrp{\frac{v}{z}}^{\prime},\quad v=\theta\lrp{\frac{u}{\theta}}^{\prime}. \end{equation} \]</span> 满足上述方程的函数<span class="math inline">\(u\)</span>，在消除辅助函数<span class="math inline">\(v\)</span>后自然得到<strong>MS方程</strong>。观察<span class="math inline">\(\zeta\)</span>的定义 式<span class="math inline">\(\eqref{eq:curvature-perturbation}\)</span>后，更希望找到<span class="math inline">\(v\)</span>满足的方程。从方程组<span class="math inline">\(\eqref{eq:middle-equations}\)</span>出发可以得到 <span class="math display">\[ \begin{equation} v^{\pprime}-c_s^2\Delta v-\frac{z^{\pprime}}{z}v= 0 \end{equation} \]</span> 巧合地是<span class="math inline">\(u\)</span>和<span class="math inline">\(v\)</span>满足的方程形式相同。实际上<span class="math inline">\(v\)</span>满足的方程才是文献中提到的<strong>MS方程</strong>，<span class="math inline">\(u\)</span>满足的方程只是形式相同，本质还是<strong>bardeen方程</strong>。 在暴胀过程中，根据规范不变量的定义 <span class="math display">\[ \begin{equation} z=\frac{a\lrp{\varepsilon+p}^{1/2}}{H}=\frac{a\dot{\varphi}}{H} =\frac{a\varphi^{\prime}}{\mathcal{H}}. \end{equation} \]</span> 其中<span class="math inline">\(\varphi\)</span>是暴胀场。到这一步时，曲率扰动的功率谱就就呼之欲出了 <span class="math display">\[ \begin{equation} \label{eq:curvature-perturbation-power-spectrum} P_{\zeta}(k)=P_{\mathcal{R}}(k) = \frac{k^{3}}{2\pi^2} \left\lvert \frac{v_k}{z}\right\rvert ^2 \end{equation} \]</span> 暴胀过程中，变换到傅立叶空间中，<span class="math inline">\(v\)</span>的<span class="math inline">\(k\)</span>模<span class="math inline">\(v_k\)</span>满足贝塞尔方程 <span class="math display">\[ \begin{equation} \label{eq:bessel-equation} v_k^{\pprime}+\lrp{k^2-\frac{\nu^2-1/4}{\eta^2}}v_k = 0, \end{equation} \]</span> 式中<span class="math inline">\(\nu=3/2+2\varepsilon_H-\eta_H\)</span>。考虑到平面波边值条件 <span class="math display">\[ \begin{equation} \label{eq:plane-wave-boundary-condition} v_k(\eta)\rightarrow \frac{1}{2k}e^{-ik\eta},\quad k\rightarrow \infty \end{equation} \]</span> 贝塞尔方程<span class="math inline">\(\eqref{eq:bessel-equation}\)</span>的解为 <span class="math display">\[ \begin{equation} \label{eq:solution-for-ms-equation-in-inflation} v_k(\eta) =\frac{\sqrt{\pi}}{2}e^{i(\nu+1/2)\pi/2}\sqrt{-\eta}H_{\nu}^{(1)}(-k\eta). \end{equation} \]</span> 式中<span class="math inline">\(H_{\nu}^{(1)}\)</span>为第一类汉克尔函数。对于超视界扰动 <span class="math display">\[ \begin{align} \label{eq:for-super-horizon} H_{\nu}^{(1)}(x\ll 1) \sim \sqrt{\frac{2}{\pi}}e^{-i\pi/2} 2^{\nu-3/2}\frac{\Gamma(\nu)}{\Gamma(3/2)}x^{-\nu}, \\ v_k(\eta) = e^{i(\nu-1/2)\pi/2}2^{\nu-3/2} \frac{\Gamma(\nu)}{\Gamma(3/2)}\frac{1}{\sqrt{2k}}(-k\eta)^{1/2-\nu}. \end{align} \]</span> 故曲率扰动的功率谱为 <span class="math display">\[ \begin{equation} \begin{aligned} P_{\mathcal{R}}(k) &amp;= \frac{k^{3}}{2\pi^2}\left\lvert \frac{\nu_k}{z}\right\rvert ^2 \\ &amp;= 2^{2\nu-3}\lrp{\frac{\Gamma(\nu)}{\Gamma(3/2)}}^2 \lrp{\frac{H}{\dot{\varphi}_0}}^2 \lrp{\frac{H}{2\pi}}^2 \lrp{\frac{k}{aH}}^{3-2\nu} \Bigg\lvert_{k=aH}. \end{aligned} \end{equation} \]</span></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;标量扰动&quot;&gt;标量扰动&lt;/h2&gt;&lt;p&gt;记录一下宇宙学中&lt;strong&gt;规范扰动理论&lt;/strong&gt;中的&lt;strong&gt;Mukhanov-Sasaki(MS)&lt;/strong&gt;方程。&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begi
      
    
    </summary>
    
      <category term="物理" scheme="http://spiedeman.github.io/categories/%E7%89%A9%E7%90%86/"/>
    
    
      <category term="Cosmology" scheme="http://spiedeman.github.io/tags/Cosmology/"/>
    
      <category term="Physics" scheme="http://spiedeman.github.io/tags/Physics/"/>
    
  </entry>
  
  <entry>
    <title>逆拉普拉斯算符</title>
    <link href="http://spiedeman.github.io/posts/f03e62a1/"/>
    <id>http://spiedeman.github.io/posts/f03e62a1/</id>
    <published>2020-06-07T02:48:49.000Z</published>
    <updated>2021-09-18T02:10:59.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="泊松方程及其解">泊松方程及其解</h1><p>拉普拉斯算符<span class="math inline">\(\Delta\)</span>是<span class="math inline">\(n\)</span>维欧几里得空间中的一个二阶微分算符，定义为标量函数<span class="math inline">\(f\)</span>的梯度的散度。 <span class="math display">\[ \begin{equation} \label{eq:poisson-equation} \Delta \varphi = \nabla^2 \varphi = \nabla\cdot\nabla \varphi = f \end{equation} \]</span> 物理中通常称为<strong>泊松方程</strong>，一般利用<strong>格林函数</strong>法求解。拉普拉斯算符对应的格林函数满足方程 <span class="math display">\[ \begin{equation} \label{eq:green-function-for-laplacian-operator} \nabla^2 G(\bm{r},\bm{r^\prime}) = \delta(\bm{r}-\bm{r}^\prime) \end{equation} \]</span> 方程<span class="math inline">\(\eqref{eq:green-function-for-laplacian-operator}\)</span>的解为 <span class="math display">\[ \begin{equation} G(\bm{r},\bm{r^\prime}) = - \frac{1}{4\pi} \frac{1}{\Abs{\bm{r}-\bm{r^\prime}}} \end{equation} \]</span> 因此<strong>泊松方程</strong>的特解为 <span class="math display">\[ \begin{equation} \label{eq:particular-solution-for-poisson-equation} \begin{aligned} \varphi_p(\bm{r}) &amp;= \int G(\bm{r},\bm{r^\prime})f(\bm{r^\prime})d^3\bm{r^\prime} \\ &amp;=-\frac{1}{4\pi}\int \frac{f(\bm{r^\prime})}{\Abs{\bm{r}-\bm{r^\prime}}}d^3\bm{r^\prime} \end{aligned} \end{equation} \]</span></p><p>若源项<span class="math inline">\(f(\bm{r})\)</span>在全空间积分为有限值，则 <span class="math display">\[ \begin{equation} \begin{aligned} \lim_{r\to\infty}\varphi_p(\bm{r})&amp;=-\frac{1}{4\pi}\lim_{r\to\infty} \int\frac{f(\bm{r})}{\Abs{\bm{r-r^\prime}}} d^3\bm{r^\prime} \\ &amp;=-\frac{1}{4\pi} \left(\lim_{r\to\infty}\frac{1}{r}\int f(\bm{r^\prime})d^3\bm{r^\prime} + \bigo\lrp{\frac{1}{r^2}} \right) \\ &amp;=-\frac{1}{4\pi} \lrp{\lim_{r\to\infty}\frac{q}{r}+\bigo\lrp{\frac{1}{r^2}}} \\ &amp;=0 \end{aligned} \end{equation} \]</span> 因此精确的表述为，当泊松方程<span class="math inline">\(\eqref{eq:poisson-equation}\)</span>的边界条件为：<span class="math inline">\(\varphi(\bm{r})\)</span>在无穷远处为零时，解为<span class="math inline">\(\varphi_p(\bm{r})\)</span>。当指定非零边界条件时，完整的解为 <span class="math display">\[ \begin{equation} \varphi(\bm{r}) =\varphi_p(\bm{r})+\varphi_c(\bm{r}) \end{equation} \]</span> 其中<span class="math inline">\(\varphi_c(\bm{r})\)</span>为任意<strong>拉普拉斯方程</strong>（无源泊松方程）的解 <span class="math display">\[ \begin{equation} \label{eq:solution-for-boundary-laplace-equation} \nabla^2\varphi_c(\bm{r}) = 0 \end{equation} \]</span></p><h1 id="逆拉普拉斯算符">逆拉普拉斯算符</h1><p>当源项<span class="math inline">\(f(\bm{r})\)</span>在全空间积分收敛，即选取无穷远处为零的边界条件时，泊松方程的解为 <span class="math display">\[ \begin{equation} \varphi(\bm{r})=\varphi_p(\bm{r}) \end{equation} \]</span> 在上述前提条件下，定义逆拉普拉斯算符为<span class="math inline">\(\Delta^{-1}\)</span>，将其作用于泊松方程<span class="math inline">\(\eqref{eq:poisson-equation}\)</span>得到 <span class="math display">\[ \begin{equation} \Delta^{-1}\Delta\varphi(\bm{r})\equiv \varphi(\bm{r}) = \Delta^{-1}f(\bm{r}) \end{equation} \]</span> 根据<span class="math inline">\(\eqref{eq:particular-solution-for-poisson-equation}\)</span>可得 <span class="math display">\[ \begin{equation} \boxed{ \Delta^{-1}f(\bm{r}) =-\frac{1}{4\pi}\int\frac{f(\bm{r^\prime})}{\Abs{\bm{r-r^\prime}}}d^3\bm{r^\prime}} \end{equation} \]</span> 容易验证 <span class="math display">\[ \begin{equation} \Delta^{-1}\Delta f(\bm{r})=\Delta\Delta^{-1}f(\bm{r})=f(\bm{r}) \end{equation} \]</span></p><h1 id="应用">应用</h1><p>利用逆拉普拉斯算符<span class="math inline">\(\Delta^{-1}\)</span>，可以将矢量场<span class="math inline">\(\bm{V}(\bm{r})\)</span>唯一分解为不相交的两部分 <span class="math display">\[ \begin{equation} \bm{V}=\bm{V}_{\parallel} + \bm{V}_{\bot},\qquad \text{其中}\ \nabla\cdot \bm{V}_{\bot}=\nabla\times \bm{V}_{\parallel}=0 \end{equation} \]</span> 直接构造 <span class="math display">\[ \begin{equation} \label{eq:longitudinal} \bm{V}_{\parallel}=\nabla\Delta^{-1}\nabla\cdot \bm{V} \end{equation} \]</span> 观察到<span class="math inline">\(\psi\equiv\Delta^{-1}\nabla\cdot \bm{V}\)</span>是一个标量场，因此<span class="math inline">\(\bm{V}\times \bm{V}_{\parallel}=\bm{V}\times\nabla\psi=0\)</span>。横向部分为 <span class="math display">\[ \begin{equation} \bm{V}_{\bot}=\bm{V}-\bm{V}_{\parallel}=\bm{V}-\nabla\Delta^{-1}\nabla\cdot \bm{V} \end{equation} \]</span> 可以验证 <span class="math display">\[ \begin{equation} \nabla\cdot \bm{V}_{\bot}=\nabla\cdot\lrb{\bm{V}-\nabla\Delta^{-1}\nabla\cdot \bm{V}} =\nabla\cdot \bm{V}-\Delta\Delta^{-1}\lrp{\nabla\cdot \bm{V}} =\nabla\cdot \bm{V}-\nabla\cdot \bm{V}=0 \end{equation} \]</span> 与<span class="math inline">\(\bm{V}_{\parallel}\)</span>一样，<span class="math inline">\(\bm{V}_{\bot}\)</span>也存在类似的表达式 <span class="math display">\[ \begin{equation} \label{eq:transverse} \bm{V}_{\bot}=-\nabla\times\Delta^{-1}\lrp{\nabla\times \bm{V}} \end{equation} \]</span> 为了证明<span class="math inline">\(\eqref{eq:transverse}\)</span>成立，首先引入两个等式，不过省略证明。 <span class="math display">\[ \begin{aligned} &amp;\nabla\times\Delta^{-1}\lrp{\bm{A}}=\Delta^{-1}\lrp{\nabla\times \bm{A}}\\ &amp;\nabla\Delta^{-1}\lrp{\psi}=\Delta^{-1}\lrp{\nabla\psi} \end{aligned} \]</span> 于是 <span class="math display">\[ \begin{aligned} \bm{V}_{\bot}&amp;=-\nabla\times\Delta^{-1}\lrp{\nabla\times\bm{V}}\\ &amp;=-\Delta^{-1}\lrb{\nabla\times\lrp{\nabla\times\bm{V}}} \\ &amp;=\Delta^{-1}\lrb{\Delta\bm{V}-\nabla\lrp{\nabla\cdot\bm{V}}}\\ &amp;=\bm{V}-\Delta^{-1}\nabla\lrp{\nabla\cdot\bm{V}}\\ &amp;=\bm{V}-\nabla\Delta^{-1}\lrp{\nabla\cdot\bm{V}} \\ &amp;=\bm{V}-\bm{V}_{\parallel} \end{aligned} \]</span> 以上说明了分解的存在性，接下来说明该分解具有唯一性，并且只需说明纵向部分具有唯一性即可。 对矢量<span class="math inline">\(\bm{V}\)</span>取散度，得到关于标量场<span class="math inline">\(\psi\)</span>的泊松方程 <span class="math display">\[ \begin{equation} \nabla\cdot \bm{V} = \nabla\cdot\bm{V_{\parallel}} = \Delta \psi \end{equation} \]</span> 由于泊松方程具有唯一解，因而矢量分解也具有唯一性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;泊松方程及其解&quot;&gt;泊松方程及其解&lt;/h1&gt;&lt;p&gt;拉普拉斯算符&lt;span class=&quot;math inline&quot;&gt;\(\Delta\)&lt;/span&gt;是&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;维欧几里得空间中的一个二阶微分算符，定义
      
    
    </summary>
    
      <category term="物理" scheme="http://spiedeman.github.io/categories/%E7%89%A9%E7%90%86/"/>
    
    
      <category term="Physics" scheme="http://spiedeman.github.io/tags/Physics/"/>
    
  </entry>
  
  <entry>
    <title>Linux下配置触摸板手势操作</title>
    <link href="http://spiedeman.github.io/posts/35c03362/"/>
    <id>http://spiedeman.github.io/posts/35c03362/</id>
    <published>2020-05-13T10:42:26.000Z</published>
    <updated>2021-09-18T02:10:59.612Z</updated>
    
    <content type="html"><![CDATA[<p>MacOS的触摸板手势体验没得说，在Linux下也可以借助一些软件达到相近的体验。不过最想要的<strong>三指取词</strong>还不知到如何实现😠。</p><p>首先配置触摸板的驱动程序为<code>libinput</code>，具体操作这里不谈。借助软件<a href="https://github.com/bulletmark/libinput-gestures" target="_blank" rel="noopener">libinput-gestures</a>可以拓展触摸板<strong>三/四指手势</strong>以及<strong>缩放</strong>操作。</p><p>i3桌面下，窗口有两种：<strong>平铺</strong>以及<strong>浮动</strong>。工作区的概念类比MacOS中的虚拟桌面，便签区的效果类似<strong>窗口最小化</strong>。</p><h3 id="功能表">功能表</h3><table><thead><tr class="header"><th style="text-align:center"></th><th style="text-align:center"><code>up</code></th><th style="text-align:center"><code>down</code></th><th style="text-align:center"><code>left</code></th><th style="text-align:center"><code>right</code></th></tr></thead><tbody><tr class="odd"><td style="text-align:center">三指</td><td style="text-align:center">切换到上方窗口</td><td style="text-align:center">切换到下方窗口</td><td style="text-align:center">切换到左侧窗口</td><td style="text-align:center">切换到右侧窗口</td></tr><tr class="even"><td style="text-align:center">四指</td><td style="text-align:center">将浮动窗口移到便签区</td><td style="text-align:center">循环切换便签区内的窗口</td><td style="text-align:center">切换到左侧工作区</td><td style="text-align:center">切换到右侧工作区</td></tr></tbody></table><p>如果当前获得焦点的窗口是浏览器，则<strong>三指</strong>的手势功能为</p><table><thead><tr class="header"><th style="text-align:center"></th><th style="text-align:left"><code>up</code></th><th style="text-align:center"><code>down</code></th><th style="text-align:center"><code>left</code></th><th style="text-align:center"><code>right</code></th></tr></thead><tbody><tr class="odd"><td style="text-align:center">三指</td><td style="text-align:left">前进</td><td style="text-align:center">后退</td><td style="text-align:center">切换到左侧tab</td><td style="text-align:center">切换到右侧tab</td></tr></tbody></table><p>以及另外四种手势</p><table><thead><tr class="header"><th style="text-align:center"></th><th style="text-align:center"><code>leftup</code></th><th style="text-align:center"><code>leftdown</code></th><th style="text-align:center"><code>rightup</code></th><th style="text-align:center"><code>rightdown</code></th></tr></thead><tbody><tr class="odd"><td style="text-align:center">三指</td><td style="text-align:center">打开最近关闭标签页</td><td style="text-align:center">关闭当前标签页</td><td style="text-align:center">左移当前便签页</td><td style="text-align:center">右移当前标签页</td></tr></tbody></table><h3 id="libinput-gestures-配置文件">libinput-gestures 配置文件</h3><p><code>libinput-gestures</code>的配置文件位于<code>~/.config/libinput-gestures.conf</code>。其中涉及到上述功能的配置为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 三指手势</span><br><span class="line">gestures swipe left  3 $HOME/Program/bin/move_window_or_tab</span><br><span class="line">gestures swipe right 3 $HOME/Program/bin/move_window_or_tab right</span><br><span class="line">gestures swipe up    3 $HOME/Program/bin/move_window_or_tab up</span><br><span class="line">gestures swipe down  3 $HOME/Program/bin/move_window_or_tab down</span><br><span class="line"></span><br><span class="line"># 四指手势</span><br><span class="line">gestures swipe left  4 i3-msg workspace prev</span><br><span class="line">gestures swipe right 4 i3-msg workspace next</span><br><span class="line">gestures swipe up    4 $HOME/Program/bin/show_or_hide_scratchpad up</span><br><span class="line">gestures swipe down  4 xdotool key super+shift+minus</span><br><span class="line"></span><br><span class="line"># 浏览器窗口中三指手势</span><br><span class="line">gestures swipe left_up    3 $HOME/Program/bin/move_window_or_tab left_up</span><br><span class="line">gestures swipe left_down  3 $HOME/Program/bin/move_window_or_tab left_down</span><br><span class="line">gestures swipe right_up   3 $HOME/Program/bin/move_window_or_tab right_up</span><br><span class="line">gestures swipe right_down 3 $HOME/Program/bin/move_window_or_tab right_down</span><br></pre></td></tr></table></figure><h3 id="实现脚本">实现脚本</h3><p><code>libinput-gestures</code>能捕捉手势，但是将手势与操作绑定需要通过另一个能实现模拟按键操作的软件<code>xdotool</code>。 由于<strong>三指</strong>手势对应的功能较为复杂，需要区分窗口内是否为浏览器，且涉及的主要功能为切换窗口，因而统一用一个脚本<code>move_window_or_tab</code>实现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取窗口名称</span></span><br><span class="line">WM_NAME=<span class="string">"<span class="variable">$(xdotool getactivewindow getwindowname)</span>"</span></span><br><span class="line"><span class="comment"># 获取手势方向</span></span><br><span class="line">DIRECTION=<span class="variable">$&#123;1:-left&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$WM_NAME</span> =~ <span class="string">'Firefox'</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="variable">$DIRECTION</span> == <span class="string">'left'</span> ]]; <span class="keyword">then</span></span><br><span class="line">        xdotool key control+Page_Up</span><br><span class="line">    <span class="keyword">elif</span> [[ <span class="variable">$DIRECTION</span> == <span class="string">'right'</span> ]]; <span class="keyword">then</span></span><br><span class="line">        xdotool key control+Page_Down</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment"># 普通i3窗口</span></span><br><span class="line">    <span class="comment"># Key number: H-43, J-44, K-45, L-46, ;-47</span></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="variable">$DIRECTION</span> == <span class="string">'left'</span> ]]; <span class="keyword">then</span></span><br><span class="line">        xdotool key super+44</span><br><span class="line">    <span class="keyword">elif</span> [[ <span class="variable">$DIRECTION</span> == <span class="string">'right'</span> ]]; <span class="keyword">then</span></span><br><span class="line">        xdotool key super+47</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>四指切换工作区的命令很简单，不需要借助脚本实现。但是涉及到<strong>便签区窗口</strong>的功能无法用一行命令搞定，因此写了一个脚本<code>show_or_hide_scratchpad</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取手势方向</span></span><br><span class="line">DIRECTION=<span class="variable">$&#123;1:-up&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 核心逻辑部分</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$DIRECTION</span> == <span class="string">'up'</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> i3-msg focus floating; <span class="keyword">then</span></span><br><span class="line">        i3-msg move scratchpad</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">elif</span> [[ <span class="variable">$DIRECTION</span> == <span class="string">'down'</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> i3-msg focus floating; <span class="keyword">then</span></span><br><span class="line">        i3-msg move scratchpad</span><br><span class="line">        i3-msg move scratchpad</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        i3-msg move scratchpad</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    i3-msg [floating] resize <span class="built_in">set</span> 1280 1200</span><br><span class="line">    i3-msg move position center</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MacOS的触摸板手势体验没得说，在Linux下也可以借助一些软件达到相近的体验。不过最想要的&lt;strong&gt;三指取词&lt;/strong&gt;还不知到如何实现😠。&lt;/p&gt;&lt;p&gt;首先配置触摸板的驱动程序为&lt;code&gt;libinput&lt;/code&gt;，具体操作这里不谈。借助软件&lt;a 
      
    
    </summary>
    
      <category term="i3" scheme="http://spiedeman.github.io/categories/i3/"/>
    
    
      <category term="触摸板" scheme="http://spiedeman.github.io/tags/%E8%A7%A6%E6%91%B8%E6%9D%BF/"/>
    
      <category term="手势操作" scheme="http://spiedeman.github.io/tags/%E6%89%8B%E5%8A%BF%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>VPS相关配置，Trojan及V2RAY脚本</title>
    <link href="http://spiedeman.github.io/posts/7a1be4a0/"/>
    <id>http://spiedeman.github.io/posts/7a1be4a0/</id>
    <published>2020-05-08T05:26:19.000Z</published>
    <updated>2021-09-18T02:10:59.622Z</updated>
    
    <content type="html"><![CDATA[<p>目前在用的科学上网工具有两款：<strong>Trojan</strong>和<strong>V2Ray</strong>。V2Ray的使用方式有很多，这里不作详细记录。Trojan的优势在于配置相对简单、采用的科学上网的方法不易被发现、速度快。V2Ray的优势在于功能齐全，搭配其他工具可以实现从简单到复杂的各种科学上网方式，缺点是某些方式速度较慢。综合两者的优缺点，我一般将两者搭配使用，Trojan负责科学上网，V2Ray负责路由功能。</p><p>### 安装Trojan和V2Ray 是否在Debian/Ubuntu官方仓库中</p><blockquote><ul><li><code>Trojan</code>: ✔ (ubuntu从19.04开始)</li><li><code>V2Ray</code>: ✘</li></ul></blockquote><p><code>V2Ray</code>的官方安装脚本在国内下载速度很慢，经常失败。结合上面信息，应选择优先安装<code>Trojan</code>，然后在终端下开启科学上网模式，再安装<code>V2Ray</code>。<strong><em>安装流程全自动，一切都很Nice。</em></strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">trojan_environment_varibles</span></span>() &#123;</span><br><span class="line">    TROJAN_PREFIX=/directory/to/trojan/real/config.json</span><br><span class="line">    TROJAN_CERT=<span class="variable">$TROJAN_PREFIX</span>/cert.pem</span><br><span class="line">    TROJAN_CERT_PATH_IN_CONFIG=<span class="variable">$TROJAN_CERT</span></span><br><span class="line">    TROJAN_CONFIG=<span class="variable">$TROJAN_PREFIX</span>/config.json</span><br><span class="line">    <span class="comment"># trojan模板配置文件</span></span><br><span class="line">    TROJAN_CONFIG_EXAMPLE=<span class="variable">$TROJAN_PREFIX</span>/config_example.json</span><br><span class="line">    </span><br><span class="line">    TROJAN_SERVER=<span class="variable">$SERVER_NAME</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">trojan_install_for_old_distributor</span></span>() &#123;</span><br><span class="line">    <span class="comment"># 当官方仓库中不含trojan时安装流程</span></span><br><span class="line">    <span class="comment"># 证书 位于 /usr/local/etc/ssl/cert.pem</span></span><br><span class="line">    <span class="comment"># 配置文件 位于 /usr/local/etc/trojan/config.json</span></span><br><span class="line">    <span class="comment"># 新建trojan用户，由trojan用户开启服务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">trojan_install</span></span>() &#123;</span><br><span class="line">    <span class="comment"># 设置trojan相关环境变量</span></span><br><span class="line">    trojan_environment_varibles</span><br><span class="line">    <span class="comment"># 若trojan配置文件不存在，则从模板配置文件复制一份</span></span><br><span class="line">    [ ! -f <span class="variable">$TROJAN_CONFIG</span> ] &amp;&amp; cp <span class="variable">$TROJAN_CONFIG_EXAMPLE</span> <span class="variable">$TROJAN_CONFIG</span></span><br><span class="line">    <span class="keyword">if</span> ! <span class="built_in">command</span> -v trojan &gt; /dev/null 2&gt;&amp;1; <span class="keyword">then</span></span><br><span class="line">        TROJAN_CONFIG=/path/to/模板配置文件</span><br><span class="line">        TROJAN_CERT=/path/to/本地证书</span><br><span class="line">        <span class="keyword">if</span> 满足条件：Ubuntu及版本在19.04及以上; <span class="keyword">then</span></span><br><span class="line">            sudo apt install trojan</span><br><span class="line">            sudo ln -sf <span class="variable">$TROJAN_CONFIG</span> /etc/trojan/config.json</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            trojan_install_for_old_distributor</span><br><span class="line">            TROJAN_CERT_PATH_IN_CONFIG=/usr/<span class="built_in">local</span>/etc/ssl/cert.pem</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="comment"># 设置配置文件中的证书路径</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable">$TROJAN_CONFIG</span>中不含<span class="variable">$TROJAN_CERT_PATH_IN_CONFIG</span>; <span class="keyword">then</span></span><br><span class="line">        sed -i <span class="string">"s|\"cert.*|\"cert\": \"<span class="variable">$TROJAN_CERT_PATH_IN_CONFIG</span>\",|"</span> <span class="variable">$TROJAN_CONFIG</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    trojan_first_start</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置文件">配置文件</h3><p>这里只讨论Trojan在本地的配置以及相关脚本。Trojan的客户端配置中有三项在切换VPS时需要修改，分别是</p><table><thead><tr class="header"><th style="text-align:center">配置选项</th><th style="text-align:center">VPS</th></tr></thead><tbody><tr class="odd"><td style="text-align:center"><code>remote_addr</code></td><td style="text-align:center"><code>IP/域名</code></td></tr><tr class="even"><td style="text-align:center"><code>sni</code></td><td style="text-align:center"><code>域名</code></td></tr><tr class="odd"><td style="text-align:center"><code>cert</code></td><td style="text-align:center"><code>本地证书路径</code></td></tr></tbody></table><p>因为使用了<code>CloudFlare</code>家的泛域名证书，因此在多个VPS上可以使用同一套证书，意味着即使在配置文件中<strong>本地证书路径</strong>使用了软链接地址，也无需对其指向的证书文件做任何修改。因此在切换VPS时，真正需要修改的只有两个地方：<code>remote_addr</code>和<code>sni</code>。</p><p><code>remote_addr</code>选择的规则为</p><table><thead><tr class="header"><th style="text-align:center">分类</th><th style="text-align:center">DNS</th><th style="text-align:center">Proxy</th></tr></thead><tbody><tr class="odd"><td style="text-align:center"><code>remote_addr</code></td><td style="text-align:center"><code>IP</code>或者<code>域名</code></td><td style="text-align:center"><code>IP</code></td></tr></tbody></table><p>原因在于<code>remote_addr</code>必须解析到VPS自己的<code>IP</code>。</p><h3 id="切换vps并重启服务的脚本">切换VPS并重启服务的脚本</h3><p>根据上面的分析，采用模板配置文件的方式，选取特定的VPS后，用<code>sed</code>直接修改配置文件中上述两个选项的值，再用<code>service</code>命令重启服务。</p><h4 id="vps信息">VPS信息</h4><p>VPS的相关信息，都存放在文件<code>server_info.ini</code>中，如下所示：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[cloudcone]</span></span><br><span class="line"><span class="attr">ip</span> = xxx.xxx.xxx.xxx</span><br><span class="line"><span class="attr">domain</span> = www.example.com</span><br><span class="line"><span class="attr">dns_proxy</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="section">[racknerd]</span></span><br><span class="line"><span class="attr">ip</span> = xxx.xxx.xxx.xxx</span><br><span class="line"><span class="attr">domain</span> = www.example2.com</span><br><span class="line"><span class="attr">dns_proxy</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p></p><p>借助<code>awk</code>定义两个函数用于读取<code>ini</code>文件中的服务器信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">SERVER_INFO_FILE=/path/to/server_info.ini</span><br><span class="line"><span class="comment"># 收集VPS入口信息</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">read_section_ini</span></span>() &#123;</span><br><span class="line">    INI_FILE=<span class="variable">$1</span></span><br><span class="line">    awk -F <span class="string">'='</span> <span class="string">'&#123;</span></span><br><span class="line"><span class="string">        if ($1 ~ /\[/) &#123;</span></span><br><span class="line"><span class="string">            gsub(/[\[\]]/, "", $1)</span></span><br><span class="line"><span class="string">            print $1</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;'</span> <span class="variable">$INI_FILE</span></span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取特定VPS的信息</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">read_ini</span></span>() &#123;</span><br><span class="line">    INI_FILE=<span class="variable">$1</span></span><br><span class="line">    SECTION=<span class="variable">$&#123;2:-cloudcone&#125;</span></span><br><span class="line">    KEY=<span class="variable">$&#123;3:-ip&#125;</span></span><br><span class="line">    awk -F <span class="string">'='</span> <span class="string">'&#123;</span></span><br><span class="line"><span class="string">    if ($1 ~ /\[/)</span></span><br><span class="line"><span class="string">        if ($1 ~ /\['</span><span class="variable">$SECTION</span><span class="string">'/) &#123;</span></span><br><span class="line"><span class="string">            a = 1</span></span><br><span class="line"><span class="string">        &#125; else &#123;</span></span><br><span class="line"><span class="string">            a = 0</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    else</span></span><br><span class="line"><span class="string">        if (a == 1 &amp;&amp; $1 ~ /'</span><span class="variable">$KEY</span><span class="string">'/) &#123;</span></span><br><span class="line"><span class="string">            gsub(/[[:blank:]]/, "", $2)</span></span><br><span class="line"><span class="string">            print $2</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;'</span> <span class="variable">$INI_FILE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VPS_SERVERS=($(read_section_ini <span class="variable">$SERVER_INFO_FILE</span>))</span><br></pre></td></tr></table></figure><p></p><h4 id="切换vps脚本">切换VPS脚本</h4><p>接下来就涉及到<code>Trojan</code>和<code>V2Ray</code>相关的脚本了，同样定义两个函数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">choose_server_for_trojan</span></span>() &#123;</span><br><span class="line">    TROJAN_SERVER=<span class="variable">$1</span></span><br><span class="line">    TROJAN_CONFIG=/path/to/trojan的模板配置文件</span><br><span class="line">    <span class="comment"># 获取选定VPS的具体信息</span></span><br><span class="line">    dns_proxy=$(read_ini <span class="variable">$SERVER_INFO_FILE</span> <span class="variable">$TROJAN_SERVER</span> dns_proxy)</span><br><span class="line">    ip=$(read_ini <span class="variable">$SERVER_INFO_FILE</span> <span class="variable">$TROJAN_SERVER</span> ip)</span><br><span class="line">    sni=$(read_ini <span class="variable">$SERVER_INFO_FILE</span> <span class="variable">$TROJAN_SERVER</span> sni)</span><br><span class="line">    <span class="keyword">if</span> <span class="variable">$dns_proxy</span>; <span class="keyword">then</span></span><br><span class="line">        remote_addr=<span class="variable">$ip</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        remote_addr=<span class="variable">$sni</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="comment"># 修改模板配置文件</span></span><br><span class="line">    sed -i <span class="string">"s|\"remote_addr.*|\"remote_addr\": \"<span class="variable">$remote_addr</span>\",|"</span> <span class="variable">$TROJAN_CONFIG</span></span><br><span class="line">    sed -i <span class="string">"s|\"sni.*|\"sni\": \"<span class="variable">$sni</span>\",|"</span> <span class="variable">$TROJAN_CONFIG</span></span><br><span class="line">    <span class="comment"># 重启Trojan服务</span></span><br><span class="line">    sudo service trojan restart</span><br><span class="line">    sudo service trojan status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">choose_server_for_v2ray</span></span>() &#123;</span><br><span class="line">    <span class="comment"># V2Ray相关配置修改</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 核心逻辑部分</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">change_server</span></span>() &#123;</span><br><span class="line">    <span class="comment"># 可用的VPS都存放在数组变量 VPS_SERVERS 中，传入的参数为数组下标，</span></span><br><span class="line">    <span class="comment"># 用于选取特定 VPS</span></span><br><span class="line">    VPS_SERVERS=($(read_section_ini <span class="variable">$SERVER_INFO_FILE</span>))</span><br><span class="line">    SERVER_ID=<span class="variable">$&#123;1:-0&#125;</span></span><br><span class="line">    SERVER_NAME=$(VPS_SERVERS[<span class="variable">$SERVER_ID</span>])</span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$SERVER_ID</span> -ge 0 ] &amp;&amp; [ <span class="variable">$SERVER_ID</span> -lt <span class="variable">$&#123;#VPS_SERVERS[*]&#125;</span> ]; <span class="keyword">then</span></span><br><span class="line">        choose_server_for_trojan <span class="variable">$SERVER_NAME</span></span><br><span class="line">        choose_server_for_v2ray <span class="variable">$SERVER_NAME</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"错误：VPS服务器不存在"</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"尝试：'<span class="variable">$COMMAND</span> -i' 查看可用服务器"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>都到这个程度了，干脆写成一个简单的命令行程序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 除了上面提到的函数外，再定义三个函数，用于实现相应的命令参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">show_help</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"欢迎使用本脚本切换VPS服务器"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"用法：vps_server 选项"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"选项："</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"  -h [--help]         显示本帮助"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"  -s [--server=val]   通过val选择不同VPS服务器"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"  -i [--info]         显示可用服务器汇总信息"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"  -c [--current]      显示当前使用的VPS服务器"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">show_servers_info</span></span>() &#123;</span><br><span class="line">    <span class="comment"># shellcheck disable=SC2128,2207</span></span><br><span class="line">    [ -z <span class="string">"<span class="variable">$VPS_SERVERS</span>"</span> ] &amp;&amp; VPS_SERVERS=($(read_section_ini <span class="variable">$SERVER_INFO_FILE</span>))</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"可用的服务器有："</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;!VPS_SERVERS[@]&#125;</span>"</span>; <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"    <span class="variable">$i</span> ): <span class="variable">$&#123;VPS_SERVERS[i]&#125;</span>"</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">""</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"服务器端安装完成："</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"    将证书下载至客户端所在主机并放置在正确路径"</span>   </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"    客户端配置文件中需指定证书（或其软链接）路径"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"    若CloudFlare中开启了代理，则客户端配置文件中只能使用IP。"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">""</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"客户端安装完成："</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"    从服务器上下载证书并安装"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"    配置文件中需指定证书绝对路径"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"    |             |       |    remote_addr   |"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"    |             |       |   IP   |   域名  |"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"    | CloudFlare  |  DNS  |    ✔   |    ✔    |"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"    |             | Proxy |    ✔   |    ✘    |"</span> </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">get_current_server</span></span>() &#123;</span><br><span class="line">    awk -F <span class="string">':'</span> <span class="string">'&#123;</span></span><br><span class="line"><span class="string">        if ($1 ~ /\"sni/) &#123;</span></span><br><span class="line"><span class="string">            gsub(/\"/, "", $2)</span></span><br><span class="line"><span class="string">            print $2</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;'</span> <span class="variable">$TROJAN_PREFIX</span>/config.json</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># while循环与case结构处理命令参数</span></span><br><span class="line"><span class="keyword">while</span> [[ <span class="variable">$#</span> -ge 1 ]]; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span></span><br><span class="line">        -h|--<span class="built_in">help</span> )</span><br><span class="line">            show_help</span><br><span class="line">            ;;</span><br><span class="line">        -i|--info)</span><br><span class="line">            show_servers_info</span><br><span class="line">            ;; </span><br><span class="line">        -c|--current)</span><br><span class="line">            VPS=$(get_current_server)</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"当前VPS服务器："</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"    <span class="variable">$&#123;VPS%%.*&#125;</span>"</span></span><br><span class="line">            ;;</span><br><span class="line">        -s|--server) </span><br><span class="line">            <span class="built_in">shift</span></span><br><span class="line">            <span class="keyword">if</span> [[ <span class="variable">$#</span> -ge 1 ]]; <span class="keyword">then</span></span><br><span class="line">                ID=<span class="variable">$1</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ID=0</span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">            change_server <span class="variable">$ID</span></span><br><span class="line">            ;;</span><br><span class="line">        *)</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"错误：未识别选项 '<span class="variable">$1</span>'"</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"尝试 '<span class="variable">$COMMAND</span> -h|--help' 查看帮助信息"</span></span><br><span class="line">            ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目前在用的科学上网工具有两款：&lt;strong&gt;Trojan&lt;/strong&gt;和&lt;strong&gt;V2Ray&lt;/strong&gt;。V2Ray的使用方式有很多，这里不作详细记录。Trojan的优势在于配置相对简单、采用的科学上网的方法不易被发现、速度快。V2Ray的优势在于功能齐全
      
    
    </summary>
    
      <category term="科学上网" scheme="http://spiedeman.github.io/categories/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
    
      <category term="VPS" scheme="http://spiedeman.github.io/tags/VPS/"/>
    
      <category term="Trojan" scheme="http://spiedeman.github.io/tags/Trojan/"/>
    
      <category term="V2Ray" scheme="http://spiedeman.github.io/tags/V2Ray/"/>
    
  </entry>
  
  <entry>
    <title>记快手笔试大题</title>
    <link href="http://spiedeman.github.io/posts/d82964a7/"/>
    <id>http://spiedeman.github.io/posts/d82964a7/</id>
    <published>2019-09-16T13:57:09.000Z</published>
    <updated>2021-09-18T02:10:59.612Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一题">第一题</h3><h4 id="题目描述">题目描述</h4><p>输入一个英文句子，词之间有 <code>1</code> 个或若干个空格，句子以英文标点 &quot;.&quot; 结尾。 要求颠倒该句子中的词语顺序，并且词之间有且只有一个空格，结尾仍是 &quot;.&quot;，结尾的 &quot;.&quot; 与前一个单词之间无空格。</p><h4 id="代码">代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">line = sys.stdin.readline().strip().split()</span><br><span class="line"><span class="keyword">if</span> line[<span class="number">-1</span>] == <span class="string">'.'</span>:</span><br><span class="line">    line = line[:<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    line[<span class="number">-1</span>] = line[<span class="number">-1</span>][:<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">' '</span>.join(line[::<span class="number">-1</span>]) + <span class="string">'.'</span></span><br></pre></td></tr></table></figure><h3 id="第二题">第二题</h3><h4 id="题目描述-1">题目描述</h4><p>已知两个字符串<code>strA</code>和<code>strB</code>，求将<code>strA</code>转换成<code>strB</code>所需的最小编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。</p><p>本题参考<a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">LeetCode 第72题——编辑距离</a></p><h4 id="代码-1">代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">strA = sys.stdin.readline().strip()</span><br><span class="line">strB = sys.stdin.readline().strip()</span><br><span class="line">n1, n2 = len(strA), len(strB)</span><br><span class="line">dp = [[<span class="number">0</span>] * (n2 + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n1 + <span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n2 + <span class="number">1</span>):</span><br><span class="line">    dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n1 + <span class="number">1</span>):</span><br><span class="line">    dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n1 + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n2 + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> strA[i<span class="number">-1</span>] == strB[j<span class="number">-1</span>]:</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp[i][j] = <span class="number">1</span> + min(dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j<span class="number">-1</span>])</span><br><span class="line"><span class="keyword">print</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h3 id="第三题">第三题</h3><h4 id="题目描述-2">题目描述</h4><p>我们知道每一个大于 <code>1</code> 的数都一定是质数或者可以用质数的乘积来表示，如 <code>10=2*5</code>。现在请设计一个程序，对于给定的一个 <code>(1, N]</code> 之间的正整数（<code>N</code> 取值不超过 <code>10</code> 万），你需要统计 <code>(1, N]</code> 之间所有正整数的质数分解后，所有质数个数的总和。举例，输入数据 <code>6</code>，那么满足 <code>(1, 6])</code> 的整数为 <code>2, 3, 4, 5, 6</code>，各自进行质数分解后为：<code>2=&gt;2, 3=&gt;3, 4=&gt;2*2, 5=&gt;5, 6=&gt;2*3</code>。对应的质数个数即 <code>1, 1, 2, 1, 2</code>。最后统计总数为 <code>7</code>。</p><p>本题是完全自己做出来的，复用了求质数的筛法。 &gt; 关键点在 若 <span class="math inline">\(n = a\times b\)</span>，则 <span class="math inline">\(f(n) = f(a)+f(b)\)</span>。</p><h4 id="代码-2">代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prime_sieve</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">"""返回所有小于 n 的质数"""</span></span><br><span class="line">    sieve = [<span class="literal">True</span>] * (n // <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, int(n**<span class="number">0.5</span>) + <span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> sieve[i // <span class="number">2</span>]:</span><br><span class="line">            sieve[i *i // <span class="number">2</span>::i] = [<span class="literal">False</span>] * ((n - i * i - <span class="number">1</span>) // (<span class="number">2</span> * i) + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">2</span>] + [<span class="number">2</span> * i + <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n // <span class="number">2</span>) <span class="keyword">if</span> sieve[i]]</span><br><span class="line"></span><br><span class="line">n = int(sys.stdin.readline().strip())</span><br><span class="line"></span><br><span class="line">primes = prime_sieve(n + <span class="number">1</span>)</span><br><span class="line">data = &#123;p: <span class="number">1</span> <span class="keyword">for</span> p <span class="keyword">in</span> primes&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">help</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">return</span> data[n]</span><br><span class="line">    i, n0 = <span class="number">0</span>, n</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> ans:</span><br><span class="line">        c, p = <span class="number">0</span>, primes[i]</span><br><span class="line">        <span class="keyword">while</span> n % p == <span class="number">0</span>:</span><br><span class="line">            c += <span class="number">1</span></span><br><span class="line">            n = n // p</span><br><span class="line">        <span class="keyword">if</span> c:</span><br><span class="line">            ans = c + help(n)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    data[n0] = ans</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">    ans += help(m)</span><br><span class="line"><span class="keyword">print</span> ans</span><br></pre></td></tr></table></figure><h3 id="第四题">第四题</h3><h4 id="题目描述-3">题目描述</h4><p>给定一个数独板的输入，确认当前的填法是否合法。 合法的输入需要满足一下三个条件： 1. 每一行的<code>9</code>个格子中是<code>1-9</code>的<code>9</code>个数字，且没有重复 2. 每一列的<code>9</code>个格子中是<code>1-9</code>的<code>9</code>个数字，且没有重复 3. <code>9</code>个<code>3*3</code>的小格子中是<code>1-9</code>的<code>9</code>个数字，且没有重复</p><p>空格用<code>X</code>表示</p><p>本题抄自己的代码<a href="https://leetcode-cn.com/problems/valid-sudoku/" target="_blank" rel="noopener">LeetCode 第36题——有效的数独</a> #### 代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">board = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">    board.append(sys.stdin.readline().strip())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">help</span><span class="params">(board)</span>:</span></span><br><span class="line">    board_t = zip(*board)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> i == j:</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">                    col = [n <span class="keyword">for</span> n <span class="keyword">in</span> board[<span class="number">3</span>*i+k] <span class="keyword">if</span> n!=<span class="string">'X'</span>]</span><br><span class="line">                    <span class="keyword">if</span> len(col) != len(set(col)):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                    row = [n <span class="keyword">for</span> n <span class="keyword">in</span> board_t[<span class="number">3</span>*i+k] <span class="keyword">if</span> n!=<span class="string">'X'</span>]</span><br><span class="line">                    <span class="keyword">if</span> len(row) != len(set(row)):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            block = set()</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">                <span class="keyword">for</span> s <span class="keyword">in</span> board[<span class="number">3</span>*i+k][<span class="number">3</span>*j:<span class="number">3</span>*j+<span class="number">3</span>]:</span><br><span class="line">                    <span class="keyword">if</span> s != <span class="string">'X'</span>:</span><br><span class="line">                        <span class="keyword">if</span> s <span class="keyword">in</span> block:</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                        block.add(s)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'true'</span> <span class="keyword">if</span> help(board) <span class="keyword">else</span> <span class="string">'false'</span></span><br></pre></td></tr></table></figure><p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;第一题&quot;&gt;第一题&lt;/h3&gt;&lt;h4 id=&quot;题目描述&quot;&gt;题目描述&lt;/h4&gt;&lt;p&gt;输入一个英文句子，词之间有 &lt;code&gt;1&lt;/code&gt; 个或若干个空格，句子以英文标点 &amp;quot;.&amp;quot; 结尾。 要求颠倒该句子中的词语顺序，并且词之间有且只有一个空格，结尾
      
    
    </summary>
    
      <category term="算法" scheme="http://spiedeman.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="面试" scheme="http://spiedeman.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>记三七互娱笔试大题</title>
    <link href="http://spiedeman.github.io/posts/a8055618/"/>
    <id>http://spiedeman.github.io/posts/a8055618/</id>
    <published>2019-09-10T07:23:29.000Z</published>
    <updated>2021-09-18T02:10:59.612Z</updated>
    
    <content type="html"><![CDATA[<p><strong>三七互娱</strong>共两道算法大题，总共就一个小时的笔试时间，总感觉时间不够用。最后一题确实因为时间不够没写完，好在思路有了用注释提了一下，不知道能不能酌情给分:joy:。</p><h4 id="第一题">第一题</h4><p><strong>描述</strong>：给一个数组，其中 <span class="math inline">\(1 \le A[i]\le n\)</span>。有些元素出现两次，有些出现一次，返回所有出现两次的元素。</p><p><strong>解答</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(array)</span>:</span></span><br><span class="line">    count = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> array:</span><br><span class="line">        <span class="keyword">if</span> a <span class="keyword">not</span> <span class="keyword">in</span> array:</span><br><span class="line">            count[a] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count[a] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> [key <span class="keyword">for</span> key <span class="keyword">in</span> count <span class="keyword">if</span> count[key] == <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p></p><h4 id="第二题">第二题</h4><p><strong>描述</strong>：小明有想设计一个随机算法来听歌，并且希望每首歌被选中的概率正比于它的豆瓣评分。如歌 A 和 B 的评分分别为 <span class="math inline">\(8.5\)</span> 和 <span class="math inline">\(9.3\)</span>，则这两首歌被选中的概率的比为 <span class="math inline">\(85:93\)</span>。现给出 <span class="math inline">\(1000\)</span> 首歌的豆瓣评分，请设计一个随机算法并实现它。</p><p><strong>解答</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(songs, scores)</span>:</span></span><br><span class="line">    n = len(songs)</span><br><span class="line">    <span class="comment"># 假设评分只有一位小数</span></span><br><span class="line">    srange = [<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        srange.append(srange[<span class="number">-1</span>] + int(scores[i] * <span class="number">10</span>))</span><br><span class="line">    <span class="comment"># 生成 [0, srange[-1]] 范围的均匀随机数 rand</span></span><br><span class="line">    rand = random.uniform(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    rand = int(rand * srange[<span class="number">-1</span>])</span><br><span class="line">    <span class="comment"># 二分法查找 rand 落在 srange 的哪个区间中</span></span><br><span class="line">    i, j = <span class="number">0</span>, n</span><br><span class="line">    m = (i + j) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        <span class="keyword">if</span> srange[m] &lt;= rand &lt; srange[m+<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> songs[m]</span><br><span class="line">        <span class="keyword">if</span> srange[m] &gt; rand:</span><br><span class="line">            j = m</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i = m + <span class="number">1</span></span><br><span class="line">        m = (i + j) // <span class="number">2</span></span><br></pre></td></tr></table></figure><p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;三七互娱&lt;/strong&gt;共两道算法大题，总共就一个小时的笔试时间，总感觉时间不够用。最后一题确实因为时间不够没写完，好在思路有了用注释提了一下，不知道能不能酌情给分:joy:。&lt;/p&gt;&lt;h4 id=&quot;第一题&quot;&gt;第一题&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;描述&lt;/
      
    
    </summary>
    
      <category term="算法" scheme="http://spiedeman.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="面试" scheme="http://spiedeman.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>记小米一面算法题——人民币大写金额转换</title>
    <link href="http://spiedeman.github.io/posts/8bd25443/"/>
    <id>http://spiedeman.github.io/posts/8bd25443/</id>
    <published>2019-09-09T14:01:15.000Z</published>
    <updated>2021-09-18T02:10:59.612Z</updated>
    
    <content type="html"><![CDATA[<p>30分钟小米算法工程师一面，由于没有项目经历面试官给了一道算法题，现撸代码。毫无意外，快速码代码向来不是我的强项。</p><p>特此记录失败史</p><h3 id="题目描述">题目描述</h3><p>根据人民币大写金额规范，将浮点数转换为人民币读法字符串需要注意以下几点： 1. 数字中间有连续一个或以上个 0 时，只写一个<strong>零</strong>。如 ¥ 140,090.3，应写作人民币十四万零玖拾元叁角。 2. 角位非 0 时，<strong>元</strong>后面可以不加<strong>零</strong>。如 ¥ 1690.32，可以写作人民币壹仟陆佰玖拾元叁角[零]贰分。 3. 角位是 0，分位不是 0 时，大写金额<strong>元</strong>后面应写<strong>零</strong>。如 ¥ 325.04，应写为人民币叁佰贰拾元零肆分。 4. 角和分都是 0 时，<strong>元</strong>后面应写上<strong>整</strong>或<strong>正</strong>。如 ¥ 1234.00，应写为人民币壹仟贰佰叁拾肆元（整/正）。</p><p><strong>注意</strong>：最小单位为<strong>分</strong>。</p><h3 id="题解">题解</h3><p>中文数字读法以 4 个数字为一个组，辅以单位如<strong>万、亿、兆、京</strong>等。这里取到最高为<strong>亿</strong>。由于每组单位不同，一度不知如何处理。因为金额大小没有限制，所以数字位数可以很大，如果根据单位用<code>if...else...</code>语句，是行不通的。 后来发现，还是可以使用<strong>递归</strong>来解决问题。</p><p>至于<strong>零</strong>的处理，可以设定字符串替换规则，使得处理后满足规范。</p><h3 id="代码">代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">ch_num = [<span class="string">'零'</span>, <span class="string">'壹'</span>, <span class="string">'贰'</span>, <span class="string">'叁'</span>, <span class="string">'肆'</span>, <span class="string">'伍'</span>, <span class="string">'陆'</span>, <span class="string">'柒'</span>, <span class="string">'捌'</span>, <span class="string">'玖'</span>]</span><br><span class="line">ch_num = dict(zip(<span class="string">'0123456789'</span>, ch_num))</span><br><span class="line"></span><br><span class="line">ch_unit = [<span class="string">''</span>, <span class="string">'万'</span>, <span class="string">'亿'</span>]</span><br><span class="line">ch_unit = dict(zip(range(<span class="number">3</span>), ch_unit)) </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_int</span><span class="params">(intPart)</span>:</span></span><br><span class="line">    <span class="string">""" 转换整数部分</span></span><br><span class="line"><span class="string">    intPart: str</span></span><br><span class="line"><span class="string">    return: str</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> len(intPart) &lt;= <span class="number">4</span>:</span><br><span class="line">        <span class="comment"># 若长度小于 4， 则补足到 4 位。</span></span><br><span class="line">        ans = [ch_num[c] <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">'0'</span>*(<span class="number">4</span>-len(intPart))+intPart]</span><br><span class="line">        <span class="keyword">if</span> ans[<span class="number">-1</span>] == ch_num[<span class="string">'0'</span>]:</span><br><span class="line">            ans = <span class="string">'&#123;&#125;仟&#123;&#125;佰&#123;&#125;拾'</span>.format(*ans[:<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ans = <span class="string">'&#123;&#125;仟&#123;&#125;佰&#123;&#125;拾&#123;&#125;'</span>.format(*ans)</span><br><span class="line">        <span class="comment"># 处理中间有 0 的情况</span></span><br><span class="line">        ans = ans.replace(<span class="string">'零仟'</span>, ch_num[<span class="string">'0'</span>]) </span><br><span class="line">        ans = ans.replace(<span class="string">'零佰'</span>, ch_num[<span class="string">'0'</span>]) </span><br><span class="line">        ans = ans.replace(<span class="string">'零拾'</span>, ch_num[<span class="string">'0'</span>]) </span><br><span class="line">        <span class="comment"># 处理中间连续多个 0，末尾有零的情况</span></span><br><span class="line">        ans = re.sub(<span class="string">'零+'</span>, ch_num[<span class="string">'0'</span>], ans)</span><br><span class="line">        ans = re.sub(<span class="string">'零+$'</span>, ch_unit[<span class="number">0</span>], ans)</span><br><span class="line">        <span class="comment"># 若开头有 0 且整数部分长度小于 4，则丢弃开头的’零‘（只有 1 个）。</span></span><br><span class="line">        <span class="keyword">return</span> ans[<span class="number">4</span>!=len(intPart):]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 金额数字长度可以写成 n = 4 * u + r</span></span><br><span class="line">        u, r = len(intPart) // <span class="number">4</span>, len(intPart) % <span class="number">4</span></span><br><span class="line">        <span class="comment"># 若 r = 0，则 u = u - 1，至少先处理开头 4 位。之后再看 u，</span></span><br><span class="line">        <span class="comment"># 若 u &gt; 2，则先处理不包括最后 8 位的部分，否则就先只处理开头 4 位。</span></span><br><span class="line">        i = r * (r != <span class="number">0</span>) + <span class="number">4</span> * (max(u - <span class="number">2</span> - (r == <span class="number">0</span>), <span class="number">0</span>) + (r == <span class="number">0</span>))</span><br><span class="line">        <span class="comment"># 于是分成两部分递归处理 intPart[:i] 和 intPart[i:]</span></span><br><span class="line">        left, right = convert_int(intPart[:i]), convert_int(intPart[i:])</span><br><span class="line">        <span class="comment"># 若左部分返回空字符串 ''，则不加单位，即 j = 0 and ch_unit[j] = ''。</span></span><br><span class="line">        <span class="comment"># 又因为最大单位为“亿”，所以 0 &lt;= j &lt;= 2</span></span><br><span class="line">        j = min(u - (r == <span class="number">0</span>), <span class="number">2</span>) <span class="keyword">if</span> left <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 得到单位</span></span><br><span class="line">        unit = ch_unit[j]</span><br><span class="line">        <span class="comment"># 返回最终结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&#123;&#125;&#123;&#125;&#123;&#125;'</span>.format(left, unit, right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_decimal</span><span class="params">(decimalPart)</span>:</span></span><br><span class="line">    <span class="string">""" 处理小数部分，容易多了</span></span><br><span class="line"><span class="string">    decimalPart: str</span></span><br><span class="line"><span class="string">    return: str</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    ans = [ch_num[c] <span class="keyword">for</span> c <span class="keyword">in</span> decimalPart + <span class="string">'0'</span> * (<span class="number">2</span> - len(decimalPart))]</span><br><span class="line">    ans = <span class="string">'&#123;&#125;角&#123;&#125;分'</span>.format(*ans)</span><br><span class="line">    ans = ans.replace(<span class="string">'零角'</span>, ch_num[<span class="string">'0'</span>])</span><br><span class="line">    ans = ans.replace(<span class="string">'零分'</span>, ch_unit[<span class="number">0</span>])</span><br><span class="line">    ans = re.sub(<span class="string">'零+$'</span>, ch_unit[<span class="number">0</span>], ans)</span><br><span class="line">    <span class="comment"># 因为使用递归处理整数部分，所以整数部分单位“元”放在这里处理。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'元&#123;&#125;'</span>.format(ans <span class="keyword">or</span> <span class="string">'整'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_RMB</span><span class="params">(money)</span>:</span></span><br><span class="line">    <span class="string">""" 将浮点数转换为大写人民币规范读法</span></span><br><span class="line"><span class="string">    money: str</span></span><br><span class="line"><span class="string">    return: str</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'.'</span> <span class="keyword">in</span> money:</span><br><span class="line">        intPart, decimalPart = money.split(<span class="string">'.'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        intPart, decimalPart = money, ch_unit[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'人民币&#123;&#125;&#123;&#125;'</span>.format(convert_int(intPart), convert_decimal(decimalPart))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;30分钟小米算法工程师一面，由于没有项目经历面试官给了一道算法题，现撸代码。毫无意外，快速码代码向来不是我的强项。&lt;/p&gt;&lt;p&gt;特此记录失败史&lt;/p&gt;&lt;h3 id=&quot;题目描述&quot;&gt;题目描述&lt;/h3&gt;&lt;p&gt;根据人民币大写金额规范，将浮点数转换为人民币读法字符串需要注意以下几点：
      
    
    </summary>
    
      <category term="算法" scheme="http://spiedeman.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="面试" scheme="http://spiedeman.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Vim 插件配置</title>
    <link href="http://spiedeman.github.io/posts/6e83abdb/"/>
    <id>http://spiedeman.github.io/posts/6e83abdb/</id>
    <published>2019-09-02T02:18:29.000Z</published>
    <updated>2021-09-18T02:10:59.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="语法检查与代码格式化ale">语法检查与代码格式化——ALE</h2><h3 id="异步检查语法">异步检查语法</h3><ul><li><a href="https://pycodestyle.readthedocs.io/en/latest/#" target="_blank" rel="noopener">pycodestyle</a> —— 前身为pep8，检查Python语法以及格式</li></ul><p><strong>安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pycodestyle</span><br></pre></td></tr></table></figure><p></p><p><strong>配置</strong></p><p>配置文件在 <code>~/.config/pycodestyle</code>。</p><h3 id="代码格式化">代码格式化</h3><ul><li><a href="https://github.com/google/yapf" target="_blank" rel="noopener">yapf</a> —— Google出品的Python代码格式化工具</li><li><a href="https://isort.readthedocs.io/en/latest/#" target="_blank" rel="noopener">isort</a> —— 格式化 <code>import</code> 语句</li></ul><p><strong>安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install yapf</span><br><span class="line">pip install isort</span><br></pre></td></tr></table></figure><p></p><p><strong>配置</strong></p><p>配置文件在 <code>~/.config/yapf/style</code> 和 <code>~/.isort.cfg</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;语法检查与代码格式化ale&quot;&gt;语法检查与代码格式化——ALE&lt;/h2&gt;&lt;h3 id=&quot;异步检查语法&quot;&gt;异步检查语法&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://pycodestyle.readthedocs.io/en/latest/#&quot; targe
      
    
    </summary>
    
      <category term="Vim" scheme="http://spiedeman.github.io/categories/Vim/"/>
    
    
      <category term="Vim-插件" scheme="http://spiedeman.github.io/tags/Vim-%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>字符串匹配之KMP算法</title>
    <link href="http://spiedeman.github.io/posts/b5ae7cab/"/>
    <id>http://spiedeman.github.io/posts/b5ae7cab/</id>
    <published>2019-08-18T03:20:11.000Z</published>
    <updated>2021-09-18T02:10:59.542Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>问题</strong>：给定长度为 <span class="math inline">\(n\)</span>，<span class="math inline">\(m\)</span> 的<strong>目标</strong>字符串<code>s</code>和<strong>模式</strong>字符串<code>p</code>，判断<code>p</code>是否是<code>s</code>的子串。若是， 返回匹配位置；否则返回 <span class="math inline">\(-1\)</span>。</p></blockquote><h4 id="暴力算法">暴力算法</h4><ul><li>模式串从目标串的<strong>第一个元素</strong>开始匹配</li><li>匹配失败，则<strong>目标串</strong>右移一位重新判断是否匹配模式串</li></ul><img src="/posts/b5ae7cab/bf-1.gif" title="暴力算法最优情况"><table style="width:10%"><colgroup><col style="width:9%"></colgroup><tbody><tr class="odd"><td>最坏情况为 <span class="math inline">\(O(mn)\)</span>。</td></tr><tr class="even"><td><img src="/posts/b5ae7cab/bf-2.gif" title="暴力算法最坏情况"></td></tr></tbody></table><h4 id="kmp">KMP</h4><p>通过观察我们可以提问： &gt; 是否遇到不匹配时，只能右移 <strong>一位</strong> 重新判断？</p><p>当模式串的第 <span class="math inline">\(k\)</span> 位失配时，前 <span class="math inline">\(k-1\)</span> 位是已经匹配的。那么可以问这样一个问题： &gt; 右移多少位之后匹配的指针不必往前移动，在当前位置的基础上继续往后开始匹配，直到匹配成功或者再次遇到失配位？</p><img src="/posts/b5ae7cab/kmp-1.gif" title="kmp算法示意图"><table style="width:8%"><colgroup><col style="width:8%"></colgroup><tbody><tr class="odd"><td>首先提出一个概念：字符串前缀和后缀的<strong>最大公共长度</strong>。假设最大公共长度为 <span class="math inline">\(j\)</span>，字符串长度为 <span class="math inline">\(n\)</span>，那么右移 <span class="math inline">\(n-j\)</span> 位后，前 <span class="math inline">\(j\)</span> 位是已经匹配了的。</td></tr><tr class="even"><td><img src="/posts/b5ae7cab/kmp-2.jpg" title="前后缀最大公共长度"></td></tr></tbody></table><p><strong>最大公共长度</strong>中的<strong>最大</strong>表示为了匹配需要右移的<strong>最少</strong>位数。也许右移更多位也能匹配，但可能会漏掉解。</p><table style="width:8%"><colgroup><col style="width:8%"></colgroup><tbody><tr class="odd"><td>#### Next数组 现在我们清楚了，为了使匹配指针不往前移，有效利用已经获得的匹配信息，我们需要对模式串进行预处理。直观地说就是我们需要知道当匹配到模式串的第几个元素失配时，应该右移多少位。这就是<strong>Next数组</strong>的含义。</td></tr><tr class="even"><td>在 <span class="math inline">\(\text{Python}\)</span> 中，数组下标从 <span class="math inline">\(0\)</span> 开始，以此为前提。假设下标为 <span class="math inline">\(j\)</span>（第 <span class="math inline">\(j+1\)</span> 位）失配，则匹配长度为 <span class="math inline">\(j\)</span>。又设最大公共长度为 <span class="math inline">\(i\)</span>，则应右移 <span class="math inline">\(j-i\)</span> 位，使失配位为模式串第 <span class="math inline">\(i+1\)</span> 位，即下标为 <span class="math inline">\(i\)</span>。故有 <span class="math inline">\(\text{next}[j]=i\)</span>。</td></tr><tr class="odd"><td>问题变为 <strong>如何快速计算最大公共长度 <span class="math inline">\(i\)</span></strong> ？</td></tr><tr class="even"><td><strong>Next数组</strong>的算法步骤如下图所示，稍后再详细讨论其过程。</td></tr><tr class="odd"><td><img src="/posts/b5ae7cab/next-1.gif" title="Next数组算法步骤示意图"></td></tr></tbody></table><p>假设已知模式串 <span class="math inline">\(\text{P}\)</span> 有 <span class="math inline">\(\text{next}[q]=k\)</span>，说明前 <span class="math inline">\(q\)</span> 位字符串的最大公共长度为 <span class="math inline">\(k\)</span>。即有 <span class="math inline">\(\text{P}[0]=\text{P}[q-k],\cdots, \text{P}[k-1]=\text{P}[q-1]\)</span>。问 <span class="math inline">\(\text{next}[q+1]=?\)</span></p><img src="/posts/b5ae7cab/next-2.png" title="Next数组计算"><p>若 <span class="math inline">\(\text{P}[q]=\text{P}[k]\)</span>，则<span class="math inline">\(\text{next}[q+1]=\text{next}[q]+1=k+1\)</span>。若 <span class="math inline">\(\text{P}[q]\neq \text{P}[k]\)</span>，那么 <span class="math inline">\(\text{next}[q]\)</span> 等于多少？</p><img src="/posts/b5ae7cab/next-3.png" title="Next数组计算"><p>假设 <span class="math inline">\(\text{next}[q+1]=j+1\)</span>，则有 <span class="math display">\[\text{P}[0] = \text{P}[q-j],\cdots,\text{P}[j-1]=\text{P}[q-1],\text{P}[j]=\text{P}[q] \]</span> 又因为 <span class="math inline">\(\text{next}[q]=k\)</span>，所以有 <span class="math display">\[ \text{P}[k-j]=\text{P}[q-j],\cdots,\text{P}[k-1]=\text{P}[q-1] \]</span> 由上面两式可知， <span class="math display">\[ \text{P}[0]=\text{P}[k-j],\cdots,\text{P}[j-1]=\text{P}[k-1] \]</span></p><p>这说明 <span class="math inline">\(j\)</span> 最大可以取到 <span class="math inline">\(\text{next}[k]\)</span>，也就是我们应该比较 <span class="math inline">\(\text{P}[q]\)</span> 和 <span class="math inline">\(\text{P}[\text{next}[\text{next}[q]]]\)</span>。经过一点思考可知，<span class="math inline">\(\text{P}[q]\)</span> 将依次与序列 <span class="math inline">\(\{\text{P}[\text{next}[q]],\text{P}[\text{next}[\text{next}[q]]],\cdots,\text{P}[\text{next}^{(n)}[q]] \}\)</span> 中的元素进行比较，直到<strong>相等</strong>或<span class="math inline">\(\text{next}^{(n)}[q]=0\)</span>。</p><h4 id="python-实现">Python 实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Next</span><span class="params">(p)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    返回模式串的Next（优化）数组</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    ans = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> p]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(p) - <span class="number">1</span>):</span><br><span class="line">        k = ans[i]</span><br><span class="line">        <span class="keyword">while</span> k:</span><br><span class="line">            <span class="keyword">if</span> p[k] == p[i]:</span><br><span class="line">                ans[i+<span class="number">1</span>] = k + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">               k = ans[k]</span><br><span class="line">        <span class="keyword">if</span> ans[i+<span class="number">1</span>] == <span class="number">0</span> <span class="keyword">and</span> p[<span class="number">0</span>] == p[i]:</span><br><span class="line">            ans[i+<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 第二个for循环给出优化KMP算法的Next数组</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(p)):</span><br><span class="line">        <span class="keyword">if</span> ans[i] == i - <span class="number">1</span>:</span><br><span class="line">            ans[i] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">KMP</span><span class="params">(s, p)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    返回模式串 p 在目标串 s 中第一次出现的下标，否则返回 -1</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    _next = Next(p)</span><br><span class="line"></span><br><span class="line">    i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    ns, np = len(s), len(p)</span><br><span class="line">    <span class="keyword">while</span> i &lt; ns <span class="keyword">and</span> j &lt; np:</span><br><span class="line">        <span class="keyword">if</span> s[i] == p[j]:</span><br><span class="line">            i, j = i + <span class="number">1</span>, j + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                i = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 遇到失配时快速移动模式串，优于暴力算法的地方</span></span><br><span class="line">                j = _next[j]</span><br><span class="line">    <span class="keyword">if</span> j == np:</span><br><span class="line">        <span class="keyword">return</span> i - j</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;：给定长度为 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 的&lt;strong&gt;目标&lt;/strong&gt;字
      
    
    </summary>
    
      <category term="算法" scheme="http://spiedeman.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="字符串匹配" scheme="http://spiedeman.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>Python-数值积分初值常微分方程组</title>
    <link href="http://spiedeman.github.io/posts/7f1dadbd/"/>
    <id>http://spiedeman.github.io/posts/7f1dadbd/</id>
    <published>2019-07-09T09:27:35.000Z</published>
    <updated>2021-09-18T02:10:59.622Z</updated>
    
    <content type="html"><![CDATA[<p>通常可以将常微分方程组的求解问题分成两类： - 初值问题 - 边界问题</p><p>这里讨论<strong>初值</strong>常微分方程组的数值求解，用到的工具为<code>scipy.integrate</code>模块中的<code>solve_ivp</code>函数。接收的参数和返回值分别为</p><p><strong>参数</strong>： - <code>fun</code>: <em>函数</em></p><pre><code>一阶常微分方程组的右端，`dy / dt = f(t, y)`。`t`为标量，`y`可以是一维数组，或二维数组（每一列表示一个函数`y`）。若参数`vectorized`为真，则`y`可以是二维数组，这一矢量化的实现是为了在刚性问题中允许通过有限差分更快地估计雅可比矩阵。</code></pre><ul><li><p><code>t_span</code>: <em>长度为2的浮点数元组</em></p>积分区间为<code>[t0, tf]</code>。</li><li><p><code>y0</code>: <em>一维数组</em></p>系统初值。若要在复数域上求解，则使<code>y0</code>的<code>data type</code>为复数。 （以下为常用可选参数）</li><li><p><code>method</code>: <em>方法名</em></p>积分方法有如下几种：<ul><li><code>RK45</code>（默认）：45阶龙格库塔法。</li><li><code>RK23</code>：23阶龙格库塔法。</li><li><code>Radau</code>：5阶隐式龙格库塔法。</li><li><code>RK23</code>：23阶龙格库塔法。</li><li><code>Radau</code>：5阶隐式龙格库塔法。</li><li><code>BDF</code>：基于后向微分公式的隐式多步变阶法。</li><li><code>LSODA</code>：Adams/BDF方法，带有刚性检测和转换功能。</li></ul><p>非刚性问题使用 <code>RK45</code>或<code>RK23</code>，刚性问题使用<code>Radau</code>或<code>BDF</code>。也可以传递任意一个实现求解功能的<code>OdeSolver</code>的子类。</p></li><li><p><code>dense_output</code>: <em>布尔值</em></p><p>是否计算连续解，默认为<code>False</code>。</p></li><li><p><code>t_eval</code>: <em>一维数组或None</em></p><p>对解的值感兴趣的一组时刻。默认由solver决定。</p></li><li><p><code>events</code>: <em>函数或函数列表</em></p><p>追踪的事件。默认为None，表示没有事件需要被追踪。每一个返回值为float的形如<code>event(t, y)</code>的函数都可以作为一个追踪器。solver会使用root-finding算法找到<code>event(t, y) = 0</code>的时刻<code>t</code>。每个<em>事件</em>函数可能拥有下面的两个属性： &gt; terminal: bool, optional &gt; &gt; 是否在事件发生时终止积分。无此属性等价于False。 &gt; direction: float, optional &gt; &gt; 表示穿过零点的方向。direction为正，则事件只会以负到正的方式穿过零点时才会被触发， &gt; 反之则direction为负。若为零，则已任意方式穿过零点都会被触发。无此属性等价于0。</p></li><li><p><code>vectorized</code>: <em>布尔值</em> 函数是否以矢量化方式实现。</p></li></ul><p><strong>返回值</strong> - <code>t</code>: <em>数组</em></p><pre><code>`t_eval`对应的时刻。</code></pre><ul><li><p><code>y</code>: <em>数组</em></p>解在时刻<code>t</code>的值。</li><li><p><code>sol</code>: <em>OdeSolution</em> 或 <em>None</em></p>如果<code>dense_output</code>为False，则为None，否则为找到的解，作为OdeSolution的一个实例。</li><li><p><code>t_events</code>: <em>列表</em> 或 <em>None</em></p><p>包含一组数组，每个数组对应一个事件，包含所有该事件发生时的时刻。</p></li></ul><p>例子可在<a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html#r179348322575-1" target="_blank" rel="noopener">此处</a>找到。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通常可以将常微分方程组的求解问题分成两类： - 初值问题 - 边界问题&lt;/p&gt;&lt;p&gt;这里讨论&lt;strong&gt;初值&lt;/strong&gt;常微分方程组的数值求解，用到的工具为&lt;code&gt;scipy.integrate&lt;/code&gt;模块中的&lt;code&gt;solve_ivp&lt;/code&gt;
      
    
    </summary>
    
      <category term="数值计算" scheme="http://spiedeman.github.io/categories/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="Python" scheme="http://spiedeman.github.io/tags/Python/"/>
    
      <category term="Scipy" scheme="http://spiedeman.github.io/tags/Scipy/"/>
    
      <category term="数值计算" scheme="http://spiedeman.github.io/tags/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>次序统计量</title>
    <link href="http://spiedeman.github.io/posts/8a864e22/"/>
    <id>http://spiedeman.github.io/posts/8a864e22/</id>
    <published>2019-05-28T00:59:11.000Z</published>
    <updated>2021-09-18T02:10:59.612Z</updated>
    
    <content type="html"><![CDATA[<p>设 <span class="math inline">\(X_1,\dots,X_n\)</span> 独立同分布，概率密度函数与累积分布函数分别为 <span class="math inline">\(f(x;\theta)\)</span> 和 <span class="math inline">\(F(x;\theta)\)</span>，<span class="math inline">\(\theta\)</span> 为分布族的参数。为了简化表达式，后文将省略参数 <span class="math inline">\(\theta\)</span>，默认为已知常数。设 <span class="math inline">\(X_{(1)}\le \dots\le X_{(n)}\)</span>，为相应的次序统计量。<span class="math inline">\(X_{(i)}\)</span> 不对应某个确定的 <span class="math inline">\(X_j\)</span>，因为每次试验，<span class="math inline">\(x_1,\dots,x_n\)</span> 的相对大小关系都不同。再加上对 <span class="math inline">\(X\sim f(x)\)</span>绝对连续型分布的假设，即 <span class="math inline">\(P(X_{(i)}=X_{(j)})=0,i\ne j;P(X_{(1)}\lt\dots\lt X_{(n)})=1\)</span>。下文将在前述基础上进行推导。</p><p><strong>积分恒等式</strong> <span class="math display">\[ \sum^n_{l=i}{n\choose l}p^l(1-p)^{n-l}=i{n\choose i}\int^p_0dt\ t^{i-1}(1-t)^{n-i},\quad 0\le t\le p\le 1. \]</span></p><p><strong>概率密度函数 <span class="math inline">\(f_{(i)}(x)\)</span></strong></p><p><span class="math inline">\(f_{(i)}(x)\)</span> 表示 <span class="math inline">\(X_{(i)}\in[x,x+dx]\)</span> 的精确到一阶的概率。这对应这样一种情况：有一个 <span class="math inline">\(X\)</span> 落在区间 <span class="math inline">\([x,x+dx]\)</span>，<span class="math inline">\(i-1\)</span> 个 <span class="math inline">\(X\)</span> 落在区间 <span class="math inline">\([-\infty,x]\)</span>，<span class="math inline">\(n-i\)</span> 个 <span class="math inline">\(X\)</span> 落在区间 <span class="math inline">\([x+dx,\infty]\)</span>。二阶及高阶对应的情形为，有两个及以上的 <span class="math inline">\(X\)</span> 落在区间 <span class="math inline">\([x,x+dx]\)</span>，计算 <span class="math inline">\(f_{(i)}(x)\)</span> 不需要考虑。因此有</p><p><span class="math display">\[ f_{(i)}(x)=n{n-1\choose i-1}[F(x)]^{i-1}f(x)[1-F(x)]^{n-i} \tag{1} \]</span></p><p><strong>累积分布函数<span class="math inline">\(F_{(i)}(x)\)</span></strong></p><p><span class="math display">\[ \begin{aligned} F_{(i)}(x)&amp;=\int^x_{-\infty}dy\ f_{(i)}(y) \\ &amp;=n{n-1\choose i-1}\int^{F(x)}_0dF(y)\ F(y)^{i-1}[1-F(y)]^{n-i} \\ &amp;=n{n-1\choose i-1}\sum^n_{j=i}\frac{(n-i)!}{(n-j)!}\frac{(i-1)!}{j!}F(x)^j[1-F(x)]^{n-j}\\ &amp;=\sum^n_{j=i}{n\choose j}F(x)^j[1-F(x)]^{n-j} \end{aligned} \tag{2} \]</span></p><p>这个结果也很好理解，<span class="math inline">\(F_{(i)}(x)\)</span> 表示概率 <span class="math inline">\(\text{P}_\text{r}(X_{(i)}\le x)\)</span>。<span class="math inline">\(X_{(i)}\le x\)</span> 表示至少有 <span class="math inline">\(j\ge i\)</span> 个 <span class="math inline">\(X\)</span> 落在区间 <span class="math inline">\([-\infty,x]\)</span>，对每个 <span class="math inline">\(j\)</span>，共有 <span class="math inline">\({n\choose j}\)</span> 个选择。</p><p><strong>概率密度函数 <span class="math inline">\(f_{(i,j)}(x)\)</span></strong></p><p>考虑 <span class="math inline">\(X_{(i)},X_{(j)}\)</span> 的联合概率密度函数 <span class="math inline">\(f_{(i,j)}(x,y)\)</span>，不妨设 <span class="math inline">\(i\lt j\)</span>。类似 <span class="math inline">\(f_{(i)}(x)\)</span> 的推导，可以直接写出 <span class="math inline">\(f_{(i,j)}(x,y)\)</span> <span class="math display">\[ f_{(i,j)}(x,y)=2{n\choose i-1}{n-i+1\choose n-j}{j-i+1\choose 2}F(x)^{i-1}[1-F(x)]^{n-j}[F(y)-F(x)]^{j-i-1}f(x)f(y)I\{x\lt y\} \tag{3} \]</span></p><p>此处 <span class="math display">\[ I\{x\le y\}= \begin{cases} 1,&amp; x\le y\\ 0,&amp; x\gt y \end{cases} \tag{4} \]</span></p><p><strong>累积分布函数 <span class="math inline">\(F_{(i,j)}(x,y)\)</span></strong></p><p><span class="math display">\[ \begin{aligned} F_{(i,j)}(x,y)&amp;=\int^x_{-\infty}dx\int^y_{-\infty}dy\ f_{(i,j)}(x,y)\\ &amp;=2{n\choose i-1}{n-i+1\choose j-i+1}{n-j\choose2} \int^x_{-\infty}ds\int^y_{-\infty}dt\ F(s)^{i-1}[F(t)-F(s)]^{j-i-1}[1-F(t)]^{n-i}f(s)f(t) I\{s\lt t\}\\ &amp;=2{n\choose i-1}{n-i+1\choose j-i+1}{n-j\choose2} \int^{F(x)}_0dF(s)\ F(s)^{i-1}\int^{F(y)}_{F(s)}dF(t)[F(t)-F(s)]^{j-i-1}[1-F(t)]^{n-j}I\{s\lt y\}\\ &amp;=2{n\choose i-1}{n-i+1\choose j-i+1}{n-j\choose2} \int^{F(x)}_0dF(s)\ F(s)^{i-1}\sum^{n-j}_{k=0}\frac{(n-j)!}{(n-j-k)!}\frac{(j-i-1)!}{(j-i+k)!}[F(y)-F(s)]^{j-i+k}[1-F(y)]^{n-j-k}I\{s\lt y\}\\ &amp;=i\sum^n_{k=j}{n\choose k}{k\choose i}[1-F(y)]^{n-k} \int^{F(x)}_0dF(s)\ F(s)^{i-1}[F(y)-F(s)]^{k-i}I\{x\lt y\}\\ &amp;=i\sum^n_{k=j}{n\choose k}{k\choose i}[1-F(y)]^{n-k} \sum^{k-i}_{l=0}\frac{(k-i)!}{(k-i-l)!}\frac{(i-1)!}{(i+l)!}F(x)^{i+l}[F(y)-F(x)]^{k-i-l}I\{x\lt y\}\\ &amp;=\sum^n_{k=j}\sum^k_{l=i}\frac{n!}{(n-k)!(k-l)!l!}F(x)^l[F(y)-F(x)]^{k-l}[1-F(y)]^{n-k} I\{x\lt y\}\\ &amp;=\sum^n_{k=j}{n\choose k}[1-F(y)]^{n-k}\sum^k_{l=i}{k\choose l}F(x)^l[F(y)-F(x)]^{k-l}I\{x\lt y\} \end{aligned} \tag{5} \]</span></p><p>同样，这个结果也很好理解，<span class="math inline">\(F_{(i,j)}(x,y)=\text{P}_\text{r}(X_{(i)}\le x,X_{(j)}\le y)\)</span>。<span class="math inline">\(X_{(j)}\le y\)</span> 表示至少有 <span class="math inline">\(k\ge j\)</span> 个 <span class="math inline">\(X\)</span> 落在区间 <span class="math inline">\([-\infty,y]\)</span>，对每个 <span class="math inline">\(k\)</span>，共有 <span class="math inline">\({n\choose k}\)</span> 个选择。然后，<span class="math inline">\(X_{(i)}\le x\)</span> 表示至少有 <span class="math inline">\(i\le l\le k\)</span> 个 <span class="math inline">\(X\)</span> 落在区间 <span class="math inline">\([-\infty, x]\)</span>，对每个 <span class="math inline">\(l\)</span>，共有 <span class="math inline">\({k\choose l}\)</span> 个选择。再考虑到需要满足 <span class="math inline">\(x\lt y\)</span>，即得 <span class="math inline">\((5)\)</span> 中最后一个等式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;设 &lt;span class=&quot;math inline&quot;&gt;\(X_1,\dots,X_n\)&lt;/span&gt; 独立同分布，概率密度函数与累积分布函数分别为 &lt;span class=&quot;math inline&quot;&gt;\(f(x;\theta)\)&lt;/span&gt; 和 &lt;span clas
      
    
    </summary>
    
      <category term="算法" scheme="http://spiedeman.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数学" scheme="http://spiedeman.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="统计" scheme="http://spiedeman.github.io/tags/%E7%BB%9F%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>在多台电脑上同步更新Hexo博客</title>
    <link href="http://spiedeman.github.io/posts/77781092/"/>
    <id>http://spiedeman.github.io/posts/77781092/</id>
    <published>2019-04-20T08:04:50.000Z</published>
    <updated>2021-09-18T02:10:59.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景">背景</h1><p>目前更新博客文章，只在自己的笔记本操作。一旦想要在办公室的台式机上写文章并发布到 Github Pages 上就变得很麻烦，一时不知从何下手。</p><h1 id="需求">需求</h1><p>博客的源文件能在多个设备上同步更新，并且在任意设备上都能自如写文章并发布。</p><h1 id="方案">方案</h1><p>利用 <code>GitHub</code> 的分支功能，将 <code>Hexo</code>建站的必备源文件以及博客文章的源文件备份到 <code>source</code> 分支上。而 <code>hexo</code>生成的静态博客文件仍然放在默认的 <code>master</code> 分支上。这样在任何设备上只需将<code>source</code> 分支克隆到本地，即可开始写新博客。之后通过 <code>hexo</code>命令即可将新生成的网站内容推送到 <code>master</code> 分支上。两个分支上的内容互不干扰，都能维持最新状态。</p><h2 id="操作">操作</h2><h3 id="创建新的分支">创建新的分支</h3><p>新分支的命名没有要求，本文采用<code>source</code>。</p><p>创建分支的方法有两种， - 在浏览器中登陆<a href="https://github.com" target="_blank" rel="noopener">GitHub</a>进行操作。 - 在本地通过命令行操作。</p><p>由于浏览器操作比较简单，就不详细讨论了。重点记录一下终端操作过程。</p><p>1、克隆仓库 <code>username.github.io</code> 到本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/username/username.github.io Hexo</span><br></pre></td></tr></table></figure><p></p><p>2、进入该文件夹并创建新的分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> username.github.io</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新的分支 source</span></span><br><span class="line">git checkout -b <span class="built_in">source</span></span><br></pre></td></tr></table></figure><p></p><p>3、在 <code>source</code> 分支内删除原有的所有文件，然后将 <code>Hexo</code> 建站所需的必备文件以及所有的博客文章拷贝进来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除所有的原有内容，.git 文件夹保留</span></span><br><span class="line">rm -rf *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝必要的文件到当前目录</span></span><br><span class="line">cp -r /path/to/hexo/<span class="built_in">source</span> .</span><br><span class="line">cp -r /path/to/hexo/scaffolds .</span><br><span class="line">cp -r /path/to/hexo/themes .</span><br><span class="line">cp /path/to/hexo/_config.yml .</span><br><span class="line">cp /path/to/hexo/package.json .</span><br></pre></td></tr></table></figure><p>需要注意的是 <code>themes</code> 中可能存在 <code>.git</code> 文件夹，需要把它们全部删除。</p><p>4、提交 source 分支 由于 <code>Hexo</code> 命令生成网站内容时会新建两个文件夹 <code>public</code> 和<code>.deploy_git</code>。<code>public</code>中包含的正是所有网站的源文件，这些内容并不需要保存在 <code>source</code>分支，因此提交时要忽略。<code>.deploy_git</code> 是 <code>Hexo</code>帮我们把网站内容推送到 <code>master</code>分支上所建的文件夹，故也可以忽略。另外不需要推送的一个文件夹，便是<code>node_modules</code>。这个文件夹里是 <code>Hexo</code>用到的所有插件，在本地安装一下就有了，不需要保存在 <code>GitHub</code> 上。</p><p>因此，提交 <code>source</code> 分支前需要</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'node_modules'</span> &gt;&gt; .gitignore</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'public'</span> &gt;&gt; .gitignore</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'.deploy_git'</span> &gt;&gt; .gitignore</span><br></pre></td></tr></table></figure><p>现在可以提交了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"update blog files"</span></span><br><span class="line">git push origin <span class="built_in">source</span></span><br></pre></td></tr></table></figure><h3 id="在新设备上的准备工作">在新设备上的准备工作</h3><p>要在新设备上愉快地用 <code>Hexo</code> 写博客之前，需要做一些准备工作。</p><p>1、安装 git，并将新设备上的 ssh key 添加到 GitHub 账户上。</p><p>2、安装 Hexo</p><p>3、把 souce 分支克隆到本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b <span class="built_in">source</span> git@github.com:username/username.github.io.git Hexo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若已将 source 分支设为默认分支，则可以简化命令</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/username/username.github.io Hexo</span><br></pre></td></tr></table></figure><p>4、安装所有依赖，生成 <code>node_modules</code> 目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p></p><p>5、创建新文章，生成博客的静态文件（即 <code>public</code> 目录）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">"title"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文章写完之后</span></span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure><p></p><p>6、将博客内容推送到 GitHub 上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 博客的静态文件在 master 分支，其他的源文件在 source 分支</span></span><br><span class="line"><span class="comment"># _config.yml 中 deploy 的 branch 值必须为 master</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p></p><p>7、最后把修改推送到 source 分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"commit message"</span></span><br><span class="line">git push origin <span class="built_in">source</span></span><br></pre></td></tr></table></figure><p></p><p><strong>注意</strong>：在新设备上的所有操作都在 <code>source</code> 分支下完成。</p><h3 id="日常操作">日常操作</h3><p>由于上一次更新博客有可能不是在手头的电脑上操作的。因此 <code>GitHub</code> 上的 <code>source</code> 分支可能比本地的更新，因此首先要更新本地的 <code>source</code> 分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin <span class="built_in">source</span></span><br></pre></td></tr></table></figure><p>接下来，按照正常流程写文章并用<code>hexo</code>部署到<code>GitHub</code>上。</p><p>最后，把对源文件的修改推送到 <code>source</code> 分支上。</p><p>参考资料： <a href="https://theqwang.github.io/2017/03/17/在多台电脑间使用hexo/#more" target="_blank" rel="noopener">theqwang's blog</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;背景&lt;/h1&gt;&lt;p&gt;目前更新博客文章，只在自己的笔记本操作。一旦想要在办公室的台式机上写文章并发布到 Github Pages 上就变得很麻烦，一时不知从何下手。&lt;/p&gt;&lt;h1 id=&quot;需求&quot;&gt;需求&lt;/h1&gt;&lt;p&gt;博客的源文件能在多个设备上同步更新，并且在
      
    
    </summary>
    
      <category term="Hexo" scheme="http://spiedeman.github.io/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://spiedeman.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>GitBook 安装配置 &amp; 导出 PDF</title>
    <link href="http://spiedeman.github.io/posts/3741144490/"/>
    <id>http://spiedeman.github.io/posts/3741144490/</id>
    <published>2019-04-18T11:46:20.000Z</published>
    <updated>2021-09-18T02:10:59.602Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装-gitbook">安装 GitBook</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g gitbook-cli</span><br><span class="line">gitbook -V <span class="comment"># 查看版本</span></span><br></pre></td></tr></table></figure><h2 id="使用-calibre-插件生成pdf">使用 calibre 插件生成PDF</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">brew cask install calibre</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> path/to/book</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 pdf</span></span><br><span class="line">gitbook pdf . mypdf.pdf</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装-gitbook&quot;&gt;安装 GitBook&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span cl
      
    
    </summary>
    
      <category term="电子书" scheme="http://spiedeman.github.io/categories/%E7%94%B5%E5%AD%90%E4%B9%A6/"/>
    
    
      <category term="GitBook" scheme="http://spiedeman.github.io/tags/GitBook/"/>
    
  </entry>
  
  <entry>
    <title>Vim 技巧</title>
    <link href="http://spiedeman.github.io/posts/4131642440/"/>
    <id>http://spiedeman.github.io/posts/4131642440/</id>
    <published>2019-02-18T02:11:19.000Z</published>
    <updated>2021-09-18T02:10:59.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="用法">用法</h2><h3 id="自定义映射">自定义映射</h3><h4 id="正确使用optionalt键">正确使用option/Alt键</h4><p><code>option</code>键在<code>macOS</code>下作为组合按键之一，对应于PC、Linux上的<code>Alt</code>键，但是功能不太一样。<code>Mac</code>上字母及一些标点符号与<code>option</code>组合会输出<code>unicode</code>字符。 原因在于按下按下<code>option</code>键发送的不是<code>Escape Sequence</code>。因此在<code>vim,emacs</code>等终端软件中，没法直接使用<code>Alt</code>键定义映射。</p><p>找到原因就好办，解决方法分为两步： 1. 在终端中修改<code>option/Alt</code>键的行为 2. 在<code>vim,emacs</code>等运行于终端下的软件中进行可能必要的设置</p><p>以终端程序<code>kitty</code>和<code>alacritty</code>为例，具体讨论解决方法中的第一步如何操作。 - kitty - 打开配置文件<code>kitty.conf</code> - 找到选项<code>macos_option_as_alt no</code>，将<code>no</code>改为<code>yes</code> - alacrity - 打开配置文件<code>alacrity.yml</code> - 定位到<code>key_bindings</code> - 添加需要的键位设置，例如 <code>- { key: x, mods: Alt, chars: &quot;\x1bx&quot; }</code></p><p>以运行在终端下的<code>vim</code>为例，给出第二步中需要的具体操作。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">Terminal_MetaMode</span><span class="params">(mode)</span></span></span><br><span class="line">    <span class="keyword">set</span> ttimeout</span><br><span class="line">    <span class="keyword">if</span> $TMUX != <span class="string">''</span></span><br><span class="line">        <span class="keyword">set</span> ttimeoutlen=<span class="number">30</span></span><br><span class="line">    <span class="keyword">elseif</span> &amp;ttimeoutlen &gt; <span class="number">80</span> || &amp;ttimeoutlen &lt;= <span class="number">0</span></span><br><span class="line">        <span class="keyword">set</span> ttimeoutlen=<span class="number">80</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">has</span>(<span class="string">'nvim'</span>) || <span class="built_in">has</span>(<span class="string">'gui_running'</span>) || $TERM_PROGRAM =~? <span class="string">'iTerm2'</span></span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    <span class="comment">" 👆表示只有某些终端下的vim需要👇的设置</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span>! <span class="title">s</span>:<span class="title">metacode</span><span class="params">(mode, key)</span></span></span><br><span class="line">        <span class="comment">" 这个函数的作用是告诉vim，&lt;M-x&gt;的键盘序列码是多少</span></span><br><span class="line">        <span class="comment">" 这样vim将按照ttimeoutlen的设置来检查是否超时</span></span><br><span class="line">        <span class="comment">" 如果用 `noremap &lt;ESC&gt;x &lt;M-x&gt;` 然后 `noremap &lt;M-x&gt; ...`的方式，</span></span><br><span class="line">        <span class="comment">" 则会使用timeoutlen来检查是否超时</span></span><br><span class="line">        <span class="comment">" 一般timeoutlen设置的相对更大，如果用它更容易误操作，降低使用体验</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable">a:mode</span> == <span class="number">0</span></span><br><span class="line">            exec <span class="string">"set &lt;M-"</span>.<span class="variable">a:key</span>.<span class="string">"&gt;=\e"</span>.<span class="variable">a:key</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">"👇这条需要对终端进行更针对性的设置，写本节时只想到在alacrity中设置会容易些</span></span><br><span class="line">            exec <span class="string">"set &lt;M-"</span>.<span class="variable">a:key</span>.<span class="string">"&gt;=\e]&#123;0&#125;"</span>.<span class="variable">a:key</span>.<span class="string">"~"</span></span><br><span class="line">        <span class="keyword">endif</span></span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line">    <span class="comment">" 针对alacrity，还需设置几个功能键</span></span><br><span class="line">    <span class="keyword">if</span> $TERM_PROGRAM =~? <span class="string">'alacritty'</span></span><br><span class="line">        exec <span class="string">"set &lt;F1&gt;=\eOP"</span></span><br><span class="line">        exec <span class="string">"set &lt;F2&gt;=\eOQ"</span></span><br><span class="line">        exec <span class="string">"set &lt;F3&gt;=\eOR"</span></span><br><span class="line">        exec <span class="string">"set &lt;F4&gt;=\eOS"</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">call</span> <span class="variable">s:metacode</span>(<span class="variable">a:mode</span>, <span class="built_in">nr2char</span>(<span class="built_in">char2nr</span>(<span class="string">'0'</span>) + i))</span><br><span class="line">    <span class="keyword">endfor</span></span><br><span class="line">    <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">26</span>)</span><br><span class="line">        <span class="keyword">call</span> <span class="variable">s:metacode</span>(<span class="variable">a:mode</span>, <span class="built_in">nr2char</span>(<span class="built_in">char2nr</span>(<span class="string">'a'</span>) + i))</span><br><span class="line">        <span class="keyword">call</span> <span class="variable">s:metacode</span>(<span class="variable">a:mode</span>, <span class="built_in">nr2char</span>(<span class="built_in">char2nr</span>(<span class="string">'A'</span>) + i))</span><br><span class="line">    <span class="keyword">endfor</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable">a:mode</span> != <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">c</span> in [<span class="string">','</span>, <span class="string">'.'</span>, <span class="string">'/'</span>. <span class="string">';'</span>, <span class="string">'['</span>, <span class="string">']'</span>, <span class="string">'&#123;'</span>, <span class="string">'&#125;'</span>]</span><br><span class="line">            <span class="keyword">call</span> <span class="variable">s:metacode</span>(<span class="variable">a:mode</span>, <span class="keyword">c</span>)</span><br><span class="line">        <span class="keyword">endfor</span></span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">c</span> in [<span class="string">'?'</span>, <span class="string">':'</span>, <span class="string">'-'</span>, <span class="string">'_'</span>]</span><br><span class="line">            <span class="keyword">call</span> <span class="variable">s:metacode</span>(<span class="variable">a:mode</span>, <span class="keyword">c</span>)</span><br><span class="line">        <span class="keyword">endfor</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">c</span> in [<span class="string">','</span>, <span class="string">'.'</span>, <span class="string">'/'</span>, <span class="string">';'</span>, <span class="string">'&#123;'</span>, <span class="string">'&#125;'</span>]</span><br><span class="line">            <span class="keyword">call</span> <span class="variable">s:metacode</span>(<span class="variable">a:mode</span>, <span class="keyword">c</span>)</span><br><span class="line">        <span class="keyword">endfor</span></span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">c</span> in [<span class="string">'?'</span>, <span class="string">':'</span>, <span class="string">'-'</span>, <span class="string">'_'</span>]</span><br><span class="line">            <span class="keyword">call</span> <span class="variable">s:metacode</span>(<span class="variable">a:mode</span>, <span class="keyword">c</span>)</span><br><span class="line">        <span class="keyword">endfor</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" 设置用户自定义命令</span></span><br><span class="line">command! -nargs=<span class="number">0</span> -bang VimMetaInit <span class="keyword">call</span> Terminal_MetaMode(<span class="symbol">&lt;bang&gt;</span><span class="number">0</span>)</span><br><span class="line"><span class="comment">" buffer 读入后自动进行设置</span></span><br><span class="line"><span class="keyword">augroup</span> alt_key</span><br><span class="line">    autocmd!</span><br><span class="line">    <span class="keyword">autocmd</span> BufReadPost * :VimMetaInit</span><br><span class="line"><span class="keyword">augroup</span> END</span><br></pre></td></tr></table></figure><p></p><h3 id="用户自定义事件">用户自定义事件</h3><p>自定义了切换透明和背景的函数，并绑定了快捷键。同时主题栏使用的是<a href="https://github.com/itchyny/lightline.vim" target="_blank" rel="noopener">lightline</a>。 我为<code>dark</code>和<code>light</code>两种背景选取不同的<code>lightline</code>主题，为了使背景切换之后，主题栏的切换也生效，这里使用用户自定义事件来解决问题。 当然这不是唯一的方法。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">ToggleBackground</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">" A lot of stuff is happening here.</span></span><br><span class="line">    <span class="comment">" 定义一个自定义事件</span></span><br><span class="line">    <span class="keyword">doautocmd</span> User ToggleBackgroundExit</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">ToggleTransparent</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">" A lot of stuff is happening here.</span></span><br><span class="line">    <span class="comment">" 定义一个自定义事件</span></span><br><span class="line">    <span class="keyword">doautocmd</span> User ToggleTransparentExit</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure><p></p><p>现在可以在切换背景和透明度执行完成后做任何想做的事：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">autocmd</span> User ToggleBackgroundExit <span class="keyword">call</span> lightline#enable()</span><br></pre></td></tr></table></figure><p></p><h3 id="插件">插件</h3><h4 id="插件管理器vim-plug">插件管理器（vim-plug）</h4><p><a href="https://github.com/junegunn/vim-plug" target="_blank" rel="noopener">vim-plug</a>是一款异步插件管理器。具有安装速度快，延迟加载等特性。 这里要讨论的是刚发现的一个特性，可以让插件按照依赖关系进行加载。</p><p>栗子🌰，我有三款用于<code>markdown</code>的插件，分别是</p><ul><li><a href="https://github.com/plasticboy/vim-markdown" target="_blank" rel="noopener"><code>plasticboy/vim-markdown</code></a></li><li><a href="https://github.com/jszakmeister/markdown2ctags" target="_blank" rel="noopener"><code>jszakmeister/markdown2ctags</code></a></li><li><a href="https://github.com/iamcco/markdown-preview.nvim" target="_blank" rel="noopener"><code>iamcco/markdown-preview.nvim</code></a></li></ul><p>原本可以在每个插件后面，用<code>{'for':'markdown'}</code>使其仅在编辑<code>.md</code>文件时才加载。但我发现 这种方法对第二款插件无效。因此想到这里的办法。</p><p><code>vim-plug</code>在调用函数<code>plug#load()</code>加载插件之后会以插件名定义一个用户自定义事件。可以利用这一事件触发对其有依赖的插件的调用。如下为具体的使用案例：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">" 以文件类型作为加载的依据</span></span><br><span class="line">Plug <span class="string">'iamcco/markdown-preview.nvim'</span>, &#123;<span class="string">'for'</span>: <span class="string">'markdown'</span>, <span class="string">'do'</span>: <span class="string">'cd app &amp; yarn install'</span>&#125;</span><br><span class="line">  <span class="comment">" 下面的插件无法按照文件类型进行加载</span></span><br><span class="line">  <span class="comment">" 故通过vim-plug 定义的用户自定义事件进行触发</span></span><br><span class="line">  Plug <span class="string">'plasticboy/vim-markdown'</span>, &#123;<span class="string">'on'</span> : []&#125;</span><br><span class="line">  Plug <span class="string">'jszakmeister/markdown2ctags'</span>, &#123;<span class="string">'on'</span>: []&#125;</span><br><span class="line">  <span class="keyword">augroup</span> vimplug_load_for_markdown</span><br><span class="line">    autocmd!</span><br><span class="line">    <span class="keyword">autocmd</span> User markdown-preview.nvim plug#load(</span><br><span class="line">                \ <span class="string">'vim-markdown'</span>,</span><br><span class="line">                \ <span class="string">'markdown2ctags'</span>,</span><br><span class="line">                \ )</span><br><span class="line">                \ | autocmd! vimplug_load_for_markdown</span><br><span class="line">  <span class="keyword">augroup</span> END</span><br></pre></td></tr></table></figure><p>进一步，针对一个插件的所有配置可以做到这样：在插件被</p><ul><li>加载前，不载入</li><li>加载后，自动载入</li></ul><p>可以这样实现</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">" 仍然以上面的插件为例</span></span><br><span class="line"><span class="comment">" 在载入 vim-markdown之后自动加载相关配置。所有配置在函数SetVimmarkdown()之中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">SetVimmarkdown</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">" all configurations for vim-markdown are at here</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">augroup</span> load_for_vimmarkdown</span><br><span class="line">    autocmd!</span><br><span class="line">    <span class="keyword">autocmd</span> User <span class="keyword">vim</span>-markdown <span class="keyword">call</span> SetVimmarkdown() | autocmd!  load_for_vimmarkdown</span><br><span class="line"><span class="keyword">augroup</span> END</span><br></pre></td></tr></table></figure><h4 id="中文输入法">中文输入法</h4><p><code>vim</code> 的模式切换与中文输入法并不总能够和谐共处。 | | 英文 | 中文 | |--------|------|------| | normal | :) | :( | | insert | :) | :) |</p><p>解决这个问题的方式大体上有两种，1、<code>vim</code> 提供中文输入法，那么这个问题就留给<code>vim</code>及其插件的开发者们去解决了；2、仍然使用外部中文输入法，如搜狗等， 那么关键在于以哪种方式自动切换输入法！</p><p>这里沿用第二种思路。尝试过如下几种方式：</p><ol type="1"><li>通过 vim 内置函数模拟按键操作来切换输入法。没有成功，但不排除可行性。</li><li>调用外部程序进行输入法切换。成功，但是并不完美。</li></ol><p>所以最终采取的方案是通过调用外部程序在进入和离开<code>insert</code>模式时只能切换输入法。实现方式具体看下面的<code>vim</code>配置。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">" 定义缓冲区变量，使得可以对每个缓冲区单独监控输入法状态</span></span><br><span class="line"><span class="keyword">au</span> BufEnter * <span class="keyword">let</span> <span class="variable">b:im</span>=<span class="number">0</span></span><br><span class="line"><span class="comment">" 为了尽量不影响体验，通过异步机制来进行处理</span></span><br><span class="line"><span class="comment">" 下面的函数用于在 job 进行过程中处理返回信息</span></span><br><span class="line">fun! IMHandler(channel, msg)</span><br><span class="line">    <span class="keyword">if</span> <span class="variable">a:msg</span> !=? <span class="string">'com.apple.keylayout.ABC'</span></span><br><span class="line">        <span class="comment">" 切换到英文输入法之前保存当前状态</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">b:im</span> = <span class="number">1</span></span><br><span class="line">        <span class="keyword">call</span> job_start([<span class="string">'issw'</span>, <span class="string">'com.apple.keylayout.ABC'</span>])</span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">endfun</span><br><span class="line">fun! Lang2en()</span><br><span class="line">    <span class="keyword">let</span> job = job_start([<span class="string">'issw'</span>], &#123;<span class="string">"out_cb"</span>: <span class="string">"IMHandler"</span>&#125;)</span><br><span class="line">endfun</span><br><span class="line"><span class="comment">" 这里中文输入法的切换用了自己写的脚本，虽然也可以用上面的 issw 命令。</span></span><br><span class="line">fun! Lang2zh()</span><br><span class="line">    <span class="keyword">if</span> <span class="variable">b:im</span> == <span class="number">1</span></span><br><span class="line">        <span class="keyword">call</span> job_start([<span class="string">'switchim'</span>])</span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">endfun</span><br><span class="line"><span class="keyword">autocmd</span> InsertEnter * <span class="keyword">call</span> Lang2zh()</span><br><span class="line"><span class="keyword">autocmd</span> BufEnter,InsertLeave * <span class="keyword">call</span> Lang2en()</span><br></pre></td></tr></table></figure><p>因为不想用破解软件来修改按键映射及快捷键，导致仍有不足之处：</p><ul><li>调用的外部程序切换输入法不够快，仍然有一定几率产生困扰。</li><li>insert 模式下，如果要用搜狗输入法，从英文切换回中文比较麻烦。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;用法&quot;&gt;用法&lt;/h2&gt;&lt;h3 id=&quot;自定义映射&quot;&gt;自定义映射&lt;/h3&gt;&lt;h4 id=&quot;正确使用optionalt键&quot;&gt;正确使用option/Alt键&lt;/h4&gt;&lt;p&gt;&lt;code&gt;option&lt;/code&gt;键在&lt;code&gt;macOS&lt;/code&gt;下作为组合按键之一，
      
    
    </summary>
    
      <category term="Vim" scheme="http://spiedeman.github.io/categories/Vim/"/>
    
    
      <category term="Vim" scheme="http://spiedeman.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>Graphviz 介绍</title>
    <link href="http://spiedeman.github.io/posts/1414645917/"/>
    <id>http://spiedeman.github.io/posts/1414645917/</id>
    <published>2019-02-16T08:46:44.000Z</published>
    <updated>2021-09-18T02:10:59.602Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章参考自<a href="http://www.graphviz.org/pdf/dotguide.pdf" target="_blank" rel="noopener">Drawing graphs with <em>dot</em></a></p><p><span class="math inline">\(dot\)</span> 通过<span class="math inline">\(DOT\)</span>语言来作图。该语言描述了三大对象：图(graphs)，节点(nodes)，边(edges)。同时支持有向图和无向图，并支持图的嵌套(<span class="math inline">\(subgraph\)</span>)。 默认采用有向图的布局方式，有另一个独立的布局工具，<em>neato</em>，用于无向图。</p><p><span class="math inline">\(dot\)</span> 编译的方式是按顺序一行一行地处理 *.dot 文件中内容。所以各种对象的属性的有效性从从属性设置语句所在行开始直到下一次属性设置语句所在行之前。</p><p>完整的属性描述可以参考<span class="math inline">\(Graphviz\)</span>官网的<a href="http://www.graphviz.org/doc/info/attrs.html" target="_blank" rel="noopener">该页面</a>。</p><h2 id="要素">要素</h2><p>一幅图可以包含如下要素：</p><ol type="1"><li>注释</li></ol><ul><li>双斜杠</li></ul><ol start="2" type="1"><li>有向图 or 无向图</li><li>节点之间的关系</li></ol><ul><li>有向图：<code>a-&gt;b</code>，节点 a 指向节点 b</li><li>无向图：<code>a--b</code>，节点 a 和节点 b连通</li></ul><ol start="4" type="1"><li>定义节点属性</li></ol><ul><li>形状，多边形<code>polygon</code>和<code>record</code>（不知道怎么翻译）</li><li>颜色</li><li>标签</li><li>等等</li></ul><ol start="5" type="1"><li>定义边的属性</li></ol><ul><li>形状</li><li>颜色</li><li>文本</li><li>等等</li></ul><ol start="6" type="1"><li>定义结构(<code>record</code>)</li></ol><ul><li>内部结构</li><li>方向，水平或竖直排列</li><li>标签</li></ul><h2 id="样例">样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">digraph G&#123;</span><br><span class="line">    a -&gt; b -&gt; c;</span><br><span class="line">    b -&gt; d;</span><br><span class="line">    a [shape=polygon,sides=5,peripheries=3,color=lightblue,style=filled];</span><br><span class="line">    c [shape=polygon,sides=4,skew=.4,label=&quot;hello world&quot;]</span><br><span class="line">    d [shape=invtriangle];</span><br><span class="line">    e [shape=polygon,sides=4,distortion=.7];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/posts/1414645917/graph-with-polygonal-shapes.svg"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">digraph structs&#123;</span><br><span class="line">node [shape=record];</span><br><span class="line">    struct1 [shape=record,label=&quot;&lt;f0&gt; left|&lt;f1&gt; mid\ dle|&lt;f2&gt; right&quot;];</span><br><span class="line">    struct2 [shape=record,label=&quot;&lt;f0&gt; one|&lt;f1&gt; two&quot;];</span><br><span class="line">    struct3 [shape=record,label=&quot;hello\nworld | &#123; b |&#123;c|&lt;here&gt; d|e&#125;| f&#125;|g|h &quot;];</span><br><span class="line">    struct1 -&gt; struct2;</span><br><span class="line">    struct1 -&gt; struct3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/posts/1414645917/records-with-nested-fields.svg"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">digraph G &#123;</span><br><span class="line">    node[shape=record,height=.1];   //定义node样式</span><br><span class="line"></span><br><span class="line">    node0[label=&quot;&lt;f0&gt; |&lt;f1&gt; A|&lt;f2&gt; &quot;]; //具体的一个node，含三个属性，第二个属性有名字</span><br><span class="line">    node0[label=&quot;&lt;f0&gt; |&lt;f1&gt; B|&lt;f2&gt; &quot;];</span><br><span class="line">    node0[label=&quot;&lt;f0&gt; |&lt;f1&gt; C|&lt;f2&gt; &quot;];</span><br><span class="line">    node0[label=&quot;&lt;f0&gt; |&lt;f1&gt; D|&lt;f2&gt; &quot;];</span><br><span class="line">    node0[label=&quot;&lt;f0&gt; |&lt;f1&gt; E|&lt;f2&gt; &quot;];</span><br><span class="line">    node0[label=&quot;&lt;f0&gt; |&lt;f1&gt; F|&lt;f2&gt; &quot;];</span><br><span class="line">    node0[label=&quot;&lt;f0&gt; |&lt;f1&gt; H|&lt;f2&gt; &quot;];</span><br><span class="line">    node0[label=&quot;&lt;f0&gt; |&lt;f1&gt; I|&lt;f2&gt; &quot;];</span><br><span class="line">    node0[label=&quot;&lt;f0&gt; |&lt;f1&gt; J|&lt;f2&gt; &quot;];</span><br><span class="line">    node0[label=&quot;&lt;f0&gt; |&lt;f1&gt; K|&lt;f2&gt; &quot;];</span><br><span class="line"></span><br><span class="line">    &quot;node0&quot;:f2 -&gt; &quot;node1&quot;: f1;  //node0的第三个属性指向node1的第二个属性</span><br><span class="line">    &quot;node1&quot;:f0 -&gt; &quot;node2&quot;: f1;</span><br><span class="line">    &quot;node1&quot;:f1 -&gt; &quot;node3&quot;: f2;</span><br><span class="line">    &quot;node3&quot;:f0 -&gt; &quot;node4&quot;: f0;</span><br><span class="line">    &quot;node3&quot;:f1 -&gt; &quot;node5&quot;: f1;</span><br><span class="line">    &quot;node3&quot;:f2 -&gt; &quot;node6&quot;: f2;</span><br><span class="line">    &quot;node6&quot;:f1 -&gt; &quot;node7&quot;: f1;</span><br><span class="line">    &quot;node7&quot;:f1 -&gt; &quot;node8&quot;: f0;</span><br><span class="line">    &quot;node2&quot;:f2 -&gt; &quot;node9&quot;: f1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/posts/1414645917/record-structure.svg">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇文章参考自&lt;a href=&quot;http://www.graphviz.org/pdf/dotguide.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Drawing graphs with &lt;em&gt;dot&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span
      
    
    </summary>
    
      <category term="Graphviz" scheme="http://spiedeman.github.io/categories/Graphviz/"/>
    
    
      <category term="Graphviz" scheme="http://spiedeman.github.io/tags/Graphviz/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 16.04 LTS 开启BBR</title>
    <link href="http://spiedeman.github.io/posts/3381164653/"/>
    <id>http://spiedeman.github.io/posts/3381164653/</id>
    <published>2019-01-05T16:56:29.000Z</published>
    <updated>2021-09-18T02:10:59.622Z</updated>
    
    <content type="html"><![CDATA[<p>Vultr 上安装 ubuntu 16.04 并开启BBR。</p><h1 id="更新内核">更新内核</h1><p><code>BBR</code>只支持4.9+的Linux内核版本，因此首先检查并更新内核。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前内核版本</span></span><br><span class="line">uname -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装最新版内核</span></span><br><span class="line">sudo apt install linux-image-generic-hwe-16.04</span><br></pre></td></tr></table></figure><p></p><h1 id="重启">重启</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><h1 id="开启bbr">开启BBR</h1><p>添加如下两行至文件<code>/etc/sysctl.conf</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.default_qdisc=fq</span><br><span class="line">net.ipv4.tcp_congestion_control=bbr</span><br></pre></td></tr></table></figure><p></p><p>启动bbr</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><p></p><p>验证是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep bbr</span><br><span class="line"></span><br><span class="line">tcp_bbr         20480 1</span><br></pre></td></tr></table></figure><p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Vultr 上安装 ubuntu 16.04 并开启BBR。&lt;/p&gt;&lt;h1 id=&quot;更新内核&quot;&gt;更新内核&lt;/h1&gt;&lt;p&gt;&lt;code&gt;BBR&lt;/code&gt;只支持4.9+的Linux内核版本，因此首先检查并更新内核。&lt;/p&gt;&lt;figure class=&quot;highlight ba
      
    
    </summary>
    
      <category term="科学上网" scheme="http://spiedeman.github.io/categories/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
    
      <category term="BBR" scheme="http://spiedeman.github.io/tags/BBR/"/>
    
  </entry>
  
  <entry>
    <title>Python万物皆对象</title>
    <link href="http://spiedeman.github.io/posts/1949292692/"/>
    <id>http://spiedeman.github.io/posts/1949292692/</id>
    <published>2018-12-14T11:33:45.000Z</published>
    <updated>2021-09-18T02:10:59.622Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类与对象">类与对象</h1><p><code>Python</code>中有两种关系： - 类与对象，顶点为<code>Type</code>。 - 继承，顶点为<code>Object</code>。</p><h2 id="类与对象type">类与对象（Type）</h2><p><code>__class__</code>方法查看当前对象所属的类，亦即由哪个类实例化得到。</p><blockquote><p>Python 中的对象可以分成两种 - 不是类的对象，例如手里的一个🍎。 - 亦是类的对象，例如🍎，作为水果这个类的一个实例（对象）。</p></blockquote><p>类比如下关系： &gt; 手里的🍎（创建自）🍎（创建自）水果（创建自）食物（创建自）... 顶点</p><p>Python 版本 &gt; 不是类的对象（创建自）亦是类的对象（创建自）类的类（创建自）Type（顶点）</p><h2 id="继承object">继承（Object）</h2><p><code>__base__</code>方法查看当前类的父类，亦即继承自哪个类。</p><blockquote><p>Python 中的类也可以分成两种 - 普通类，类继承链条的末端，其实例不是类。 - 元类，类继承链条的非末端，其实例依然是类。</p></blockquote><p>类比如下关系： &gt; 🍎（继承自）水果（继承自）食物（继承自）... 顶点</p><p>Python 版本 &gt; 普通类（继承自）元类（继承自）...（继承自）Object（顶点）</p><h2 id="typeobject">Type/Object</h2><p>Type 作为 - 类，继承自 Object - 对象，创建自 Type（自身）</p><p>Object 作为 - 类，继承自 Object（自身） - 对象，创建自 Type</p><img src="/posts/1949292692/type-and-object.png" title="类与对象关系"><hr><blockquote><p>道生一，一生二，二生三，三生万物</p></blockquote><p>网上有人用它来理解 <strong>类对象</strong> 关系，觉得生动形象，故记录于此。 1、道 即 Type 2、一 即 元类 3、二 即 普通类 4、三 即 实例 5、<strong>万物</strong> 即 各种实例属性，方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;类与对象&quot;&gt;类与对象&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Python&lt;/code&gt;中有两种关系： - 类与对象，顶点为&lt;code&gt;Type&lt;/code&gt;。 - 继承，顶点为&lt;code&gt;Object&lt;/code&gt;。&lt;/p&gt;&lt;h2 id=&quot;类与对象type&quot;&gt;类与对象（Typ
      
    
    </summary>
    
      <category term="Python" scheme="http://spiedeman.github.io/categories/Python/"/>
    
    
      <category term="类型与对象" scheme="http://spiedeman.github.io/tags/%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>在集群（CentOS 6.6）上安装YouCompleteMe</title>
    <link href="http://spiedeman.github.io/posts/3242500049/"/>
    <id>http://spiedeman.github.io/posts/3242500049/</id>
    <published>2018-12-08T16:25:58.000Z</published>
    <updated>2021-09-18T02:10:59.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="准备工作">准备工作</h1><h2 id="获取动态库">获取动态库</h2><p>安装<code>YouCompleteMe</code>所需的其实只有一个动态库文件<code>libclang.so.$version</code>。由于<code>YCM</code>一直在升级，对<code>clang</code>的版本要求也越来越高。 无奈官网最新的几个版本都没有给出<code>CentOS</code>的预编译包，只能下载官网<code>unknown-linux-gnu</code>版本或自行编译<code>clang</code>得到库文件。</p><p>实际尝试过后发现官网<code>unknown-linux-gnu</code>版本虽然可以编译通过，但是无法使用。因此只能选择自行编译<code>clang</code>，具体编译安装过程可以<a href="/posts/2372579481/" title="参考">参考</a>。</p><h2 id="配置gcc及g版本">配置gcc及g++版本</h2><p>由于集群默认<code>gcc</code>版本太低，故需切换高版本<code>gcc</code>并设置<code>CC</code>和<code>CXX</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> CC=gcc</span><br><span class="line"><span class="built_in">export</span> CXX=g++</span><br><span class="line"><span class="comment"># 不做上述设置则需要添加 CMAKE 选项</span></span><br><span class="line"><span class="comment"># -DCMAKE_C_COMPILER=gcc</span></span><br><span class="line"><span class="comment"># —DCMAKE_CXX_COMPILER=g++</span></span><br></pre></td></tr></table></figure><p></p><h2 id="设置python版本">设置python版本</h2><p><code>YouCompleteMe</code>目前同时支持<code>python2</code>及<code>python3</code>，因此开启<code>vim</code>对<code>python2/3</code>的支持均可以。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换shell中python版本，使其与vim支持的一致</span></span><br><span class="line">pyenv shell 2.7.15</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">pyenv shell 3.6.6</span><br></pre></td></tr></table></figure><p></p><p><strong>问题</strong>：原本想编译<code>vim</code>使其同时支持<code>python2</code>和<code>python3</code>，但不知哪里出了问题，虽然显示同时支持，可实际上一个都不支持。</p><h1 id="安装-ycm">安装 YCM</h1><h2 id="方法一">方法一</h2><p>使用自带安装脚本<code>install.py</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># YCM 通过sha256来判断是否需要从官网下载需要的库文件</span></span><br><span class="line"><span class="comment"># 为了避免自动下载，使其使用自行编译并打包的动态库</span></span><br><span class="line"><span class="comment"># 需要修改如下文件</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/.vim/vim_plugin/YouCompleteMe/third_party/ycmd/cpp/ycm/</span><br><span class="line">vim CMakeLists.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改第74行，将该sha256值替换为自己的压缩文件的sha256值，保存并推出。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将打包的库文件放到如下目录中</span></span><br><span class="line">mv /path/to/my/libclang-<span class="variable">$version</span>-*.tar.bz2 ../../clang_archive/</span><br></pre></td></tr></table></figure><p></p><h2 id="方法二">方法二</h2><p>使用我自己写的脚本进行<code>Full Installation</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义路径</span></span><br><span class="line">pathbuild=<span class="variable">$HOME</span>/ycm_build</span><br><span class="line">pathdest=<span class="variable">$HOME</span>/.vim/vim_plugin/YouCompleteMe/third_party/ycmd/cpp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建目录 build</span></span><br><span class="line">[ -d <span class="variable">$pathbuild</span> ] &amp;&amp; rm -rf <span class="variable">$pathbuild</span></span><br><span class="line">mkdir <span class="variable">$pathbuild</span> &amp;&amp; <span class="built_in">cd</span> <span class="variable">$pathbuild</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始编译</span></span><br><span class="line">cmake -DCMAKE_C_COMPILER=gcc \</span><br><span class="line">    -DCMAKE_CXX_COMPILER=g++ \</span><br><span class="line">    -DUSE_PYTHON2=<span class="string">'OFF'</span> \</span><br><span class="line">    -DPYTHON_INCLUDE_DIR=<span class="variable">$HOME</span>/.pyenv/versions/3.6.6/include/python3.6m \</span><br><span class="line">    -DPYTHON_LIBRARY=<span class="variable">$HOME</span>/.pyenv/versions/3.6.6/lib/libpython3.6m.so \</span><br><span class="line">    -G <span class="string">"Unix Makefiles"</span> -DEXTERNAL_LIBCLANG_PATH=/path/to/libclang.so .  <span class="variable">$pathdest</span></span><br><span class="line"></span><br><span class="line">cmake --build . --target ycm_core --config Release</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除目录 build</span></span><br><span class="line">rm -rf <span class="variable">$pathbuild</span></span><br></pre></td></tr></table></figure><p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;准备工作&quot;&gt;准备工作&lt;/h1&gt;&lt;h2 id=&quot;获取动态库&quot;&gt;获取动态库&lt;/h2&gt;&lt;p&gt;安装&lt;code&gt;YouCompleteMe&lt;/code&gt;所需的其实只有一个动态库文件&lt;code&gt;libclang.so.$version&lt;/code&gt;。由于&lt;code&gt;YCM&lt;/
      
    
    </summary>
    
      <category term="Vim" scheme="http://spiedeman.github.io/categories/Vim/"/>
    
    
      <category term="YouCompleteMe" scheme="http://spiedeman.github.io/tags/YouCompleteMe/"/>
    
  </entry>
  
</feed>
