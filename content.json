{"pages":[{"title":"关于","date":"2019-04-18T04:42:57.222Z","updated":"2019-04-18T04:42:57.221Z","comments":false,"path":"about/index.html","permalink":"http://spiedeman.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2019-04-18T04:42:01.491Z","updated":"2019-04-18T04:42:01.491Z","comments":false,"path":"books/index.html","permalink":"http://spiedeman.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-04-18T04:42:26.706Z","updated":"2019-04-18T04:42:26.706Z","comments":false,"path":"categories/index.html","permalink":"http://spiedeman.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-04-18T04:42:51.293Z","updated":"2019-04-18T04:42:51.292Z","comments":true,"path":"links/index.html","permalink":"http://spiedeman.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-04-01T14:43:27.031Z","updated":"2019-03-17T15:08:32.000Z","comments":false,"path":"repository/index.html","permalink":"http://spiedeman.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-04-18T04:42:46.311Z","updated":"2019-04-18T04:42:46.311Z","comments":false,"path":"tags/index.html","permalink":"http://spiedeman.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"GitBook 安装配置 & 导出 PDF","slug":"gitbook2pdf","date":"2019-04-18T11:46:20.000Z","updated":"2019-04-18T12:35:22.732Z","comments":true,"path":"posts/3741144490/","link":"","permalink":"http://spiedeman.github.io/posts/3741144490/","excerpt":"","text":"安装 GitBook12npm install -g gitbook-cligitbook -V # 查看版本 使用 calibre 插件生成PDF123456brew cask install calibrecd path/to/book# 生成 pdfgitbook pdf . mypdf.pdf","categories":[],"tags":[{"name":"GitBook","slug":"GitBook","permalink":"http://spiedeman.github.io/tags/GitBook/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-03-17T15:09:08.000Z","updated":"2019-03-17T15:09:08.000Z","comments":true,"path":"posts/1243066710/","link":"","permalink":"http://spiedeman.github.io/posts/1243066710/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post1$ hexo new \"My New Post\"More info: Writing Run server1$ hexo serverMore info: Server Generate static files1$ hexo generateMore info: Generating Deploy to remote sites1$ hexo deployMore info: Deployment","categories":[],"tags":[]},{"title":"vim 技巧","slug":"vim-tips","date":"2019-02-18T02:11:19.000Z","updated":"2019-03-17T15:09:08.000Z","comments":true,"path":"posts/4131642440/","link":"","permalink":"http://spiedeman.github.io/posts/4131642440/","excerpt":"","text":"用法 自定义映射 正确使用option/Alt键option键在macOS下作为组合按键之一，对应于PC、Linux上的Alt键，但是功能不太一样。Mac上字母及一些标点符号与option组合会输出unicode字符。原因在于按下按下option键发送的不是Escape Sequence。因此在vim,emacs等终端软件中，没法直接使用Alt键定义映射。找到原因就好办，解决方法分为两步：在终端中修改option/Alt键的行为在vim,emacs等运行于终端下的软件中进行可能必要的设置以终端程序kitty和alacritty为例，具体讨论解决方法中的第一步如何操作。kitty打开配置文件kitty.conf找到选项macos_option_as_alt no，将no改为yesalacrity打开配置文件alacrity.yml定位到key_bindings添加需要的键位设置，例如 - { key: x, mods: Alt, chars: &quot;\\x1bx&quot; }以运行在终端下的vim为例，给出第二步中需要的具体操作。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162function! Terminal_MetaMode(mode) set ttimeout if $TMUX != '' set ttimeoutlen=30 elseif &amp;ttimeoutlen &gt; 80 || &amp;ttimeoutlen &lt;= 0 set ttimeoutlen=80 endif if has('nvim') || has('gui_running') || $TERM_PROGRAM =~? 'iTerm2' return endif \" 👆表示只有某些终端下的vim需要👇的设置 function! s:metacode(mode, key) \" 这个函数的作用是告诉vim，&lt;M-x&gt;的键盘序列码是多少 \" 这样vim将按照ttimeoutlen的设置来检查是否超时 \" 如果用 `noremap &lt;ESC&gt;x &lt;M-x&gt;` 然后 `noremap &lt;M-x&gt; ...`的方式， \" 则会使用timeoutlen来检查是否超时 \" 一般timeoutlen设置的相对更大，如果用它更容易误操作，降低使用体验 if a:mode == 0 exec \"set &lt;M-\".a:key.\"&gt;=\\e\".a:key else \"👇这条需要对终端进行更针对性的设置，写本节时只想到在alacrity中设置会容易些 exec \"set &lt;M-\".a:key.\"&gt;=\\e]&#123;0&#125;\".a:key.\"~\" endif endfunction \" 针对alacrity，还需设置几个功能键 if $TERM_PROGRAM =~? 'alacritty' exec \"set &lt;F1&gt;=\\eOP\" exec \"set &lt;F2&gt;=\\eOQ\" exec \"set &lt;F3&gt;=\\eOR\" exec \"set &lt;F4&gt;=\\eOS\" endif for i in range(10) call s:metacode(a:mode, nr2char(char2nr('0') + i)) endfor for i in range(26) call s:metacode(a:mode, nr2char(char2nr('a') + i)) call s:metacode(a:mode, nr2char(char2nr('A') + i)) endfor if a:mode != 0 for c in [',', '.', '/'. ';', '[', ']', '&#123;', '&#125;'] call s:metacode(a:mode, c) endfor for c in ['?', ':', '-', '_'] call s:metacode(a:mode, c) endfor else for c in [',', '.', '/', ';', '&#123;', '&#125;'] call s:metacode(a:mode, c) endfor for c in ['?', ':', '-', '_'] call s:metacode(a:mode, c) endfor endifendfunction\" 设置用户自定义命令command! -nargs=0 -bang VimMetaInit call Terminal_MetaMode(&lt;bang&gt;0)\" buffer 读入后自动进行设置augroup alt_key autocmd! autocmd BufReadPost * :VimMetaInitaugroup END 用户自定义事件自定义了切换透明和背景的函数，并绑定了快捷键。同时主题栏使用的是lightline。我为dark和light两种背景选取不同的lightline主题，为了使背景切换之后，主题栏的切换也生效，这里使用用户自定义事件来解决问题。当然这不是唯一的方法。1234567891011function! ToggleBackground() \" A lot of stuff is happening here. \" 定义一个自定义事件 doautocmd User ToggleBackgroundExitendfunctionfunction! ToggleTransparent() \" A lot of stuff is happening here. \" 定义一个自定义事件 doautocmd User ToggleTransparentExitendfunction现在可以在切换背景和透明度执行完成后做任何想做的事：1autocmd User ToggleBackgroundExit call lightline#enable() 插件 插件管理器（vim-plug）vim-plug是一款异步插件管理器。具有安装速度快，延迟加载等特性。这里要讨论的是刚发现的一个特性，可以让插件按照依赖关系进行加载。栗子🌰，我有三款用于markdown的插件，分别是plasticboy/vim-markdownjszakmeister/markdown2ctagsiamcco/markdown-preview.nvim原本可以在每个插件后面，用{'for':'markdown'}使其仅在编辑.md文件时才加载。但我发现这种方法对第二款插件无效。因此想到这里的办法。vim-plug在调用函数plug#load()加载插件之后会以插件名定义一个用户自定义事件。可以利用这一事件触发对其有依赖的插件的调用。如下为具体的使用案例：1234567891011121314\" 以文件类型作为加载的依据Plug 'iamcco/markdown-preview.nvim', &#123;'for': 'markdown', 'do': 'cd app &amp; yarn install'&#125; \" 下面的插件无法按照文件类型进行加载 \" 故通过vim-plug 定义的用户自定义事件进行触发 Plug 'plasticboy/vim-markdown', &#123;'on' : []&#125; Plug 'jszakmeister/markdown2ctags', &#123;'on': []&#125; augroup vimplug_load_for_markdown autocmd! autocmd User markdown-preview.nvim plug#load( \\ 'vim-markdown', \\ 'markdown2ctags', \\ ) \\ | autocmd! vimplug_load_for_markdown augroup END进一步，针对一个插件的所有配置可以做到这样：在插件被加载前，不载入加载后，自动载入可以这样实现12345678910\" 仍然以上面的插件为例\" 在载入 vim-markdown之后自动加载相关配置。所有配置在函数SetVimmarkdown()之中function! SetVimmarkdown() \" all configurations for vim-markdown are at hereendfunctionaugroup load_for_vimmarkdown autocmd! autocmd User vim-markdown call SetVimmarkdown() | autocmd! load_for_vimmarkdownaugroup END 中文输入法vim 的模式切换与中文输入法并不总能够和谐共处。英文中文normal😃😦insert😃😃解决这个问题的方式大体上有两种，1、vim提供中文输入法，那么这个问题就留给vim及其插件的开发者们去解决了；2、仍然使用外部中文输入法，如搜狗等，那么关键在于以哪种方式自动切换输入法！这里沿用第二种思路。尝试过如下几种方式：通过 vim 内置函数模拟按键操作来切换输入法。没有成功，但不排除可行性。调用外部程序进行输入法切换。成功，但是并不完美。所以最终采取的方案是通过调用外部程序在进入和离开insert模式时只能切换输入法。实现方式具体看下面的vim配置。12345678910111213141516171819202122\" 定义缓冲区变量，使得可以对每个缓冲区单独监控输入法状态au BufEnter * let b:im=0\" 为了尽量不影响体验，通过异步机制来进行处理\" 下面的函数用于在 job 进行过程中处理返回信息fun! IMHandler(channel, msg) if a:msg !=? 'com.apple.keylayout.ABC' \" 切换到英文输入法之前保存当前状态 let b:im = 1 call job_start(['issw', 'com.apple.keylayout.ABC']) endifendfunfun! Lang2en() let job = job_start(['issw'], &#123;\"out_cb\": \"IMHandler\"&#125;)endfun\" 这里中文输入法的切换用了自己写的脚本，虽然也可以用上面的 issw 命令。fun! Lang2zh() if b:im == 1 call job_start(['switchim']) endifendfunautocmd InsertEnter * call Lang2zh()autocmd BufEnter,InsertLeave * call Lang2en()因为不想用破解软件来修改按键映射及快捷键，导致仍有不足之处：调用的外部程序切换输入法不够快，仍然有一定几率产生困扰。insert 模式下，如果要用搜狗输入法，从英文切换回中文比较麻烦。","categories":[{"name":"Vim","slug":"Vim","permalink":"http://spiedeman.github.io/categories/Vim/"}],"tags":[{"name":"Vim","slug":"Vim","permalink":"http://spiedeman.github.io/tags/Vim/"}]},{"title":"graphviz-introduction","slug":"graphviz-introduction","date":"2019-02-16T08:46:44.000Z","updated":"2019-03-17T15:09:06.000Z","comments":true,"path":"posts/1414645917/","link":"","permalink":"http://spiedeman.github.io/posts/1414645917/","excerpt":"","text":"这篇文章参考自Drawing graphs with dotdotdotdot 通过DOTDOTDOT语言来作图。该语言描述了三大对象：图(graphs)，节点(nodes)，边(edges)。同时支持有向图和无向图，并支持图的嵌套(subgraphsubgraphsubgraph)。默认采用有向图的布局方式，有另一个独立的布局工具，neato，用于无向图。dotdotdot 编译的方式是按顺序一行一行地处理 *.dot 文件中内容。所以各种对象的属性的有效性从从属性设置语句所在行开始直到下一次属性设置语句所在行之前。完整的属性描述可以参考GraphvizGraphvizGraphviz官网的该页面。 要素一幅图可以包含如下要素：注释双斜杠有向图 or 无向图节点之间的关系有向图：a-&gt;b，节点 a 指向节点 b无向图：a--b，节点 a 和节点 b连通定义节点属性形状，多边形polygon和record（不知道怎么翻译）颜色标签等等定义边的属性形状颜色文本等等定义结构(record)内部结构方向，水平或竖直排列标签 样例12345678digraph G&#123; a -&gt; b -&gt; c; b -&gt; d; a [shape=polygon,sides=5,peripheries=3,color=lightblue,style=filled]; c [shape=polygon,sides=4,skew=.4,label=&quot;hello world&quot;] d [shape=invtriangle]; e [shape=polygon,sides=4,distortion=.7];&#125;12345678digraph structs&#123;node [shape=record]; struct1 [shape=record,label=&quot;&lt;f0&gt; left|&lt;f1&gt; mid\\ dle|&lt;f2&gt; right&quot;]; struct2 [shape=record,label=&quot;&lt;f0&gt; one|&lt;f1&gt; two&quot;]; struct3 [shape=record,label=&quot;hello\\nworld | &#123; b |&#123;c|&lt;here&gt; d|e&#125;| f&#125;|g|h &quot;]; struct1 -&gt; struct2; struct1 -&gt; struct3;&#125;123456789101112131415161718192021222324digraph G &#123; node[shape=record,height=.1]; //定义node样式 node0[label=&quot;&lt;f0&gt; |&lt;f1&gt; A|&lt;f2&gt; &quot;]; //具体的一个node，含三个属性，第二个属性有名字 node0[label=&quot;&lt;f0&gt; |&lt;f1&gt; B|&lt;f2&gt; &quot;]; node0[label=&quot;&lt;f0&gt; |&lt;f1&gt; C|&lt;f2&gt; &quot;]; node0[label=&quot;&lt;f0&gt; |&lt;f1&gt; D|&lt;f2&gt; &quot;]; node0[label=&quot;&lt;f0&gt; |&lt;f1&gt; E|&lt;f2&gt; &quot;]; node0[label=&quot;&lt;f0&gt; |&lt;f1&gt; F|&lt;f2&gt; &quot;]; node0[label=&quot;&lt;f0&gt; |&lt;f1&gt; H|&lt;f2&gt; &quot;]; node0[label=&quot;&lt;f0&gt; |&lt;f1&gt; I|&lt;f2&gt; &quot;]; node0[label=&quot;&lt;f0&gt; |&lt;f1&gt; J|&lt;f2&gt; &quot;]; node0[label=&quot;&lt;f0&gt; |&lt;f1&gt; K|&lt;f2&gt; &quot;]; &quot;node0&quot;:f2 -&gt; &quot;node1&quot;: f1; //node0的第三个属性指向node1的第二个属性 &quot;node1&quot;:f0 -&gt; &quot;node2&quot;: f1; &quot;node1&quot;:f1 -&gt; &quot;node3&quot;: f2; &quot;node3&quot;:f0 -&gt; &quot;node4&quot;: f0; &quot;node3&quot;:f1 -&gt; &quot;node5&quot;: f1; &quot;node3&quot;:f2 -&gt; &quot;node6&quot;: f2; &quot;node6&quot;:f1 -&gt; &quot;node7&quot;: f1; &quot;node7&quot;:f1 -&gt; &quot;node8&quot;: f0; &quot;node2&quot;:f2 -&gt; &quot;node9&quot;: f1;&#125;","categories":[{"name":"Graphviz","slug":"Graphviz","permalink":"http://spiedeman.github.io/categories/Graphviz/"}],"tags":[{"name":"graphviz","slug":"graphviz","permalink":"http://spiedeman.github.io/tags/graphviz/"}]},{"title":"Ubuntu 16.04 LTS 开启BBR","slug":"vultr-ubuntu16-04-bbr","date":"2019-01-05T16:56:29.000Z","updated":"2019-03-17T15:09:08.000Z","comments":true,"path":"posts/3381164653/","link":"","permalink":"http://spiedeman.github.io/posts/3381164653/","excerpt":"","text":"Vultr 上安装 ubuntu 16.04 并开启BBR。 更新内核BBR只支持4.9+的Linux内核版本，因此首先检查并更新内核。12345# 查看当前内核版本uname -r# 安装最新版内核sudo apt install linux-image-generic-hwe-16.04 重启1sudo reboot 开启BBR添加如下两行至文件/etc/sysctl.conf12net.ipv4.default_qdisc=fqnet.ipv4.tcp_congestion_control=bbr启动bbr1sysctl -p验证是否成功123lsmod | grep bbrtcp_bbr 20480 1","categories":[{"name":"Vultr","slug":"Vultr","permalink":"http://spiedeman.github.io/categories/Vultr/"}],"tags":[{"name":"BBR","slug":"BBR","permalink":"http://spiedeman.github.io/tags/BBR/"}]},{"title":"python万物皆对象","slug":"python-type-and-object","date":"2018-12-14T11:33:45.000Z","updated":"2019-03-17T15:09:08.000Z","comments":true,"path":"posts/1949292692/","link":"","permalink":"http://spiedeman.github.io/posts/1949292692/","excerpt":"","text":"类与对象Python中有两种关系：类与对象，顶点为Type。继承，顶点为Object。 类与对象（Type）__class__方法查看当前对象所属的类，亦即由哪个类实例化得到。Python 中的对象可以分成两种不是类的对象，例如手里的一个🍎。亦是类的对象，例如🍎，作为水果这个类的一个实例（对象）。类比如下关系：手里的🍎（创建自）🍎（创建自）水果（创建自）食物（创建自）… 顶点Python 版本不是类的对象（创建自）亦是类的对象（创建自）类的类（创建自）Type（顶点） 继承（Object）__base__方法查看当前类的父类，亦即继承自哪个类。Python 中的类也可以分成两种普通类，类继承链条的末端，其实例不是类。元类，类继承链条的非末端，其实例依然是类。类比如下关系：🍎（继承自）水果（继承自）食物（继承自）… 顶点Python 版本普通类（继承自）元类（继承自）…（继承自）Object（顶点） Type/ObjectType 作为类，继承自 Object对象，创建自 Type（自身）Object 作为类，继承自 Object（自身）对象，创建自 Type道生一，一生二，二生三，三生万物网上有人用它来理解 类对象 关系，觉得生动形象，故记录于此。1、道 即 Type2、一 即 元类3、二 即 普通类4、三 即 实例5、万物 即 各种实例属性，方法","categories":[{"name":"Python","slug":"Python","permalink":"http://spiedeman.github.io/categories/Python/"}],"tags":[{"name":"Type","slug":"Type","permalink":"http://spiedeman.github.io/tags/Type/"},{"name":"Object","slug":"Object","permalink":"http://spiedeman.github.io/tags/Object/"}]},{"title":"在集群（CentOS 6.6）上安装YouCompleteMe","slug":"YouCompleteMe-on-ITP","date":"2018-12-08T16:25:58.000Z","updated":"2019-03-17T15:09:06.000Z","comments":true,"path":"posts/3242500049/","link":"","permalink":"http://spiedeman.github.io/posts/3242500049/","excerpt":"","text":"准备工作 获取动态库安装YouCompleteMe所需的其实只有一个动态库文件libclang.so.$version。由于YCM一直在升级，对clang的版本要求也越来越高。无奈官网最新的几个版本都没有给出CentOS的预编译包，只能下载官网unknown-linux-gnu版本或自行编译clang得到库文件。实际尝试过后发现官网unknown-linux-gnu版本虽然可以编译通过，但是无法使用。因此只能选择自行编译clang，具体编译安装过程可以参考。 配置gcc及g++版本由于集群默认gcc版本太低，故需切换高版本gcc并设置CC和CXX12345export CC=gccexport CXX=g++# 不做上述设置则需要添加 CMAKE 选项# -DCMAKE_C_COMPILER=gcc# —DCMAKE_CXX_COMPILER=g++ 设置python版本YouCompleteMe目前同时支持python2及python3，因此开启vim对python2/3的支持均可以。1234# 切换shell中python版本，使其与vim支持的一致pyenv shell 2.7.15# orpyenv shell 3.6.6问题：原本想编译vim使其同时支持python2和python3，但不知哪里出了问题，虽然显示同时支持，可实际上一个都不支持。 安装 YCM 方法一使用自带安装脚本install.py。12345678910# YCM 通过sha256来判断是否需要从官网下载需要的库文件# 为了避免自动下载，使其使用自行编译并打包的动态库# 需要修改如下文件cd $HOME/.vim/vim_plugin/YouCompleteMe/third_party/ycmd/cpp/ycm/vim CMakeLists.txt# 修改第74行，将该sha256值替换为自己的压缩文件的sha256值，保存并推出。# 将打包的库文件放到如下目录中mv /path/to/my/libclang-$version-*.tar.bz2 ../../clang_archive/ 方法二使用我自己写的脚本进行Full Installation。1234567891011121314151617181920# 自定义路径pathbuild=$HOME/ycm_buildpathdest=$HOME/.vim/vim_plugin/YouCompleteMe/third_party/ycmd/cpp# 新建目录 build[ -d $pathbuild ] &amp;&amp; rm -rf $pathbuildmkdir $pathbuild &amp;&amp; cd $pathbuild# 开始编译cmake -DCMAKE_C_COMPILER=gcc \\ -DCMAKE_CXX_COMPILER=g++ \\ -DUSE_PYTHON2='OFF' \\ -DPYTHON_INCLUDE_DIR=$HOME/.pyenv/versions/3.6.6/include/python3.6m \\ -DPYTHON_LIBRARY=$HOME/.pyenv/versions/3.6.6/lib/libpython3.6m.so \\ -G \"Unix Makefiles\" -DEXTERNAL_LIBCLANG_PATH=/path/to/libclang.so . $pathdestcmake --build . --target ycm_core --config Release# 删除目录 buildrm -rf $pathbuild","categories":[{"name":"Vim","slug":"Vim","permalink":"http://spiedeman.github.io/categories/Vim/"}],"tags":[{"name":"YouCompleteMe","slug":"YouCompleteMe","permalink":"http://spiedeman.github.io/tags/YouCompleteMe/"}]},{"title":"CentOS6.6编译安装Clang7.0.0","slug":"clang-from-source-on-centos6","date":"2018-12-08T07:52:16.000Z","updated":"2019-03-17T15:09:06.000Z","comments":true,"path":"posts/2372579481/","link":"","permalink":"http://spiedeman.github.io/posts/2372579481/","excerpt":"","text":"下载安装包编译安装Clang需要下载7个文件，分别是1、llvm-7.0.0.src.tar.xz2、cfe-7.0.0.src.tar.xz13、clang-tools-extra-7.0.0.src.tar.xz4、compiler-rt-7.0.0.src.tar.xz5、libcxx-7.0.0.src.tar.xz6、libcxxabi-7.0.0.src.tar.xz7、libunwind-7.0.0.src.tar.xz1234567891011121314version=7.0.0url=http://releases.llvm.org/$versionfile1=llvm-$version.srcfile2=cfe-$version.srcfile3=clang-tools-extra-$version.srcfile4=compiler-rt-$version.srcfile5=libcxx-$version.srcfile6=libcxxabi-$version.srcfile7=libunwind-$version.srcfor file in $file&#123;1..7&#125;do [ -f $file.tar.xz ] || wget $url/$file.tar.xzdone 编译安装12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 进入安装脚本所在的目录path=$PWD/$0cd $&#123;path%/*&#125;# 获取 clang 版本号for file in `ls .`do [[ $file =~ \"llvm\" ]] &amp;&amp; version=$filedoneversion=$&#123;version/*-&#125;version=$&#123;version%.src*&#125;# 新建 build 目录mkdir build &amp;&amp; cd build# 解压for file in $file&#123;1..7&#125;do tar xvf ../$file.tar.xzdone# 移动目录mv $file2 $file1/tools/clangmv $file3 $file1/tools/clang/tools/extramv $file4 $file1/projects/compiler-rtmv $file5 $file1/projects/libcxxmv $file6 $file1/projects/libcxxabimv $file7 $file1/projects/libunwind# 编译及安装# 由于集群上默认gcc版本太低，所以必须切换到较高版本。# 即便如此，仍需在shell中设定CC、CXX或者添加CMAKE选项指定C、CXX编译器才能通过检测export CC=gccexport CXX=g++# 若进行了上面的设置，则可省去选项 -DCMAKE_C_COMPILER 和 -DCMAKE_CXX_COMPILERcmake -G\"Unix Makefiles\" \\ -DCMAKE_CXX_COMPILER=/path/to/specified/g++ \\ -DCMAKE_C_COMPILER=/path/to/specified/gcc \\ -DCMAKE_INSTALL_PREFIX=/path/to/installation \\ -DCMAKE_BUILD_TYPE=Release \\ -DLLVM_TARGETS_TO_BUILD=\"X86\" \\ $file1 # -DCLANG_DEFAULT_CXX_STDLIB=libc++ \\make -j 4make installmake install-cxx install-cxxabi 打包clang动态库手动安装clang的目的主要是为了安装YouCompleteMe，需要用到的其实就只有一个动态库文件libclang.so.7。1234mkdir libcp -l /path/to/installation/lib/libclang.so* libtar -cjf libclang-$version-x86_64-unknown-linux-gnu.tar.bz2 librm -rf lib","categories":[{"name":"Clang","slug":"Clang","permalink":"http://spiedeman.github.io/categories/Clang/"}],"tags":[{"name":"clang","slug":"clang","permalink":"http://spiedeman.github.io/tags/clang/"},{"name":"centos","slug":"centos","permalink":"http://spiedeman.github.io/tags/centos/"}]},{"title":"vim 编译安装及配置","slug":"vim-install-from-source","date":"2018-12-08T06:56:12.000Z","updated":"2019-04-01T15:00:21.836Z","comments":true,"path":"posts/3465068350/","link":"","permalink":"http://spiedeman.github.io/posts/3465068350/","excerpt":"","text":"提前准备为了脚本能顺利运行，需要预先安装好如下几个软件：curljqwget 下载源代码从github下载vim，好处是可以自由切换版本。12345678910# git clone https://github.com/vim/vim.git# 利用 curl、jq、awk 以及 GitHub 的 API 获取最新版本下载链接# 利用 wget 下载并保存为 vim-latest.tar.gzfile=vim-latest.tar.gzapi=\"https://api.github.com/repos/vim/vim/tags\"download_url=$(curl -s $api | jq -r \".[] | .tarball_url\" | awk 'NR==1&#123;print&#125;')latest_version=$(curl -s $api | jq -r \".[] | .name\" | awk 'NR==1&#123;print&#125;')wget -O $file $download_url解压，进入目录123456mkdir vim-latesttar -zxf vim-latest.tar.gz -C vim-latest --strip-components=1cd vim || exit# 查看当前版本git describe --tags 编译安装1234567891011121314151617181920# 清除上次configure留下的痕迹make distclean# 重新configure./configure \\--prefix=$HOME/Program/vim/$&#123;latest_version##*v&#125; \\--enable-multibyte=yes \\--enable-gui=gtk2 \\--with-x \\--with-features=huge \\--enable-python3interp=yes \\--enable-perlinterp=yes \\--enable-rubyinterp=yes \\--enable-luainterp=yes \\--with-luajit \\--enable-cscope \\--with-compiledby=徐武涛 \\# 安装make -j 16 &amp;&amp; make install 卸载vim的Makefile提供了uninstall选项，因此卸载很容易。1cd vim &amp;&amp; make uninstall","categories":[{"name":"Vim","slug":"Vim","permalink":"http://spiedeman.github.io/categories/Vim/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://spiedeman.github.io/tags/vim/"}]},{"title":"Homebrew 使用方法","slug":"homebrew-guide","date":"2018-12-04T13:55:23.000Z","updated":"2019-03-17T15:09:08.000Z","comments":true,"path":"posts/319510325/","link":"","permalink":"http://spiedeman.github.io/posts/319510325/","excerpt":"","text":"查看已安装的包1brew list 更新 Homebrew要获取最新的包列表，需先更新 Homebrew 自身。1brew update 更新包（formula）查看哪些包有新版本1234brew outdatedbrew upgrade # 更新左右包brew upgrade $FORMULA # 更新指定包更新时自动清理旧版本，在brew upgrade前设置环境变量HOMEBREW_UPGRADE_CLEANUP。 清理旧版本123brew cleanup # 清理所有包的旧版本brew cleanup $FORMULA # 清理指定包的旧版本brew cleanup -n # 查看可清理的旧版本包，不会执行清除操作彻底卸载，包括删除旧版本1brew uninstall formaula_name --force 锁定包被锁定的包在更新时会被略过。12brew pin $FORMULA # 锁定brew unpin $FORMULA # 取消锁定 切换版本时间一长，各个包可能都有多个版本并存。1brew switch $FORMULA $VERSION # 切换包到指定版本 查看依赖关系1brew deps --installed --tree # 查看已安装的包的依赖关系","categories":[{"name":"Homebrew","slug":"Homebrew","permalink":"http://spiedeman.github.io/categories/Homebrew/"}],"tags":[{"name":"homebrew","slug":"homebrew","permalink":"http://spiedeman.github.io/tags/homebrew/"}]},{"title":"euler-lagrange-equation","slug":"euler-lagrange-equation","date":"2018-12-02T12:12:33.000Z","updated":"2019-03-17T15:09:06.000Z","comments":true,"path":"posts/4141491110/","link":"","permalink":"http://spiedeman.github.io/posts/4141491110/","excerpt":"","text":"作用量作用量 SSS 是拉氏密度L\\mathcal{L}L 在四维时空中的积分，S=1c∫d4xL(ϕ,∂μϕ)S = \\frac{1}{c}\\int d^4x \\mathcal{L}(\\phi,\\partial_\\mu\\phi)S=c1​∫d4xL(ϕ,∂μ​ϕ) 场的变分对场的变分的贡献共来自两个方面，1、坐标无穷小变换；2、场自身的无穷小变换。下面分别讨论这两种情况。1、坐标无穷小变换xμ→x′μ=xμ+δxμx^{\\mu}\\rightarrow x&#x27;^{\\mu}= x^{\\mu} + \\delta x^{\\mu}xμ→x′μ=xμ+δxμ通常谈论的场的变分是指坐标不变时的变分 δˉ\\bar{\\delta}δˉ，δˉϕ(x)=ϕ′(x)−ϕ(x)\\bar{\\delta}\\phi(x) = \\phi&#x27;(x) - \\phi(x)δˉϕ(x)=ϕ′(x)−ϕ(x)根据标量场 ϕ(x)\\phi(x)ϕ(x) 在坐标变换下的性质 ϕ′(x′)=ϕ(x)\\phi&#x27;(x&#x27;)=\\phi(x)ϕ′(x′)=ϕ(x)，容易得到δˉϕ=−δxμ∂μϕ\\bar{\\delta}\\phi = -\\delta x^{\\mu}\\partial_{\\mu}\\phiδˉϕ=−δxμ∂μ​ϕ2、场自身的无穷小变换在没有坐标变换的情况下，场 ϕ\\phiϕ 产生了一个无穷小变换。此时坐标不变时的变分为δˉϕ=ϕ′(x)−ϕ(x)=δϕ\\bar{\\delta}\\phi = \\phi&#x27;(x) - \\phi(x) = \\delta\\phiδˉϕ=ϕ′(x)−ϕ(x)=δϕ注意到这里用 δ\\deltaδ 表示场自身的变分。通常情况下遇到的变分就是这种情况。3、一般情况如果同时考虑到坐标变换以及场自身的变分，则标量场 ϕ(x)\\phi(x)ϕ(x) 满足的性质需修改为ϕ′(x′)=ϕ(x)+δϕ(x)\\phi&#x27;(x&#x27;) = \\phi(x) + \\delta\\phi(x)ϕ′(x′)=ϕ(x)+δϕ(x)故坐标不变时的变分为δˉϕ(x)=ϕ′(x)−ϕ(x)=ϕ(x−δx)+δϕ(x−δx)−ϕ(x)≈δϕ(x)−δxμ∂μϕ(x)\\begin{aligned} \\bar{\\delta}\\phi(x) &amp;= \\phi&#x27;(x) - \\phi(x) \\\\ &amp;= \\phi(x-\\delta{x}) + \\delta\\phi(x-\\delta{x}) - \\phi(x) \\\\ &amp;\\approx \\delta\\phi(x) - \\delta{x^\\mu}\\partial_{\\mu}\\phi(x) \\\\ \\end{aligned}δˉϕ(x)​=ϕ′(x)−ϕ(x)=ϕ(x−δx)+δϕ(x−δx)−ϕ(x)≈δϕ(x)−δxμ∂μ​ϕ(x)​根据上述讨论可知，场自身的变分一般情况下并非坐标不变时的变分 (δˉ≠δ\\bar{\\delta} \\neq \\deltaδˉ​=δ)，只有当不存在坐标变换的情况下两者才相等 (δˉ=δ\\bar{\\delta} = \\deltaδˉ=δ)。 拉氏密度的变分一般情况下，作为标量场的拉氏密度的坐标不变时的变分为δˉL(x)=L′(x)−L(x)=L(x−δx)−δL(x−δx)−L(x)=δL(x)−δxμ∂μL=∂L∂ϕδˉϕ+∂L∂∂μϕδˉ∂μϕ\\begin{aligned} \\bar{\\delta}\\mathcal{L}(x) &amp;= \\mathcal{L}&#x27;(x) - \\mathcal{L}(x) \\\\ &amp;= \\mathcal{L}(x-\\delta x) - \\delta\\mathcal{L}(x-\\delta x) - \\mathcal{L}(x) \\\\ &amp;= \\delta\\mathcal{L}(x) - \\delta{x^\\mu}\\partial_{\\mu}\\mathcal{L} \\\\ &amp;= \\frac{\\partial\\mathcal{L}}{\\partial\\phi}\\bar{\\delta}\\phi + \\frac{\\partial\\mathcal{L}}{\\partial\\partial_{\\mu}\\phi}\\bar{\\delta}\\partial_{\\mu}\\phi \\end{aligned}δˉL(x)​=L′(x)−L(x)=L(x−δx)−δL(x−δx)−L(x)=δL(x)−δxμ∂μ​L=∂ϕ∂L​δˉϕ+∂∂μ​ϕ∂L​δˉ∂μ​ϕ​ 作用量的变分δS=∫δ(d4x)L+∫d4xδL=∫d4x(δˉL+δxμ∂μL+L∂μδxμ)=∫d4x(δˉL+∂μ(Lδxμ))=∫d4x(∂L∂ϕδˉϕ+∂L∂∂μϕδˉ∂μϕ+∂μ(Lδxμ))=∫d4x[(∂L∂ϕ−∂μ∂L∂∂μϕ)δˉϕ+∂μ(∂L∂∂μϕδˉϕ+Lδxμ)]\\begin{aligned} \\delta S &amp;= \\int \\delta(d^4 x)\\mathcal{L} + \\int d^4 x\\, \\delta{\\mathcal{L}} \\\\ &amp;= \\int d^4x \\left(\\bar{\\delta}\\mathcal{L}+\\delta x^{\\mu}\\partial_{\\mu}{\\mathcal{L}} + \\mathcal{L}\\partial_{\\mu}\\delta{x^\\mu}\\right) \\\\ &amp;= \\int d^4x \\left(\\bar{\\delta}\\mathcal{L} + \\partial_{\\mu}(\\mathcal{L}\\delta x^{\\mu})\\right) \\\\ &amp;= \\int d^4x \\left(\\frac{\\partial\\mathcal{L}}{\\partial\\phi}\\bar{\\delta}\\phi + \\frac{\\partial\\mathcal{L}}{\\partial\\partial_{\\mu}\\phi}\\bar{\\delta}\\partial_{\\mu}\\phi + \\partial_{\\mu}(\\mathcal{L}\\delta x^{\\mu})\\right) \\\\ &amp;= \\int d^4x \\left[\\left(\\frac{\\partial\\mathcal{L}}{\\partial\\phi} - \\partial_{\\mu}\\frac{\\partial\\mathcal{L}}{\\partial\\partial_{\\mu}\\phi}\\right)\\bar{\\delta}\\phi + \\partial_{\\mu}\\left(\\frac{\\partial\\mathcal{L}}{\\partial\\partial_{\\mu}\\phi}\\bar{\\delta}\\phi+\\mathcal{L}\\delta x^{\\mu}\\right) \\right] \\end{aligned}δS​=∫δ(d4x)L+∫d4xδL=∫d4x(δˉL+δxμ∂μ​L+L∂μ​δxμ)=∫d4x(δˉL+∂μ​(Lδxμ))=∫d4x(∂ϕ∂L​δˉϕ+∂∂μ​ϕ∂L​δˉ∂μ​ϕ+∂μ​(Lδxμ))=∫d4x[(∂ϕ∂L​−∂μ​∂∂μ​ϕ∂L​)δˉϕ+∂μ​(∂∂μ​ϕ∂L​δˉϕ+Lδxμ)]​ 拉格朗日方程假设坐标不变，只考虑场量的变分，则有δˉϕ=δϕδxμ=0\\begin{aligned} &amp; \\bar{\\delta}\\phi = \\delta\\phi \\\\ &amp; \\delta x^{\\mu} = 0 \\end{aligned}​δˉϕ=δϕδxμ=0​由表面项在4维时空边界上为零及变分 δˉϕ\\bar{\\delta}\\phiδˉϕ 任意，作用量的变分取极值的条件给出拉格朗日方程∂μ∂L∂∂μϕ−∂L∂ϕ=0\\partial_{\\mu}\\frac{\\partial\\mathcal{L}}{\\partial\\partial_{\\mu}\\phi} - \\frac{\\partial\\mathcal{L}}{\\partial\\phi} = 0∂μ​∂∂μ​ϕ∂L​−∂ϕ∂L​=0 诺特定理若场 ϕ(x)\\phi(x)ϕ(x)满足拉格朗日方程，则作用量的变分为某个表面项的4维积分。若场在变换（包括坐标变换和自身变换）前后均满足拉格朗日方程，且保持作用量不变。则由δS=1c∫d4x∂μjμ=0\\delta S = \\frac{1}{c} \\int d^4x \\partial_{\\mu}j^{\\mu} = 0δS=c1​∫d4x∂μ​jμ=0以及jμ=∂L∂∂μϕδˉϕ+Lδxμj^{\\mu} = \\frac{\\partial\\mathcal{L}}{\\partial\\partial_{\\mu}\\phi}\\bar{\\delta}\\phi + \\mathcal{L}\\delta x^{\\mu}jμ=∂∂μ​ϕ∂L​δˉϕ+Lδxμ得到一个对应该变换的守恒流 jμj^{\\mu}jμ。将 jμj^{\\mu}jμ 改写为jμ=∂L∂∂μϕδϕ−(∂L∂∂μϕ∂ν−Lgνμ)δxνj^{\\mu} = \\frac{\\partial\\mathcal{L}}{\\partial\\partial_{\\mu}\\phi}\\delta\\phi - \\left(\\frac{\\partial\\mathcal{L}}{\\partial\\partial_{\\mu}\\phi}\\partial_{\\nu} - \\mathcal{L}g^{\\mu}_{\\nu}\\right)\\delta x^{\\nu}jμ=∂∂μ​ϕ∂L​δϕ−(∂∂μ​ϕ∂L​∂ν​−Lgνμ​)δxνδϕ\\delta\\phiδϕ 和 δxμ\\delta x^{\\mu}δxμ 现在是保持拉格朗日方程不变的变换。","categories":[{"name":"QFT","slug":"QFT","permalink":"http://spiedeman.github.io/categories/QFT/"}],"tags":[{"name":"最小作用量","slug":"最小作用量","permalink":"http://spiedeman.github.io/tags/最小作用量/"},{"name":"诺特定理","slug":"诺特定理","permalink":"http://spiedeman.github.io/tags/诺特定理/"}]},{"title":"Mac下安装Python版CAMB","slug":"camb-with-python-on-mac","date":"2018-11-26T09:48:03.000Z","updated":"2019-03-17T15:09:06.000Z","comments":true,"path":"posts/3538923028/","link":"","permalink":"http://spiedeman.github.io/posts/3538923028/","excerpt":"","text":"安装过程遇到的坑camb的最新版已经支持Intel Fortran编译器进行编译。然而编译python版本camb的过程中会遇到不少问题。1、编译选项冲突查看Makefile发现，MacOS平台下camb共享库camblib.so的编译选项中SFFLAGS保持默认会出现编译错误。123# -fminshared 与 -fpic 选项冲突# 修改为SFFLAGS = -dynamiclib2、动态库加载错误修改Makefile之后，编译没有问题，但是在Python中import时会出现库未加载的错误。1234OSError:dlopen(/Users/xuwutao/.pyenv/versions/3.7.1/envs/science/lib/python3.7/site-packages/camb/camblib.so, 6): Library not loaded: @rpath/libiomp5.dylib Referenced from : /Users/xuwutao/.pyenv/versions/3.7.1/envs/science/lib/python3.7/site-packages/camb/camblib.so Reason: image not found解决办法：将libiomp5.dylib所在的目录加入@rpath中。1install_name_tool -add_rpath /Users/xuwutao/Program/intel/2018/compilers_and_libraries_2018.1.126/mac/compiler/lib /Users/xuwutao/.pyenv/versions/3.7.1/envs/science/lib/python3.7/site-packages/camb/camblib.so 疑问原以为设置好DYLD_LIBRARY_PATH就没有问题，没想到还需要设置@rpath。估计和Mac下动态库的加载机制有关，详细情况以后有时间再研究吧。","categories":[{"name":"python","slug":"python","permalink":"http://spiedeman.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://spiedeman.github.io/tags/python/"},{"name":"camb","slug":"camb","permalink":"http://spiedeman.github.io/tags/camb/"}]},{"title":"jupyter-with-virtualenv","slug":"jupyter-with-virtualenv","date":"2018-11-26T05:36:56.000Z","updated":"2019-03-17T15:09:08.000Z","comments":true,"path":"posts/3264731549/","link":"","permalink":"http://spiedeman.github.io/posts/3264731549/","excerpt":"","text":"添加内核终端切换python版本很容易，但在jupyter中应该如何切换环境？假如有一个虚拟环境science，将其导入jupyter的过程如下：1、进入虚拟环境science1pyenv active science2、安装ipykernel1pip install ipykernel3、为jupyter安装新内核1ipython kernel install --user --name science -display-name \"python3 (science)\"4、查看可用内核12345jupyter-kernelspec listAvailable kernerls: science /Users/xuwutao/Library/Jupyter/kernels/science python3 /Users/xuwutao/.pyenv/versions/3.7.1/Python.framework/Versions/3.7/share/jupyter/kernels/python3 修改内核内核在jupyter中以json文件方式存在。每新建一个内核，jupyter会在系统的特定位置新建文件夹，存储相应的json文件。这些位置分布如下：UnixWindowsSystem/usr/share/jupyter/kernels/usr/local/share/jupyter/kernels%PROGRAMDATA\\jupyter\\kernelsEnv{sys.prefix}/share/jupyter/kernelsUser~/Library/Jupyter/kernels (Mac)~/.local/share/jupyter/kernels (Linux)%APPDATA%\\jupyter\\kernels","categories":[{"name":"Python","slug":"Python","permalink":"http://spiedeman.github.io/categories/Python/"}],"tags":[{"name":"jupyter","slug":"jupyter","permalink":"http://spiedeman.github.io/tags/jupyter/"},{"name":"virtualenv","slug":"virtualenv","permalink":"http://spiedeman.github.io/tags/virtualenv/"}]},{"title":"树莓派新手指南","slug":"raspberry-install","date":"2018-11-18T11:12:14.000Z","updated":"2019-03-17T15:09:08.000Z","comments":true,"path":"posts/2712929324/","link":"","permalink":"http://spiedeman.github.io/posts/2712929324/","excerpt":"","text":"刻录系统选好合适的系统镜像之后，用dd命令刻录系统到 sd 卡中。1dd bs=16M if=/path/to/img of=/dev/sdcMac系统下类似，主要注意输出文件是/dev/sdc而不是sd卡上的分区。 开启SSH最新版树莓派系统默认不开启ssh服务。没有显示器的情况下，这是不能忍的。好在有一个简单的办法可以解决，系统刻录完成后在boot分区下新建名为ssh的空白文件。12# 挂载并进入boot分区touch ssh 启动树莓派用网线连接树莓派和Mac，打开Mac终端，通过ssh连接树莓派。12# 将公钥加入远程主机的 authorized_keys 文件中，实现无密码登陆ssh-copy-id pi@raspberrypi 初始化配置输入命令 sudo raspi-config 进入配置模式。常用的有扩展系统分区，修改密码，启动设置等。 修改swap空间大小12345# 修改文件sudo vim /etc/dphys-swapfile# 把 CONF_SWAPSIZE=100 改成需要的大小，单位是m# 重启dphys-swapfile服务sudo service dphys-swapfile restart查看当前swap空间1free -m VNC 远程桌面树莓派自带VNC服务器，通过配置实现远程图形化界面登陆。树莓派官方VNC教程 debian 安装后必做的几件事1、安装shadowsocks。注意pip安装时不要--user选项。配置服务，开机自启动。12# 安装最新版 shadowsockspip install https://github.com/shadowsocks/shadowsocks/archive/master.zippip更新之后可能会遇到问题can not import name main修改 /usr/bin/pip 文件。123456789# 修改前from pip import mainif __name__ == '__main__': sys.exit(main())# 修改后from pip import __main__if __name__ == '__main__': sys.exit(__main__.main())2、安装pyenv1git clone https://github.com/pyenv/pyenv.git ~/.pyenv详细内容参见文章 pyenv基础教程3、安装字体，VNC连接时视觉上不能遭罪。","categories":[{"name":"Raspberrypi","slug":"Raspberrypi","permalink":"http://spiedeman.github.io/categories/Raspberrypi/"}],"tags":[{"name":"Raspberrypi","slug":"Raspberrypi","permalink":"http://spiedeman.github.io/tags/Raspberrypi/"}]},{"title":"矢量函数分解","slug":"vector-tensor-decomposition","date":"2018-10-08T08:34:27.000Z","updated":"2019-03-17T15:09:08.000Z","comments":true,"path":"posts/2388637373/","link":"","permalink":"http://spiedeman.github.io/posts/2388637373/","excerpt":"","text":"结论：纵向无旋，横向无源任意给定一个矢量函数 w(x→)=(w1(x→),w2(x→),w3(x→))w(\\overrightarrow{x})=(w_1(\\overrightarrow{x}),w_2(\\overrightarrow{x}),w_3(\\overrightarrow{x}))w(x)=(w1​(x),w2​(x),w3​(x))。在傅立叶空间中，k→\\overrightarrow{k}k模式的系数w(k→)=(w1(k→),w2(k→),w3(k→))w(\\overrightarrow{k})=(w_1(\\overrightarrow{k}),w_2(\\overrightarrow{k}),w_3(\\overrightarrow{k}))w(k)=(w1​(k),w2​(k),w3​(k))可以分解为动量kkk的平行和垂直方向。w=w//+w⊥w = w^{//} + w^{\\bot}w=w//+w⊥且有 w////k→w^{//} // \\overrightarrow{k}w////k及 w⊥⋅k→=0w^{\\bot}\\cdot{\\overrightarrow{k}} = 0w⊥⋅k=0回到实空间中，发现 w(x→)w(\\overrightarrow{x})w(x) 可以分解为纵向和横向两部分，w//(x→)w^{//}(\\overrightarrow{x})w//(x) 和 w⊥(x→)w^{\\bot}(\\overrightarrow{x})w⊥(x)。分别有如下性质：纵向无旋∇×w//(x→)=0\\nabla \\times w^{//}(\\overrightarrow{x}) = 0∇×w//(x)=0横向无源∇⋅w⊥(x→)=0\\nabla \\cdot w^{\\bot}(\\overrightarrow{x}) = 0∇⋅w⊥(x)=0 投影算符傅立叶空间中，kkk mode 的纵向（横向）投影算符分别为P∥(k⃗)=k^⊗k^P⊥(k⃗)=1−k^⊗k^\\begin{aligned} P^{\\parallel}(\\vec{k}) &amp;= \\hat{k}\\otimes\\hat{k} \\\\ P^{\\perp}(\\vec{k}) &amp;= 1 - \\hat{k}\\otimes\\hat{k} \\\\ \\end{aligned}P∥(k)P⊥(k)​=k^⊗k^=1−k^⊗k^​或者分量表示Pij∥(k⃗)=k^ik^jPij⊥(k⃗)=δij−k^ik^j\\begin{aligned} P^{\\parallel}_{ij}(\\vec{k}) &amp;= \\hat{k}_i\\hat{k}_j \\\\ P^{\\perp}_{ij}(\\vec{k}) &amp;= \\delta_{ij} - \\hat{k}_i\\hat{k}_j \\\\ \\end{aligned}Pij∥​(k)Pij⊥​(k)​=k^i​k^j​=δij​−k^i​k^j​​","categories":[{"name":"Math","slug":"Math","permalink":"http://spiedeman.github.io/categories/Math/"}],"tags":[]},{"title":"pyenv基础教程","slug":"pyenv-guide","date":"2018-09-30T08:52:46.000Z","updated":"2019-03-17T15:09:08.000Z","comments":true,"path":"posts/1952119038/","link":"","permalink":"http://spiedeman.github.io/posts/1952119038/","excerpt":"","text":"pyenv 是一个python版本管理软件。受到ruby的同类软件 rbenv和 ruby-build的启发。 安装 pyenv MacOS使用homebrew安装12brew updatebrew install pyenv Linux1git clone https://github.com/pyenv/pyenv.git ~/.pyenv 配置在.bashrc中添加下列内容：1234export PYENV_ROOT=\"$home/.pyenv\"export PATH=\"$PYENV_ROOT/bin:$path\"# 上面两行不需要，如果采用homebrew安装方式eval \"$(pyenv init -)\" 依赖环境pyenv可以用于安装多个python版本，并对其进行管理。为了避免出现可能的错误，安装之前需要准备好依赖环境。macos1brew install openssl readline sqlite xz zlib如果运行 Mojave 或更高版本，还需额外安装1sudo installer -pkg /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg -target /Debian/Ubuntu1apt-get install -y make build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev 安装pythonpyenv install命令用于安装指定python版本。为了添加framework支持，安装代码应如下1234# MacOSenv python_configure_opts=\"--enable-framework\" pyenv install 3.6.6# Linuxenv python_configure_opts=\"--enable-shared\" pyenv install 3.6.6 参考命令 查看已安装python版本12345pyenv versions system* 2.7.15 (set by /users/xuwutao/.python-version) 3.6.6 版本切换pyenv总共设置了三个命令用于python的版本控制，按优先级由高到低以此为pyenv shellpyenv localpyenv global pyenv shell效果等价于设定环境变量pyenv_version。1234pyenv shell 3.6.6# unsetpyenv shell --unset pyenv local在当前目录下新建文件.python-version，记录python版本号，一行一个。如果当前目录下没有该文件，则一路往上寻找直到系统根目录。123pyenv local 2.7.15# 等价于touch .python-version &amp;&amp; echo '2.7.15' &gt; !$ pyenv global和pyenv global对应的文件为$(pyenv root)/version。123pyenv global 2.7.10# 等价于touch ~/.pyenv/version &amp;&amp; echo '2.7.10' &gt; !$有一个特殊的版本名system是指pyenv之外的python（macos自带，homebrew安装版本等）。三个命令都可以后接多个版本号。","categories":[{"name":"Python","slug":"Python","permalink":"http://spiedeman.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://spiedeman.github.io/tags/Python/"}]},{"title":"physics-oscillation","slug":"physics-oscillation","date":"2018-09-24T02:32:26.000Z","updated":"2019-03-17T15:09:08.000Z","comments":true,"path":"posts/3976093928/","link":"","permalink":"http://spiedeman.github.io/posts/3976093928/","excerpt":"","text":"参考 阻尼振动以弹簧为模型讨论，当考虑空气阻力时，运动方程为ma=−kx−bvma = -kx - bvma=−kx−bv阻尼系数bbb可以随时间变化阻尼振动的结果振动为周期运动，周期由劲度系数kkk和阻尼系数bbb共同决定ω=km→ωN=km−γ24\\omega = \\sqrt{\\dfrac{k}{m}}\\rightarrow \\omega_N = \\sqrt{\\dfrac{k}{m}-\\dfrac{\\gamma^2}{4}}ω=mk​​→ωN​=mk​−4γ2​​振幅随时间减小A→AN=Ae−γt/2A \\rightarrow A_N = Ae^{-\\gamma t / 2}A→AN​=Ae−γt/2图像表示 定量分析运动方程可以改写为d2xdt2+γdxdt+ω2x=0\\dfrac{d^2x}{dt^2} + \\gamma\\dfrac{dx}{dt} + \\omega^2x = 0dt2d2x​+γdtdx​+ω2x=0，γ=bm\\gamma=\\dfrac{b}{m}γ=mb​和ω=km\\omega=\\sqrt{\\dfrac{k}{m}}ω=mk​​考虑同形式的复数方程d2Zdt2+γdZdt+ω2Z=0\\dfrac{d^2Z}{dt^2} + \\gamma\\dfrac{dZ}{dt} + \\omega^2Z = 0dt2d2Z​+γdtdZ​+ω2Z=0，ZZZ 的实数部分即为阻尼方程的解。令Z=CeAtZ = Ce^{At}Z=CeAt，AAA和CCC为复常数，代入上式得到AAA的方程A2+γA+ω2=0A^2 + \\gamma A + \\omega^2 = 0A2+γA+ω2=0AAA的解为A=−γ/2±iω2−γ24A=-\\gamma/2\\pm i\\sqrt{\\omega^2-\\dfrac{\\gamma^2}{4}}A=−γ/2±iω2−4γ2​​， 假设阻力不大，即ω&gt;γ/2\\omega\\gt\\gamma/2ω&gt;γ/2ZZZ的通解为Z=e−γt/2(C1e+iωNt+C2e−iωNt)Z=e^{-\\gamma t/2}(C_1e^{+i\\omega_N t} + C_2e^{-i\\omega_N t})Z=e−γt/2(C1​e+iωN​t+C2​e−iωN​t)故阻尼方程的解为x=Re(Z)=e−γt/2[Dcos⁡(ωNt)−Esin⁡(ωNt)]x = Re(Z) = e^{-\\gamma t/2}[D\\cos(\\omega_N t) - E\\sin(\\omega_N t)]x=Re(Z)=e−γt/2[Dcos(ωN​t)−Esin(ωN​t)]，DDD 和 EEE 为常数。令初始相位为θ0=tan⁡−1(DE)\\theta_0=\\tan^{-1}(\\dfrac{D}{E})θ0​=tan−1(ED​)，L=D2−E2L=\\sqrt{D^2-E^2}L=D2−E2​，xxx可以化简为x=Le−γt/2cos⁡(ωNt+θ0)x = Le^{-\\gamma t/2}\\cos(\\omega_N t + \\theta_0)x=Le−γt/2cos(ωN​t+θ0​)","categories":[{"name":"Physics","slug":"Physics","permalink":"http://spiedeman.github.io/categories/Physics/"},{"name":"Oscillation","slug":"Physics/Oscillation","permalink":"http://spiedeman.github.io/categories/Physics/Oscillation/"}],"tags":[{"name":"Physics","slug":"Physics","permalink":"http://spiedeman.github.io/tags/Physics/"},{"name":"Oscillation","slug":"Oscillation","permalink":"http://spiedeman.github.io/tags/Oscillation/"}]},{"title":"pandas 简介","slug":"pandas-guide","date":"2018-09-21T06:22:14.000Z","updated":"2019-03-17T15:09:08.000Z","comments":true,"path":"posts/1982572123/","link":"","permalink":"http://spiedeman.github.io/posts/1982572123/","excerpt":"","text":"学习目标大致了解pandas库的DataFrame和Series数据结构存取和处理DataFrame和Series中的数据将CSV数据导入pandas库的DataFrame对DataFrame重建索引来随机打乱数据pandas 是一种存列数据分析API。它是用于处理和分析输入数据的强大工具，很多机器学习框架都支持将pandas数据结构作为输入。本文只介绍它的核心概念。有关更完整的参考，请访问 pandas文档网站。 基本概念导入pandas API 并输出相应的 API 版本：1234from __future__ import print_functionimport pandas as pdpd.__version__1u'0.22.2'pandas中主要的数据被实现为以下两类：DataFrame，可以想象成一个Excel表，包含多个行和已命名的列。Series，它是单一列。DataFrame 中包含一个或多个 Series，每个 Series均有一个名称。数据框架是用于 数据操控的一种常用抽象实现形式。 Spark和 R中也有类似的实现。创建 Series 的一种方法时构建 Series 对象。例如：1pd.Series(['San Francisco', 'San Jose', 'Sacramento'])DataFrame 和字典很像，Series 对应字典的 键-值对，Series 的名称为键，数据为值。例如像下面这样创建 DataFrame 对象：1234city_names = pd.Series(['San Francisco', 'San Jose', 'Sacramento'])population = pd.Series([852469, 1015785, 485199])pd.DataFrame(&#123;'City name': city_names, 'Population': population&#125;)但在大多数情况下，是将整个文件加载到 DataFrame 中。1data = pd.read_csv('path or url', *args, **kwargs) 访问数据前面提到，DataFrame 和字典很像，还体现在访问数据的方式上。123cities['City name'] # 返回名称为 City name 的 Seriescities[0:2] # 返回所有 Series 的前两个值构建的 DataFrame此外，pandas针对高级 索引和选择提供了机器丰富的 API。 操控数据可以向 Series 应用 Python 的基本运算指令。例如：1population / 1000.Numpy是一种用于进行科学计算的常用工具包。pandasSeries 可用作大多数 Numpy 函数的参数：12import numpy as npnp.log(population)对于更复杂的单列转换，可以使用 Series.apply。像 Python 映射函数一样，Series.apply 将以参数形式接受 lambda函数，而该函数会应用于每个值。下面的示例创建了一个指明 population 是否超过 100 万的新 Series：123456population.apply(lambda val: val &gt; 1000000)0 False1 True2 Falsedtype: boolDataFrame 的修改方式也非常简单。例如，以下代码向现有 DataFrame 添加了两个 Series：123cities['Area square miles'] = pd.Series([46.87, 176.53, 97.92])cities['Population density'] = cities['Population'] / cities['Area square miles']cities","categories":[{"name":"Python","slug":"Python","permalink":"http://spiedeman.github.io/categories/Python/"},{"name":"Pandas","slug":"Python/Pandas","permalink":"http://spiedeman.github.io/categories/Python/Pandas/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://spiedeman.github.io/tags/Python/"},{"name":"Pandas","slug":"Pandas","permalink":"http://spiedeman.github.io/tags/Pandas/"}]},{"title":"matplotlib 技巧","slug":"matplotlib-tips","date":"2018-09-19T08:04:13.000Z","updated":"2019-03-17T15:09:08.000Z","comments":true,"path":"posts/1362387800/","link":"","permalink":"http://spiedeman.github.io/posts/1362387800/","excerpt":"","text":"收集各种技巧、解决问题的办法。不断加深理解、熟悉matplotlib的使用。 中文查看支持的中文字体运行如下代码123456789101112131415from matplotlib.font_manager import FontManagerimport subprocessfm = FontManager()mat_fonts = set(f.name for f in fm.ttflist)output = subprocess.check_output( 'fc-list :lang=zh -f \"%&#123;family&#125;\\n\"', shell=True)zh_fonts = set(f.split(',', 1)[0] for f in output.split('\\n'))available = mat_fonts &amp; zh_fonts# 可用中文字体for f in available: print f尝试发现matplotlib自带了一个可以显示中文的字体Arial Unicode MS。于是可以如下设置，不用下载字体，不用修改matplotlib配置文件。12from matplotlib import rcParamsrcParams['font.sans-serif'] = ['Arial Unicode MS']搞定中文乱码！ Figure 设置图片大小px(pixel), inch, pt(point)三者之间的关系为1231 px = constant size on screen1 inch = dpi px # dpi is variable1 inch = 72 pt # 确定关系Figure size (figsize) 决定figure的尺寸，单位为inches。默认大小为[6.4, 4.8]。Dots per inches (dpi) 决定figure包含多少像素。默认大小为100。设置为figsize=(w,h)的figure包含123px, py = w * dpi, h * dpi # pixels# e.g.# 6.4 inches * 100 dpi = 640 pixels因此若要获得例如(1200, 600)大小的figure，单位为pixel，可以有各种不同的组合方式1234figsize = (15. 7.5), dpi = 80figsize = (12. 6) , dpi = 100figsize = (8, 4) , dpi = 150figsize = (6, 3) , dpi = 200以上组合方式的不同之处在哪里？差异在图形中线条、文字的粗细不同。figure中大多数元素如线条、标记、文本的size的单位为points。Matplotlib设置 Points per inch (ppi) 等于72。因此无论 dpi 等于多少，一英寸只画72个点。或者说 dpi 决定线条粗细，figsize决定内容多少。","categories":[{"name":"python","slug":"python","permalink":"http://spiedeman.github.io/categories/python/"},{"name":"matplotlib","slug":"python/matplotlib","permalink":"http://spiedeman.github.io/categories/python/matplotlib/"}],"tags":[{"name":"matplotlib","slug":"matplotlib","permalink":"http://spiedeman.github.io/tags/matplotlib/"}]},{"title":"cosmology","slug":"cosmology","date":"2018-09-19T03:00:38.000Z","updated":"2019-03-17T15:09:06.000Z","comments":true,"path":"posts/3384466728/","link":"","permalink":"http://spiedeman.github.io/posts/3384466728/","excerpt":"","text":"Note波数 kkk 和波长 λ\\lambdaλ 的关系：k=2π/λk=2\\pi/\\lambdak=2π/λ角速度 ω\\omegaω 和周期 TTT 的关系：ω=2π/T=2πf\\omega=2\\pi/T=2\\pi fω=2π/T=2πf波速 ccc 和波长 λ\\lambdaλ 的关系：cT=λcT=\\lambdacT=λ波数 kkk 和角速度 ω\\omegaω 的关系：ck=ω=2πfck=\\omega=2\\pi fck=ω=2πf频率 fff 和波数 kkk 的关系：f=ck/(2π)=c/λf=ck/(2\\pi)=c/\\lambdaf=ck/(2π)=c/λ","categories":[{"name":"cosmology","slug":"cosmology","permalink":"http://spiedeman.github.io/categories/cosmology/"}],"tags":[{"name":"cosmology","slug":"cosmology","permalink":"http://spiedeman.github.io/tags/cosmology/"}]},{"title":"sed 学习笔记","slug":"bash-sed","date":"2018-09-18T07:09:07.000Z","updated":"2019-03-17T15:09:06.000Z","comments":true,"path":"posts/2825119572/","link":"","permalink":"http://spiedeman.github.io/posts/2825119572/","excerpt":"","text":"sed 简介sed 是强大的文本编辑工具。所有的操作都在模式空间进行，且每次只会将一行文本复制到其中等待 sed 命令对其操作。因此，从第二条命令开始，操作的对象都是上一条命令作用后的文本。 命令格式1sed [option] 'COMMANDS' file常用的option有123-e 表明后接 sed 命令。命令多于一条时不能省略-i 直接对文件进行操作。-f 后接包含一列 sed 命令的脚本文件。命令COMMANDS 通常格式为1'address[,address]cmd[options]' # 三部分组成：地址、命令、具体操作地址：右行号、正则表达式给出，用于指定需要操作的行。有些命令只能操作单行，有些可以操作连续多行。地址对所有的命令都是可选项，如果不指定，则作用在所有的行上。命令：有追加（a）、改变（c）、插入（i）、替换（s）等最常用。选项：格式由前面的命令决定。 替换（s）options的格式为/pattern/replacement/flags。pattern与replacement都支持正则表达式。flags选项有n：1~512的整数，表示只替换第n个匹配项。g：替换全部匹配项默认替换第一个匹配项 技巧pattern和replacement中包含Shell变量$var。如果命令用单引号括起来，那么美元符号$分别表示行尾和符号本身。只有用双引号，$var才会被替换为变量值。12345678#!/bin/bashvar=LINUXsed 's/linux/$var/' sonfile...$var... # linux 被替换为 $varvar=LINUXsed \"s/linux/$var\" somefile...LINUX... # linux 被替换为 LINUX替换命令（s）格式中的斜杠/作为定界符，可以换成任何其它符号（好像有一个例外），并且必须出现三次。通常当匹配项或替换项中出现斜杠/时会变更定界符，如#。1's#pattern#replacement#' 例子删除空白行sed -i '/^$/d' input.xxx # -i，修改源文件输出某一行到其他文件sed -n '3p' input.xxx &gt;&gt; output.xxx","categories":[{"name":"bash","slug":"bash","permalink":"http://spiedeman.github.io/categories/bash/"}],"tags":[{"name":"bash","slug":"bash","permalink":"http://spiedeman.github.io/tags/bash/"},{"name":"sed","slug":"sed","permalink":"http://spiedeman.github.io/tags/sed/"}]},{"title":"hexo 建站及使用建议","slug":"hexo-guide","date":"2018-09-17T07:03:18.000Z","updated":"2019-03-17T15:53:18.000Z","comments":true,"path":"posts/1795312736/","link":"","permalink":"http://spiedeman.github.io/posts/1795312736/","excerpt":"","text":"建站 依赖node.jsgit安装 node.js以及git12brew install nodebrew install git 安装 Hexo12# 全局安装 hexo 命令行工具npm install -g hexo-cli 新建博客根目录1234567891011hexo init /path/to/blogcd /path/to/blognpm install# 博客根目录如下：# |—— _config.yml# |—— node_modules# |—— package.json# |—— scaffolds# |—— source# | |—— _posts# |—— themes博客配置文件/path/to/blog/_config.yml通常搭配主题进行配置，只要不更换主题可以一直使用，顶多需要稍作修改。 安装主题经过一番挑选之后，个人选择使用pure主题。1git clone https://github.com/cofess/hexo-theme-pure.git themes/pure修改主题的配置文件theme/pure/_config.yml。这个文件比较重要，配置过后可以一直使用，每次主题版本更新之后最多只需稍作修改即可。 安装插件配合pure主题使用的插件有123456npm install gitment --savenpm install hexo-wordcount --savenpm install hexo-generator-json-content --savenpm install hexo-generator-feed --savenpm install hexo-generator-sitemap --savenpm install hexo-neat --savepure主题使用Katex渲染数学公式，目前最新版本号为0.10.1。为了使用Katex，需要替换默认的markdown渲染引擎为markdown-it-plus12npm un hexo-renderer-marked --savenpm install hexo-renderer-markdown-it-plus --save本地不需要安装Katex插件，但是需要修改模版中的一处地方。1234cd themes/pure/layout/_commonvim head.ejs# 定位到 katex，将版本号0.9.0修改为最新0.10.1# 保存退出推送到GitHub，需要安装插件hexo-deployer-git。1npm install hexo-deployer-git --save以上是利用Hexo建立个人静态博客的基本过程，并已将大部分操作保存在了脚本中hexo.sh。 使用建议Hexo 使用的 markdown 语法与标准的 markdown 语法有所差别。 图片当需要同时插入多张图片时，就遇到了排版问题。next主题有 gp属性 可以做到。 pure主题没有相似的命令，所以只能直接用html标记语言。居中123456&lt;div align=\"center\"&gt; &lt;!-- 分作两行的话中间会有缝隙 --&gt; &lt;!-- 由于插件 hexo-abbrlink 的使用，路径的获取最好用下面第二种方式 --&gt; &lt;img src=\"path/to/image\" [width=\"200\"] [height=\"300\"] [title]&gt; &lt;img src=\"&#123;% asset_path slug %&#125;\" [width=\"200\"] [height=\"300\"] [title]&gt;&lt;/div&gt;效果由于图片过大可能会导致无法并排放两张图片，所以需要在插入时调整尺寸。hexo中插入命令asset_img没有size选项，因此按照上例插入图片或使用标签插件。 参考资料Hexo 官方中文文档Hexo 主题文档（中文）","categories":[{"name":"hexo","slug":"hexo","permalink":"http://spiedeman.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://spiedeman.github.io/tags/hexo/"}]},{"title":"Metaclass","slug":"python-metaclass","date":"2017-12-31T16:00:00.000Z","updated":"2019-03-17T15:09:08.000Z","comments":true,"path":"posts/2704906340/","link":"","permalink":"http://spiedeman.github.io/posts/2704906340/","excerpt":"","text":"Metaclass面向对象编程语言中，元类是指实例为类的类。定义确定的类及其实例的行为。并非所有面向对象的语言都支持元类。每一种语言都拥有他自己的元对象原型，为一系列描述对象、类、元类之间如何相互作用的规则。 Python example在Python里，内置的类type是一个元类。考虑这样一个简单的Python类：1234567891011class Car(object): def __init__(self, make, model, year, color): self.make = make self.model = model self.year = year self.color = color @property def description(self): \"\"\" Return a description of this car. \"\"\" return \"%s %s %s %s\" % (self.color, self.year, self.make, self.model)在程序运行时，Car本身是类type的一个实例，类Car的源代码如上所示，有很多内容没有直接呈现出来，例如Car对象的大小、在内存中的二进制布局、它们是如何被分配内存的、每当一个Car实例被创建时初始化__init__方法会被自动调用等等。这些细节不仅在一个新的Car实例被创建时，还会在每次访问car的属性时起作用。没有元类的语言，这些细节是被语言本身所确定的，且无法被重载。在Python中，元类type控制了这些细节是实现的方式。具体的控制方式可以用另一个元类代替type来改变。12345678910111213class AttributeInitType(type): def __call__(self, *args, **kwargs): \"\"\" Create a new instance. \"\"\" # First, create the object in the normal default way. obj = type.__call__(self, *args) # Additionally, set attributes on the new object. for name, value in kwargs.items(): setattr(obj, name, value) # Return the new object. return obj这个元类只重载了类的创建方式，类的其他方面及对象的行为仍然由type进行处理。现在类Car可以使用新定义的元类重写。在Python2中通过在类定义中赋值给__metaclass__来实现：1234567class Car(object): __metaclass__ = AttributeInitType @property def description(self): \"\"\" Return a description of this car. \"\"\" return \" \".join(str(getattr(self, attr, \"Unknown\")) for attr in self.__dict__)在Python3中需要提供一个命名参数：12345class Car(object, mateclass=AttributeInitType): @property def description(self): \"\"\" Return a description of this car. \"\"\" return \" \".join(str(value) for value in self.__dict__.values())Car的实例于是可以像下面这样实例化：12new_car = Car(make='Toyota', model='Prius', year=2005, color='Green')old_car = Car(make='Ford', model='Prefect', year=1979)关键字参数实例化的效果也可以不用元类实现：1234567class Car(object): def __init__(self, **kwargs): for name, value in kwargs.items(): setattr(self, name, value) @property def description(self): return \" \".join(str(value) for value in self.__dict__.values())","categories":[{"name":"Python","slug":"Python","permalink":"http://spiedeman.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://spiedeman.github.io/tags/python/"}]},{"title":"The second article","slug":"article2","date":"2017-12-12T16:00:00.000Z","updated":"2019-03-17T15:09:06.000Z","comments":true,"path":"posts/386283100/","link":"","permalink":"http://spiedeman.github.io/posts/386283100/","excerpt":"","text":"intra-site link examples/posts/386283100/buffon_needle.gif Math Formulaeiπ=1e^{i\\pi}=1eiπ=1Here is the Buffon’s Needle experiment for calculating π\\piπ.","categories":[{"name":"article","slug":"article","permalink":"http://spiedeman.github.io/categories/article/"}],"tags":[]},{"title":"bash-tips","slug":"bash-tips","date":"2017-06-09T06:54:21.000Z","updated":"2019-03-17T15:09:06.000Z","comments":true,"path":"posts/3452120969/","link":"","permalink":"http://spiedeman.github.io/posts/3452120969/","excerpt":"","text":"持续更新 bash 小技巧检测程序是否已安装123456789101112131415#!/bin/bashcheck_software()&#123; local software=(\"vim\" \"git\" \"tmux\" \"npm\") # 待测程序名 for soft in $&#123;software[@]&#125; do type $soft 2&gt;&amp;1 &gt; /dev/null # 已安装，则返回零 if [ $? -ne 0 ]; then echo \"ERROR: **$soft** is not installed!\" exit 1 fi echo \"Checking $soft...ok!\" done&#125;check_software123456运行结果bash check_software.shChecking vim...ok!Checking git...ok!Checking tmux...ok!Checking npm...ok!","categories":[{"name":"bash","slug":"bash","permalink":"http://spiedeman.github.io/categories/bash/"}],"tags":[{"name":"bash","slug":"bash","permalink":"http://spiedeman.github.io/tags/bash/"}]}]}