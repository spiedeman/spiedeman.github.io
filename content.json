{"meta":{"title":"陋室","subtitle":"Colin McGuire'Blog","description":"山不在高，有仙则灵；水不在深，有我则灵","author":"Colin McGuire","url":"http://spiedeman.github.io","root":"/"},"pages":[{"title":"关于","date":"2021-09-18T02:10:59.622Z","updated":"2021-09-18T02:10:59.622Z","comments":false,"path":"about/index.html","permalink":"http://spiedeman.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2021-09-18T02:10:59.622Z","updated":"2021-09-18T02:10:59.622Z","comments":false,"path":"books/index.html","permalink":"http://spiedeman.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-09-18T02:10:59.622Z","updated":"2021-09-18T02:10:59.622Z","comments":false,"path":"categories/index.html","permalink":"http://spiedeman.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-09-18T02:10:59.622Z","updated":"2021-09-18T02:10:59.622Z","comments":true,"path":"links/index.html","permalink":"http://spiedeman.github.io/links/index.html","excerpt":"","text":""},{"title":"GitHub 项目","date":"2021-09-18T02:10:59.622Z","updated":"2021-09-18T02:10:59.622Z","comments":false,"path":"repository/index.html","permalink":"http://spiedeman.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-09-18T13:52:13.601Z","updated":"2021-09-18T13:52:13.601Z","comments":false,"path":"tags/index.html","permalink":"http://spiedeman.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2021-09-18T02:10:59.612Z","updated":"2021-09-18T02:10:59.612Z","comments":true,"path":"posts/1243066710/","link":"","permalink":"http://spiedeman.github.io/posts/1243066710/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new \"My New Post\"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment","categories":[],"tags":[]},{"title":"在Ubuntu中使用Citrix Workspace App办公","slug":"citrix-workspace-first-use","date":"2020-10-24T03:04:17.000Z","updated":"2021-09-18T02:10:59.602Z","comments":true,"path":"posts/c80075c3/","link":"","permalink":"http://spiedeman.github.io/posts/c80075c3/","excerpt":"","text":"远程办公在家里办公需要下载Citrix Reciver远程连接公司服务器。Google之后发现在Linux平台上， Citrix Workspace APP已经取代前者并提供兼容性支持，因此将选择它进行安装。安装使用下载安装包在最新版本所在 页面 根据Linux发行版找到相应的安装包并下载。遇到的问题安装完成后，启动程序并填入服务器地址进行连接，发现缺少SSL证书导致连接失败。 网上搜索之后找到解决办法，如下1234# 将证书软链接至相应目录sudo ln -s /usr/share/ca-certificates/mozilla/GlobalSign_Root_CA.crt /opt/Citrix/ICAClient/keystore/cacerts/# 更新证书记录sudo c_rehash /opt/Citrix/ICAClient/keystore/cacerts由于本人所用笔记本屏幕分辨率较高2560x1600，打开远程桌面后，字体很小，眼睛累。公司用的服务器系统是window server 2008， 调整字体大小为150%之后，基本解决问题。不过这只是治标，治本得等Linux客户端程序提供功能改进了。使用体验暂时OK，仍然不用切换到Windows办公，就这样！","categories":[{"name":"工作","slug":"工作","permalink":"http://spiedeman.github.io/categories/工作/"}],"tags":[{"name":"远程办公","slug":"远程办公","permalink":"http://spiedeman.github.io/tags/远程办公/"}]},{"title":"Mukhanov-Sasaki 方程","slug":"physics-mukhanov-sasaki-equation","date":"2020-06-18T11:28:55.000Z","updated":"2021-09-18T02:10:59.612Z","comments":true,"path":"posts/579653d0/","link":"","permalink":"http://spiedeman.github.io/posts/579653d0/","excerpt":"","text":"标量扰动记录一下宇宙学中规范扰动理论中的Mukhanov-Sasaki(MS)方程。\\[ \\begin{equation} \\label{eq:ms-equation} u^{\\pprime}-c_s^2\\Delta u - \\frac{\\theta^{\\pprime}}{\\theta}u = 0. \\end{equation} \\]以标量扰动以及完美流体为例，验证MS方程\\(\\eqref{eq:ms-equation}\\)。为了叙述方便，以下将规范扰动简称为扰动，在物理量上添加横线代表相对应的规范不变量，若不至于产生误解，则省略横线。完美流体的能动张量为 \\[ \\begin{equation} \\label{eq:perfect-fluid-energy-mommentum-tensor} T^{\\alpha}_{\\ \\beta} = (\\varepsilon + p) u^{\\alpha}u_{\\beta}-p\\delta^{\\alpha}_{\\ \\beta}. \\end{equation} \\] 相应的一阶扰动为 \\[ \\begin{equation} \\label{eq:guage-invariant-perturbation-for-perfect-fluid} \\overline{\\delta T}^{0}_0 = \\overline{\\delta\\varepsilon},\\quad \\overline{\\delta T}^{0}_i = \\frac{1}{a}(\\varepsilon_0+p_0)(\\overline{\\delta u}_{\\parallel i}+\\overline{\\delta u}_{\\bot i}), \\quad \\overline{\\delta T}^i_j = -\\overline{\\delta p}\\delta^i_j. \\end{equation} \\] 其中\\(\\overline{\\delta\\varepsilon},\\overline{\\delta u}_{\\parallel i},\\overline{\\delta p}\\)对应标量扰动，而\\(\\overline{\\delta u}_{\\bot i}\\)有旋无源，贡献为矢量扰动。因为\\(\\delta T^i_{\\ j}=0\\)，当\\(i\\ne j\\)。因而\\((ij)\\)分量对应的标量扰动方程约化为 \\[ \\begin{equation} (\\Phi-\\Psi)_{,ij} = 0 \\qquad (i\\ne j). \\end{equation} \\] 因而有\\(\\Phi = \\Psi\\)。故而标量扰动满足的规范方程组的形式具体如下 \\[ \\begin{align} \\Delta \\Phi - 3\\mathcal{H}(\\Phi^{\\prime}+\\mathcal{H}\\Phi) =4\\pi Ga^2\\overline{\\delta\\varepsilon}, \\label{eq:scalar-guage-invariant-perturbation-equations-00} \\\\ (a\\Phi)_{,}^{\\prime}=4\\pi Ga^2(\\varepsilon_0+p_0)\\overline{\\delta u}_{\\parallel i}, \\label{eq:scalar-guage-invariant-perturbation-equations-0i} \\\\ \\Phi^{\\pprime}+3\\mathcal{H}\\Phi^{\\prime}+(2\\mathcal{H^\\prime+H^2}\\Phi) = 4\\pi Ga^2\\overline{\\delta p}. \\label{eq:scalar-guage-invariant-perturbation-equations-ij} \\end{align} \\] 根据热力学可知压强为内能和熵的函数，\\(p=p(\\varepsilon, S)\\)。压强的涨落\\(\\overline{\\delta p}\\)可以表示为 \\[ \\begin{equation} \\label{eq:sound-speed} \\overline{\\delta p}=c_s^2\\overline{\\delta\\varepsilon}+\\tau\\delta S. \\end{equation} \\] 这里只考虑绝热扰动（\\(\\delta S=0\\)），故\\(\\overline{\\delta p}=c_s^2\\overline{\\delta\\varepsilon}\\)。 联合方程\\(\\eqref{eq:scalar-guage-invariant-perturbation-equations-00}\\)和\\(\\eqref{eq:scalar-guage-invariant-perturbation-equations-ij}\\) 得到引力势\\(\\Phi\\)满足的动力学方程 \\[ \\begin{equation} \\label{eq:bardeen-equation} \\Phi^{\\pprime}+3(1+c_s^2)\\mathcal{H}\\Phi^{\\prime}-c_s^2\\Delta\\Phi+\\lrp{2\\mathcal{H^\\prime}+(1+3 c_s^2)\\mathcal{H^2}}\\Phi = 0 \\end{equation} \\] 方程\\(\\eqref{eq:bardeen-equation}\\)称为bardeen方程，这个方程并不总是存在解析解。 不过有可能得到长波极限和短波极限下的渐进解。这可以通过引入新变量，改写方程形式消灭其中的摩擦项做到。\\[ \\begin{equation} \\begin{aligned} u&amp;\\equiv \\exp\\lrp{\\frac{3}{2}\\int (1+c_s^2)\\mathcal{H}d\\eta}\\Phi \\\\ &amp;=\\exp\\lrp{-\\frac{1}{2}\\int \\lrp{1+\\frac{p_0^{\\prime}}{\\varepsilon_0^{\\prime}}} \\frac{\\varepsilon_0^{\\prime}}{\\varepsilon_0+p_0}d\\eta}\\Phi \\\\ &amp;=\\frac{\\Phi}{(\\varepsilon_0+p_0)^{1/2}}. \\end{aligned} \\end{equation} \\] 其中用到了\\(c_s^2=p_0^{\\prime}/\\varepsilon_0^{\\prime}\\)，连续性方程 \\(\\varepsilon_0^{\\prime}=-3\\mathcal{H}(\\varepsilon_0+p_0)\\) 。以及 \\[ \\begin{equation} \\theta\\equiv \\frac{1}{a}\\lrp{1+\\frac{p_0}{\\varepsilon_0}}^{-1/2} =\\frac{1}{a}\\lrp{\\frac{2}{3}\\lrp{1-\\frac{\\mathcal{H^{\\prime}}}{\\mathcal{H^2}}}}^{-1/2}. \\end{equation} \\] 其中用到了背景方程 \\[ \\begin{equation} \\label{eq:background-equation} \\mathcal{H^2}=\\frac{8\\pi G}{3}a^2\\varepsilon_0,\\quad \\mathcal{H^2-H^\\prime}=4\\pi Ga^2(\\varepsilon_0+p_0). \\end{equation} \\] 经过复杂的计算，bardeen方程\\(\\eqref{eq:bardeen-equation}\\)可以重写为不含摩擦项的MS方程 \\[ \\begin{equation} u^{\\pprime}-c_s^2\\Delta u-\\frac{\\theta^{\\pprime}}{\\theta} u = 0. \\end{equation} \\]接下来，只进行验证MS方程和bardeen方程\\(\\eqref{eq:bardeen-equation}\\)等价。首先注意到 \\[ \\begin{equation} \\begin{aligned} u^{\\pprime}-\\frac{\\theta^{\\pprime}}{\\theta}u &amp;= \\lrp{\\frac{u}{\\theta}}^{\\pprime}\\theta+2\\lrp{\\frac{u}{\\theta}}^{\\prime}\\theta^{\\prime} \\\\ &amp;=\\lrp{\\lrp{\\frac{u}{\\theta}}^{\\prime}\\theta}^{\\prime} + \\lrp{\\frac{u}{\\theta}}^{\\prime}\\theta^{\\prime} \\\\ &amp;= v^{\\prime} + v\\frac{\\theta^{\\prime}}{\\theta}. \\quad \\text{令}(v=\\lrp{\\frac{u}{\\theta}}^{\\prime}\\theta). \\end{aligned} \\end{equation} \\] 故MS方程等价于 \\[ \\begin{equation} c_s^2\\Delta u=v^{\\prime}+v\\frac{\\theta^{\\prime}}{\\theta}. \\end{equation} \\] \\(v\\)和\\(v^{\\prime}\\)的表达式分别为 \\[ \\begin{equation} \\begin{aligned} &amp;\\begin{aligned} v\\equiv \\lrp{\\frac{u}{\\theta}}^{\\prime}\\theta &amp;= \\frac{1}{\\lrp{\\varepsilon_0+p_0}^{1/2}}\\lrp{\\Phi^{\\prime}+\\Phi\\lrp{\\mathcal{H}-\\frac{1}{2}\\frac{\\varepsilon_0^{\\prime}}{\\varepsilon_0}}} \\\\ &amp;= \\frac{1}{\\lrp{\\varepsilon_0+p_0}^{1/2}} f. \\end{aligned} \\\\ &amp;\\begin{aligned} v^{\\prime}=\\frac{1}{\\lrp{\\varepsilon_0+p_0}^{1/2}}\\lrp{f^{\\prime}-\\frac{1}{2} f\\frac{\\lrp{\\varepsilon_0+p_0}^{\\prime}}{\\varepsilon_0+p_0}}. \\end{aligned} \\end{aligned} \\end{equation} \\]故MS方程等价于 \\[ \\begin{equation} c_s^2\\Delta u = \\frac{1}{\\lrp{\\varepsilon_0+p_0}^{1/2}}\\lrp{f^{\\prime} +f\\lrp{\\frac{\\theta^{\\prime}}{\\theta}-\\frac{1}{2} \\frac{\\lrp{\\varepsilon_0+p_0}^{\\prime}}{\\varepsilon_0+p_0}}}. \\end{equation} \\] 为了后续计算方便，先计算几个表达式 \\[ \\begin{align} &amp;\\frac{\\theta^{\\prime}}{\\theta} = \\frac{\\mathcal{H}}{2}(1+3 c_s^2)+\\frac{1}{2}\\frac{\\varepsilon_0^{\\prime}}{\\varepsilon_0}, \\\\ &amp;\\frac{\\lrp{\\varepsilon_0^{\\prime}}}{\\varepsilon_0+p_0} =\\frac{\\lrp{1+\\frac{p_0^{\\prime}}{\\varepsilon_0^{\\prime}}}\\varepsilon_0^{\\prime}}{\\varepsilon_0+p_0} =-3\\mathcal{H}(1+c_s^2), \\\\ &amp;\\frac{\\varepsilon_0^{\\prime}}{\\varepsilon_0} =-3\\mathcal{H}\\lrp{1+\\frac{p_0}{\\varepsilon_0}} =-2\\mathcal{H}\\lrp{1-\\frac{\\mathcal{H}^{\\prime}}{\\mathcal{H}^2}}, \\\\ &amp;\\lrp{\\frac{\\varepsilon_0^{\\prime}}{\\varepsilon_0}}^{\\prime} =\\frac{\\varepsilon_0^{\\prime}}{\\varepsilon_0} \\lrp{\\mathcal{\\frac{H^{\\prime}}{H}}-3\\mathcal{H}(1+c_s^2)- \\frac{\\varepsilon_0^{\\prime}}{\\varepsilon_0}}. \\end{align} \\]故MS方程等价于 \\[ \\begin{equation} \\begin{aligned} c_s^2\\Delta\\Phi &amp;= f^{\\prime} + f\\lrp{\\frac{\\theta^{\\prime}}{\\theta}-\\frac{1}{2} \\frac{\\lrp{\\varepsilon_0+p_0}^{\\prime}}{\\varepsilon_0+p_0}} \\\\ &amp;= \\Phi^{\\pprime}+\\Phi^{\\prime}\\lrp{\\mathcal{H}-\\frac{1}{2}\\frac{\\varepsilon_0^{\\prime}}{\\varepsilon_0}} +\\Phi\\lrp{\\mathcal{H}-\\frac{1}{2}\\frac{\\varepsilon_0^{\\prime}}{\\varepsilon_0}}^{\\prime} \\\\ &amp;\\ +\\lrp{\\Phi^{\\prime}+\\Phi\\lrp{\\mathcal{H}-\\frac{1}{2}\\frac{\\varepsilon_0^{\\prime}}{\\varepsilon_0}}} \\lrp{\\mathcal{H}\\lrp{2+3 c_s^2}+\\frac{1}{2}\\frac{\\varepsilon_0^{\\prime}}{\\varepsilon_0}} \\\\ &amp;=\\Phi^{\\pprime} + 3\\mathcal{H}(1+3 c_s^2)\\Phi^{\\prime} \\\\ &amp;\\ +\\Phi\\lrp{\\mathcal{H^{\\prime}}-\\lrp{\\frac{1}{2} \\frac{\\varepsilon_0^{\\prime}}{\\varepsilon_0}}^{\\prime} +\\lrp{\\mathcal{H}-\\frac{1}{2}\\frac{\\varepsilon_0^{\\prime}}{\\varepsilon_0}} \\lrp{\\mathcal{H}\\lrp{2+3 c_s^2}+\\frac{1}{2}\\frac{\\varepsilon_0^{\\prime}}{\\varepsilon_0}}}, \\end{aligned} \\end{equation} \\]经过简单但复杂的计算，上式最后一行中的括号为 \\[ \\begin{equation} 2\\mathcal{H^{\\prime}}+\\mathcal{H^2}\\lrp{1+3 c_s^2}, \\end{equation} \\] 故MS方程确实等价于bardeen方程。显然MS方程是规范不变方程，引入的变量 \\(u\\)和\\(\\theta\\)均为规范不变量。曲率扰动MS方程能够被写成更紧凑的形式 \\[ \\begin{equation} \\lrb{\\lrp{\\frac{u}{\\theta}}^{\\prime}\\theta^2}^{\\prime} = c_s^2\\theta\\Delta u \\end{equation} \\] 在长波极限下，散度项\\(\\Delta u\\)可以被忽略，故而我们找到了一个在超视界区域为常数的规范不变量 \\[ \\begin{equation} \\label{eq:curvature-perturbation} \\begin{aligned} \\zeta &amp;\\equiv \\frac{2}{3}\\lrp{\\frac{u}{\\theta}}^{\\prime}\\theta^2 \\\\ &amp;= \\frac{v}{z} \\end{aligned} \\end{equation} \\] 其中 \\[ \\begin{equation} v=\\lrp{\\frac{u}{\\theta}}^{\\prime}\\theta,\\quad z = \\frac{1}{\\theta}. \\end{equation} \\] 该变量即是文献中常见的标量曲率扰动\\(\\mathcal{R}\\)，通常在暴胀过程中会计算\\(\\mathcal{R}\\)的功率谱\\(P_{\\mathcal{R}}(k)\\)。前面验证MS方程的过程中从数学的角度看，构造出的四个规范不变量\\(u,v,\\theta,z\\) 满足了如下两个方程 \\[ \\begin{equation} \\label{eq:middle-equations} c_s^2\\Delta u=z\\lrp{\\frac{v}{z}}^{\\prime},\\quad v=\\theta\\lrp{\\frac{u}{\\theta}}^{\\prime}. \\end{equation} \\] 满足上述方程的函数\\(u\\)，在消除辅助函数\\(v\\)后自然得到MS方程。观察\\(\\zeta\\)的定义 式\\(\\eqref{eq:curvature-perturbation}\\)后，更希望找到\\(v\\)满足的方程。从方程组\\(\\eqref{eq:middle-equations}\\)出发可以得到 \\[ \\begin{equation} v^{\\pprime}-c_s^2\\Delta v-\\frac{z^{\\pprime}}{z}v= 0 \\end{equation} \\] 巧合地是\\(u\\)和\\(v\\)满足的方程形式相同。实际上\\(v\\)满足的方程才是文献中提到的MS方程，\\(u\\)满足的方程只是形式相同，本质还是bardeen方程。 在暴胀过程中，根据规范不变量的定义 \\[ \\begin{equation} z=\\frac{a\\lrp{\\varepsilon+p}^{1/2}}{H}=\\frac{a\\dot{\\varphi}}{H} =\\frac{a\\varphi^{\\prime}}{\\mathcal{H}}. \\end{equation} \\] 其中\\(\\varphi\\)是暴胀场。到这一步时，曲率扰动的功率谱就就呼之欲出了 \\[ \\begin{equation} \\label{eq:curvature-perturbation-power-spectrum} P_{\\zeta}(k)=P_{\\mathcal{R}}(k) = \\frac{k^{3}}{2\\pi^2} \\left\\lvert \\frac{v_k}{z}\\right\\rvert ^2 \\end{equation} \\] 暴胀过程中，变换到傅立叶空间中，\\(v\\)的\\(k\\)模\\(v_k\\)满足贝塞尔方程 \\[ \\begin{equation} \\label{eq:bessel-equation} v_k^{\\pprime}+\\lrp{k^2-\\frac{\\nu^2-1/4}{\\eta^2}}v_k = 0, \\end{equation} \\] 式中\\(\\nu=3/2+2\\varepsilon_H-\\eta_H\\)。考虑到平面波边值条件 \\[ \\begin{equation} \\label{eq:plane-wave-boundary-condition} v_k(\\eta)\\rightarrow \\frac{1}{2k}e^{-ik\\eta},\\quad k\\rightarrow \\infty \\end{equation} \\] 贝塞尔方程\\(\\eqref{eq:bessel-equation}\\)的解为 \\[ \\begin{equation} \\label{eq:solution-for-ms-equation-in-inflation} v_k(\\eta) =\\frac{\\sqrt{\\pi}}{2}e^{i(\\nu+1/2)\\pi/2}\\sqrt{-\\eta}H_{\\nu}^{(1)}(-k\\eta). \\end{equation} \\] 式中\\(H_{\\nu}^{(1)}\\)为第一类汉克尔函数。对于超视界扰动 \\[ \\begin{align} \\label{eq:for-super-horizon} H_{\\nu}^{(1)}(x\\ll 1) \\sim \\sqrt{\\frac{2}{\\pi}}e^{-i\\pi/2} 2^{\\nu-3/2}\\frac{\\Gamma(\\nu)}{\\Gamma(3/2)}x^{-\\nu}, \\\\ v_k(\\eta) = e^{i(\\nu-1/2)\\pi/2}2^{\\nu-3/2} \\frac{\\Gamma(\\nu)}{\\Gamma(3/2)}\\frac{1}{\\sqrt{2k}}(-k\\eta)^{1/2-\\nu}. \\end{align} \\] 故曲率扰动的功率谱为 \\[ \\begin{equation} \\begin{aligned} P_{\\mathcal{R}}(k) &amp;= \\frac{k^{3}}{2\\pi^2}\\left\\lvert \\frac{\\nu_k}{z}\\right\\rvert ^2 \\\\ &amp;= 2^{2\\nu-3}\\lrp{\\frac{\\Gamma(\\nu)}{\\Gamma(3/2)}}^2 \\lrp{\\frac{H}{\\dot{\\varphi}_0}}^2 \\lrp{\\frac{H}{2\\pi}}^2 \\lrp{\\frac{k}{aH}}^{3-2\\nu} \\Bigg\\lvert_{k=aH}. \\end{aligned} \\end{equation} \\]","categories":[{"name":"物理","slug":"物理","permalink":"http://spiedeman.github.io/categories/物理/"}],"tags":[{"name":"Cosmology","slug":"Cosmology","permalink":"http://spiedeman.github.io/tags/Cosmology/"},{"name":"Physics","slug":"Physics","permalink":"http://spiedeman.github.io/tags/Physics/"}]},{"title":"逆拉普拉斯算符","slug":"physics-inverse-laplacian-operator","date":"2020-06-07T02:48:49.000Z","updated":"2021-09-18T02:10:59.612Z","comments":true,"path":"posts/f03e62a1/","link":"","permalink":"http://spiedeman.github.io/posts/f03e62a1/","excerpt":"","text":"泊松方程及其解拉普拉斯算符\\(\\Delta\\)是\\(n\\)维欧几里得空间中的一个二阶微分算符，定义为标量函数\\(f\\)的梯度的散度。 \\[ \\begin{equation} \\label{eq:poisson-equation} \\Delta \\varphi = \\nabla^2 \\varphi = \\nabla\\cdot\\nabla \\varphi = f \\end{equation} \\] 物理中通常称为泊松方程，一般利用格林函数法求解。拉普拉斯算符对应的格林函数满足方程 \\[ \\begin{equation} \\label{eq:green-function-for-laplacian-operator} \\nabla^2 G(\\bm{r},\\bm{r^\\prime}) = \\delta(\\bm{r}-\\bm{r}^\\prime) \\end{equation} \\] 方程\\(\\eqref{eq:green-function-for-laplacian-operator}\\)的解为 \\[ \\begin{equation} G(\\bm{r},\\bm{r^\\prime}) = - \\frac{1}{4\\pi} \\frac{1}{\\Abs{\\bm{r}-\\bm{r^\\prime}}} \\end{equation} \\] 因此泊松方程的特解为 \\[ \\begin{equation} \\label{eq:particular-solution-for-poisson-equation} \\begin{aligned} \\varphi_p(\\bm{r}) &amp;= \\int G(\\bm{r},\\bm{r^\\prime})f(\\bm{r^\\prime})d^3\\bm{r^\\prime} \\\\ &amp;=-\\frac{1}{4\\pi}\\int \\frac{f(\\bm{r^\\prime})}{\\Abs{\\bm{r}-\\bm{r^\\prime}}}d^3\\bm{r^\\prime} \\end{aligned} \\end{equation} \\]若源项\\(f(\\bm{r})\\)在全空间积分为有限值，则 \\[ \\begin{equation} \\begin{aligned} \\lim_{r\\to\\infty}\\varphi_p(\\bm{r})&amp;=-\\frac{1}{4\\pi}\\lim_{r\\to\\infty} \\int\\frac{f(\\bm{r})}{\\Abs{\\bm{r-r^\\prime}}} d^3\\bm{r^\\prime} \\\\ &amp;=-\\frac{1}{4\\pi} \\left(\\lim_{r\\to\\infty}\\frac{1}{r}\\int f(\\bm{r^\\prime})d^3\\bm{r^\\prime} + \\bigo\\lrp{\\frac{1}{r^2}} \\right) \\\\ &amp;=-\\frac{1}{4\\pi} \\lrp{\\lim_{r\\to\\infty}\\frac{q}{r}+\\bigo\\lrp{\\frac{1}{r^2}}} \\\\ &amp;=0 \\end{aligned} \\end{equation} \\] 因此精确的表述为，当泊松方程\\(\\eqref{eq:poisson-equation}\\)的边界条件为：\\(\\varphi(\\bm{r})\\)在无穷远处为零时，解为\\(\\varphi_p(\\bm{r})\\)。当指定非零边界条件时，完整的解为 \\[ \\begin{equation} \\varphi(\\bm{r}) =\\varphi_p(\\bm{r})+\\varphi_c(\\bm{r}) \\end{equation} \\] 其中\\(\\varphi_c(\\bm{r})\\)为任意拉普拉斯方程（无源泊松方程）的解 \\[ \\begin{equation} \\label{eq:solution-for-boundary-laplace-equation} \\nabla^2\\varphi_c(\\bm{r}) = 0 \\end{equation} \\]逆拉普拉斯算符当源项\\(f(\\bm{r})\\)在全空间积分收敛，即选取无穷远处为零的边界条件时，泊松方程的解为 \\[ \\begin{equation} \\varphi(\\bm{r})=\\varphi_p(\\bm{r}) \\end{equation} \\] 在上述前提条件下，定义逆拉普拉斯算符为\\(\\Delta^{-1}\\)，将其作用于泊松方程\\(\\eqref{eq:poisson-equation}\\)得到 \\[ \\begin{equation} \\Delta^{-1}\\Delta\\varphi(\\bm{r})\\equiv \\varphi(\\bm{r}) = \\Delta^{-1}f(\\bm{r}) \\end{equation} \\] 根据\\(\\eqref{eq:particular-solution-for-poisson-equation}\\)可得 \\[ \\begin{equation} \\boxed{ \\Delta^{-1}f(\\bm{r}) =-\\frac{1}{4\\pi}\\int\\frac{f(\\bm{r^\\prime})}{\\Abs{\\bm{r-r^\\prime}}}d^3\\bm{r^\\prime}} \\end{equation} \\] 容易验证 \\[ \\begin{equation} \\Delta^{-1}\\Delta f(\\bm{r})=\\Delta\\Delta^{-1}f(\\bm{r})=f(\\bm{r}) \\end{equation} \\]应用利用逆拉普拉斯算符\\(\\Delta^{-1}\\)，可以将矢量场\\(\\bm{V}(\\bm{r})\\)唯一分解为不相交的两部分 \\[ \\begin{equation} \\bm{V}=\\bm{V}_{\\parallel} + \\bm{V}_{\\bot},\\qquad \\text{其中}\\ \\nabla\\cdot \\bm{V}_{\\bot}=\\nabla\\times \\bm{V}_{\\parallel}=0 \\end{equation} \\] 直接构造 \\[ \\begin{equation} \\label{eq:longitudinal} \\bm{V}_{\\parallel}=\\nabla\\Delta^{-1}\\nabla\\cdot \\bm{V} \\end{equation} \\] 观察到\\(\\psi\\equiv\\Delta^{-1}\\nabla\\cdot \\bm{V}\\)是一个标量场，因此\\(\\bm{V}\\times \\bm{V}_{\\parallel}=\\bm{V}\\times\\nabla\\psi=0\\)。横向部分为 \\[ \\begin{equation} \\bm{V}_{\\bot}=\\bm{V}-\\bm{V}_{\\parallel}=\\bm{V}-\\nabla\\Delta^{-1}\\nabla\\cdot \\bm{V} \\end{equation} \\] 可以验证 \\[ \\begin{equation} \\nabla\\cdot \\bm{V}_{\\bot}=\\nabla\\cdot\\lrb{\\bm{V}-\\nabla\\Delta^{-1}\\nabla\\cdot \\bm{V}} =\\nabla\\cdot \\bm{V}-\\Delta\\Delta^{-1}\\lrp{\\nabla\\cdot \\bm{V}} =\\nabla\\cdot \\bm{V}-\\nabla\\cdot \\bm{V}=0 \\end{equation} \\] 与\\(\\bm{V}_{\\parallel}\\)一样，\\(\\bm{V}_{\\bot}\\)也存在类似的表达式 \\[ \\begin{equation} \\label{eq:transverse} \\bm{V}_{\\bot}=-\\nabla\\times\\Delta^{-1}\\lrp{\\nabla\\times \\bm{V}} \\end{equation} \\] 为了证明\\(\\eqref{eq:transverse}\\)成立，首先引入两个等式，不过省略证明。 \\[ \\begin{aligned} &amp;\\nabla\\times\\Delta^{-1}\\lrp{\\bm{A}}=\\Delta^{-1}\\lrp{\\nabla\\times \\bm{A}}\\\\ &amp;\\nabla\\Delta^{-1}\\lrp{\\psi}=\\Delta^{-1}\\lrp{\\nabla\\psi} \\end{aligned} \\] 于是 \\[ \\begin{aligned} \\bm{V}_{\\bot}&amp;=-\\nabla\\times\\Delta^{-1}\\lrp{\\nabla\\times\\bm{V}}\\\\ &amp;=-\\Delta^{-1}\\lrb{\\nabla\\times\\lrp{\\nabla\\times\\bm{V}}} \\\\ &amp;=\\Delta^{-1}\\lrb{\\Delta\\bm{V}-\\nabla\\lrp{\\nabla\\cdot\\bm{V}}}\\\\ &amp;=\\bm{V}-\\Delta^{-1}\\nabla\\lrp{\\nabla\\cdot\\bm{V}}\\\\ &amp;=\\bm{V}-\\nabla\\Delta^{-1}\\lrp{\\nabla\\cdot\\bm{V}} \\\\ &amp;=\\bm{V}-\\bm{V}_{\\parallel} \\end{aligned} \\] 以上说明了分解的存在性，接下来说明该分解具有唯一性，并且只需说明纵向部分具有唯一性即可。 对矢量\\(\\bm{V}\\)取散度，得到关于标量场\\(\\psi\\)的泊松方程 \\[ \\begin{equation} \\nabla\\cdot \\bm{V} = \\nabla\\cdot\\bm{V_{\\parallel}} = \\Delta \\psi \\end{equation} \\] 由于泊松方程具有唯一解，因而矢量分解也具有唯一性。","categories":[{"name":"物理","slug":"物理","permalink":"http://spiedeman.github.io/categories/物理/"}],"tags":[{"name":"Physics","slug":"Physics","permalink":"http://spiedeman.github.io/tags/Physics/"}]},{"title":"Linux下配置触摸板手势操作","slug":"i3wm-touchpad-tips","date":"2020-05-13T10:42:26.000Z","updated":"2021-09-18T02:10:59.612Z","comments":true,"path":"posts/35c03362/","link":"","permalink":"http://spiedeman.github.io/posts/35c03362/","excerpt":"","text":"MacOS的触摸板手势体验没得说，在Linux下也可以借助一些软件达到相近的体验。不过最想要的三指取词还不知到如何实现😠。首先配置触摸板的驱动程序为libinput，具体操作这里不谈。借助软件libinput-gestures可以拓展触摸板三/四指手势以及缩放操作。i3桌面下，窗口有两种：平铺以及浮动。工作区的概念类比MacOS中的虚拟桌面，便签区的效果类似窗口最小化。功能表updownleftright三指切换到上方窗口切换到下方窗口切换到左侧窗口切换到右侧窗口四指将浮动窗口移到便签区循环切换便签区内的窗口切换到左侧工作区切换到右侧工作区如果当前获得焦点的窗口是浏览器，则三指的手势功能为updownleftright三指前进后退切换到左侧tab切换到右侧tab以及另外四种手势leftupleftdownrightuprightdown三指打开最近关闭标签页关闭当前标签页左移当前便签页右移当前标签页libinput-gestures 配置文件libinput-gestures的配置文件位于~/.config/libinput-gestures.conf。其中涉及到上述功能的配置为1234567891011121314151617# 三指手势gestures swipe left 3 $HOME/Program/bin/move_window_or_tabgestures swipe right 3 $HOME/Program/bin/move_window_or_tab rightgestures swipe up 3 $HOME/Program/bin/move_window_or_tab upgestures swipe down 3 $HOME/Program/bin/move_window_or_tab down# 四指手势gestures swipe left 4 i3-msg workspace prevgestures swipe right 4 i3-msg workspace nextgestures swipe up 4 $HOME/Program/bin/show_or_hide_scratchpad upgestures swipe down 4 xdotool key super+shift+minus# 浏览器窗口中三指手势gestures swipe left_up 3 $HOME/Program/bin/move_window_or_tab left_upgestures swipe left_down 3 $HOME/Program/bin/move_window_or_tab left_downgestures swipe right_up 3 $HOME/Program/bin/move_window_or_tab right_upgestures swipe right_down 3 $HOME/Program/bin/move_window_or_tab right_down实现脚本libinput-gestures能捕捉手势，但是将手势与操作绑定需要通过另一个能实现模拟按键操作的软件xdotool。 由于三指手势对应的功能较为复杂，需要区分窗口内是否为浏览器，且涉及的主要功能为切换窗口，因而统一用一个脚本move_window_or_tab实现。123456789101112131415161718192021222324#!/usr/bin/env bash# 获取窗口名称WM_NAME=\"$(xdotool getactivewindow getwindowname)\"# 获取手势方向DIRECTION=$&#123;1:-left&#125;if [[ $WM_NAME =~ 'Firefox' ]]; then if [[ $DIRECTION == 'left' ]]; then xdotool key control+Page_Up elif [[ $DIRECTION == 'right' ]]; then xdotool key control+Page_Down # ... fielse # 普通i3窗口 # Key number: H-43, J-44, K-45, L-46, ;-47 if [[ $DIRECTION == 'left' ]]; then xdotool key super+44 elif [[ $DIRECTION == 'right' ]]; then xdotool key super+47 # ... fifi四指切换工作区的命令很简单，不需要借助脚本实现。但是涉及到便签区窗口的功能无法用一行命令搞定，因此写了一个脚本show_or_hide_scratchpad。123456789101112131415161718# 获取手势方向DIRECTION=$&#123;1:-up&#125;# 核心逻辑部分if [[ $DIRECTION == 'up' ]]; then if i3-msg focus floating; then i3-msg move scratchpad fielif [[ $DIRECTION == 'down' ]]; then if i3-msg focus floating; then i3-msg move scratchpad i3-msg move scratchpad else i3-msg move scratchpad fi i3-msg [floating] resize set 1280 1200 i3-msg move position centerfi","categories":[{"name":"i3","slug":"i3","permalink":"http://spiedeman.github.io/categories/i3/"}],"tags":[{"name":"触摸板","slug":"触摸板","permalink":"http://spiedeman.github.io/tags/触摸板/"},{"name":"手势操作","slug":"手势操作","permalink":"http://spiedeman.github.io/tags/手势操作/"}]},{"title":"VPS相关配置，Trojan及V2RAY脚本","slug":"vps-config","date":"2020-05-08T05:26:19.000Z","updated":"2021-09-18T02:10:59.622Z","comments":true,"path":"posts/7a1be4a0/","link":"","permalink":"http://spiedeman.github.io/posts/7a1be4a0/","excerpt":"","text":"目前在用的科学上网工具有两款：Trojan和V2Ray。V2Ray的使用方式有很多，这里不作详细记录。Trojan的优势在于配置相对简单、采用的科学上网的方法不易被发现、速度快。V2Ray的优势在于功能齐全，搭配其他工具可以实现从简单到复杂的各种科学上网方式，缺点是某些方式速度较慢。综合两者的优缺点，我一般将两者搭配使用，Trojan负责科学上网，V2Ray负责路由功能。### 安装Trojan和V2Ray 是否在Debian/Ubuntu官方仓库中Trojan: ✔ (ubuntu从19.04开始)V2Ray: ✘V2Ray的官方安装脚本在国内下载速度很慢，经常失败。结合上面信息，应选择优先安装Trojan，然后在终端下开启科学上网模式，再安装V2Ray。安装流程全自动，一切都很Nice。12345678910111213141516171819202122232425262728293031323334353637383940function trojan_environment_varibles() &#123; TROJAN_PREFIX=/directory/to/trojan/real/config.json TROJAN_CERT=$TROJAN_PREFIX/cert.pem TROJAN_CERT_PATH_IN_CONFIG=$TROJAN_CERT TROJAN_CONFIG=$TROJAN_PREFIX/config.json # trojan模板配置文件 TROJAN_CONFIG_EXAMPLE=$TROJAN_PREFIX/config_example.json TROJAN_SERVER=$SERVER_NAME&#125;function trojan_install_for_old_distributor() &#123; # 当官方仓库中不含trojan时安装流程 # 证书 位于 /usr/local/etc/ssl/cert.pem # 配置文件 位于 /usr/local/etc/trojan/config.json # 新建trojan用户，由trojan用户开启服务&#125;function trojan_install() &#123; # 设置trojan相关环境变量 trojan_environment_varibles # 若trojan配置文件不存在，则从模板配置文件复制一份 [ ! -f $TROJAN_CONFIG ] &amp;&amp; cp $TROJAN_CONFIG_EXAMPLE $TROJAN_CONFIG if ! command -v trojan &gt; /dev/null 2&gt;&amp;1; then TROJAN_CONFIG=/path/to/模板配置文件 TROJAN_CERT=/path/to/本地证书 if 满足条件：Ubuntu及版本在19.04及以上; then sudo apt install trojan sudo ln -sf $TROJAN_CONFIG /etc/trojan/config.json else trojan_install_for_old_distributor TROJAN_CERT_PATH_IN_CONFIG=/usr/local/etc/ssl/cert.pem fi fi # 设置配置文件中的证书路径 if $TROJAN_CONFIG中不含$TROJAN_CERT_PATH_IN_CONFIG; then sed -i \"s|\\\"cert.*|\\\"cert\\\": \\\"$TROJAN_CERT_PATH_IN_CONFIG\\\",|\" $TROJAN_CONFIG fi trojan_first_start&#125;配置文件这里只讨论Trojan在本地的配置以及相关脚本。Trojan的客户端配置中有三项在切换VPS时需要修改，分别是配置选项VPSremote_addrIP/域名sni域名cert本地证书路径因为使用了CloudFlare家的泛域名证书，因此在多个VPS上可以使用同一套证书，意味着即使在配置文件中本地证书路径使用了软链接地址，也无需对其指向的证书文件做任何修改。因此在切换VPS时，真正需要修改的只有两个地方：remote_addr和sni。remote_addr选择的规则为分类DNSProxyremote_addrIP或者域名IP原因在于remote_addr必须解析到VPS自己的IP。切换VPS并重启服务的脚本根据上面的分析，采用模板配置文件的方式，选取特定的VPS后，用sed直接修改配置文件中上述两个选项的值，再用service命令重启服务。VPS信息VPS的相关信息，都存放在文件server_info.ini中，如下所示：123456789[cloudcone]ip = xxx.xxx.xxx.xxxdomain = www.example.comdns_proxy = true[racknerd]ip = xxx.xxx.xxx.xxxdomain = www.example2.comdns_proxy = false借助awk定义两个函数用于读取ini文件中的服务器信息。123456789101112131415161718192021222324252627282930313233SERVER_INFO_FILE=/path/to/server_info.ini# 收集VPS入口信息function read_section_ini() &#123; INI_FILE=$1 awk -F '=' '&#123; if ($1 ~ /\\[/) &#123; gsub(/[\\[\\]]/, \"\", $1) print $1 &#125; &#125;' $INI_FILE&#125; # 获取特定VPS的信息function read_ini() &#123; INI_FILE=$1 SECTION=$&#123;2:-cloudcone&#125; KEY=$&#123;3:-ip&#125; awk -F '=' '&#123; if ($1 ~ /\\[/) if ($1 ~ /\\['$SECTION'/) &#123; a = 1 &#125; else &#123; a = 0 &#125; else if (a == 1 &amp;&amp; $1 ~ /'$KEY'/) &#123; gsub(/[[:blank:]]/, \"\", $2) print $2 &#125; &#125;' $INI_FILE&#125;VPS_SERVERS=($(read_section_ini $SERVER_INFO_FILE))切换VPS脚本接下来就涉及到Trojan和V2Ray相关的脚本了，同样定义两个函数12345678910111213141516171819202122232425262728293031323334353637383940function choose_server_for_trojan() &#123; TROJAN_SERVER=$1 TROJAN_CONFIG=/path/to/trojan的模板配置文件 # 获取选定VPS的具体信息 dns_proxy=$(read_ini $SERVER_INFO_FILE $TROJAN_SERVER dns_proxy) ip=$(read_ini $SERVER_INFO_FILE $TROJAN_SERVER ip) sni=$(read_ini $SERVER_INFO_FILE $TROJAN_SERVER sni) if $dns_proxy; then remote_addr=$ip else remote_addr=$sni fi # 修改模板配置文件 sed -i \"s|\\\"remote_addr.*|\\\"remote_addr\\\": \\\"$remote_addr\\\",|\" $TROJAN_CONFIG sed -i \"s|\\\"sni.*|\\\"sni\\\": \\\"$sni\\\",|\" $TROJAN_CONFIG # 重启Trojan服务 sudo service trojan restart sudo service trojan status&#125;function choose_server_for_v2ray() &#123; # V2Ray相关配置修改&#125;# 核心逻辑部分function change_server() &#123; # 可用的VPS都存放在数组变量 VPS_SERVERS 中，传入的参数为数组下标， # 用于选取特定 VPS VPS_SERVERS=($(read_section_ini $SERVER_INFO_FILE)) SERVER_ID=$&#123;1:-0&#125; SERVER_NAME=$(VPS_SERVERS[$SERVER_ID]) if [ $SERVER_ID -ge 0 ] &amp;&amp; [ $SERVER_ID -lt $&#123;#VPS_SERVERS[*]&#125; ]; then choose_server_for_trojan $SERVER_NAME choose_server_for_v2ray $SERVER_NAME else echo \"错误：VPS服务器不存在\" echo \"尝试：'$COMMAND -i' 查看可用服务器\" fi&#125;都到这个程度了，干脆写成一个简单的命令行程序。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374# 除了上面提到的函数外，再定义三个函数，用于实现相应的命令参数function show_help() &#123; echo \"欢迎使用本脚本切换VPS服务器\" echo \"用法：vps_server 选项\" echo \"选项：\" echo \" -h [--help] 显示本帮助\" echo \" -s [--server=val] 通过val选择不同VPS服务器\" echo \" -i [--info] 显示可用服务器汇总信息\" echo \" -c [--current] 显示当前使用的VPS服务器\"&#125;function show_servers_info() &#123; # shellcheck disable=SC2128,2207 [ -z \"$VPS_SERVERS\" ] &amp;&amp; VPS_SERVERS=($(read_section_ini $SERVER_INFO_FILE)) echo \"可用的服务器有：\" for i in \"$&#123;!VPS_SERVERS[@]&#125;\"; do echo \" $i ): $&#123;VPS_SERVERS[i]&#125;\" done echo \"\" echo \"服务器端安装完成：\" echo \" 将证书下载至客户端所在主机并放置在正确路径\" echo \" 客户端配置文件中需指定证书（或其软链接）路径\" echo \" 若CloudFlare中开启了代理，则客户端配置文件中只能使用IP。\" echo \"\" echo \"客户端安装完成：\" echo \" 从服务器上下载证书并安装\" echo \" 配置文件中需指定证书绝对路径\" echo \" | | | remote_addr |\" echo \" | | | IP | 域名 |\" echo \" | CloudFlare | DNS | ✔ | ✔ |\" echo \" | | Proxy | ✔ | ✘ |\" echo \"\"&#125;function get_current_server() &#123; awk -F ':' '&#123; if ($1 ~ /\\\"sni/) &#123; gsub(/\\\"/, \"\", $2) print $2 &#125; &#125;' $TROJAN_PREFIX/config.json&#125;# while循环与case结构处理命令参数while [[ $# -ge 1 ]]; do case \"$1\" in -h|--help ) show_help ;; -i|--info) show_servers_info ;; -c|--current) VPS=$(get_current_server) echo \"当前VPS服务器：\" echo \" $&#123;VPS%%.*&#125;\" ;; -s|--server) shift if [[ $# -ge 1 ]]; then ID=$1 else ID=0 fi change_server $ID ;; *) echo \"错误：未识别选项 '$1'\" echo \"尝试 '$COMMAND -h|--help' 查看帮助信息\" ;; esac shiftdone","categories":[{"name":"科学上网","slug":"科学上网","permalink":"http://spiedeman.github.io/categories/科学上网/"}],"tags":[{"name":"VPS","slug":"VPS","permalink":"http://spiedeman.github.io/tags/VPS/"},{"name":"Trojan","slug":"Trojan","permalink":"http://spiedeman.github.io/tags/Trojan/"},{"name":"V2Ray","slug":"V2Ray","permalink":"http://spiedeman.github.io/tags/V2Ray/"}]},{"title":"记快手笔试大题","slug":"interview-kuaishou","date":"2019-09-16T13:57:09.000Z","updated":"2021-09-18T02:10:59.612Z","comments":true,"path":"posts/d82964a7/","link":"","permalink":"http://spiedeman.github.io/posts/d82964a7/","excerpt":"","text":"第一题题目描述输入一个英文句子，词之间有 1 个或若干个空格，句子以英文标点 &quot;.&quot; 结尾。 要求颠倒该句子中的词语顺序，并且词之间有且只有一个空格，结尾仍是 &quot;.&quot;，结尾的 &quot;.&quot; 与前一个单词之间无空格。代码123456789#coding=utf-8import sysline = sys.stdin.readline().strip().split()if line[-1] == '.': line = line[:-1]else: line[-1] = line[-1][:-1]print ' '.join(line[::-1]) + '.'第二题题目描述已知两个字符串strA和strB，求将strA转换成strB所需的最小编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。本题参考LeetCode 第72题——编辑距离代码1234567891011121314151617#coding=utf-8import sysstrA = sys.stdin.readline().strip()strB = sys.stdin.readline().strip()n1, n2 = len(strA), len(strB)dp = [[0] * (n2 + 1) for _ in range(n1 + 1)]for j in range(1, n2 + 1): dp[0][j] = dp[0][j-1] + 1for i in range(1, n1 + 1): dp[i][0] = dp[i-1][0] + 1for i in range(1, n1 + 1): for j in range(1, n2 + 1): if strA[i-1] == strB[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = 1 + min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1])print dp[-1][-1]第三题题目描述我们知道每一个大于 1 的数都一定是质数或者可以用质数的乘积来表示，如 10=2*5。现在请设计一个程序，对于给定的一个 (1, N] 之间的正整数（N 取值不超过 10 万），你需要统计 (1, N] 之间所有正整数的质数分解后，所有质数个数的总和。举例，输入数据 6，那么满足 (1, 6]) 的整数为 2, 3, 4, 5, 6，各自进行质数分解后为：2=&gt;2, 3=&gt;3, 4=&gt;2*2, 5=&gt;5, 6=&gt;2*3。对应的质数个数即 1, 1, 2, 1, 2。最后统计总数为 7。本题是完全自己做出来的，复用了求质数的筛法。 &gt; 关键点在 若 \\(n = a\\times b\\)，则 \\(f(n) = f(a)+f(b)\\)。代码123456789101112131415161718192021222324252627282930313233343536#coding=utf-8import sysdef prime_sieve(n): \"\"\"返回所有小于 n 的质数\"\"\" sieve = [True] * (n // 2) for i in range(3, int(n**0.5) + 1, 2): if sieve[i // 2]: sieve[i *i // 2::i] = [False] * ((n - i * i - 1) // (2 * i) + 1) return [2] + [2 * i + 1 for i in range(1, n // 2) if sieve[i]]n = int(sys.stdin.readline().strip())primes = prime_sieve(n + 1)data = &#123;p: 1 for p in primes&#125;def help(n): if n == 1: return 0 if n in data: return data[n] i, n0 = 0, n ans = 0 while not ans: c, p = 0, primes[i] while n % p == 0: c += 1 n = n // p if c: ans = c + help(n) i += 1 data[n0] = ans return ansans = 0for m in range(2, n + 1): ans += help(m)print ans第四题题目描述给定一个数独板的输入，确认当前的填法是否合法。 合法的输入需要满足一下三个条件： 1. 每一行的9个格子中是1-9的9个数字，且没有重复 2. 每一列的9个格子中是1-9的9个数字，且没有重复 3. 9个3*3的小格子中是1-9的9个数字，且没有重复空格用X表示本题抄自己的代码LeetCode 第36题——有效的数独 #### 代码12345678910111213141516171819202122232425262728#coding=utf-8import sysboard = []for _ in range(9): board.append(sys.stdin.readline().strip())def help(board): board_t = zip(*board) for i in range(3): for j in range(3): if i == j: for k in range(3): col = [n for n in board[3*i+k] if n!='X'] if len(col) != len(set(col)): return False row = [n for n in board_t[3*i+k] if n!='X'] if len(row) != len(set(row)): return False block = set() for k in range(3): for s in board[3*i+k][3*j:3*j+3]: if s != 'X': if s in block: return False block.add(s) return Trueprint 'true' if help(board) else 'false'","categories":[{"name":"算法","slug":"算法","permalink":"http://spiedeman.github.io/categories/算法/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://spiedeman.github.io/tags/面试/"}]},{"title":"记三七互娱笔试大题","slug":"interview-37huyu","date":"2019-09-10T07:23:29.000Z","updated":"2021-09-18T02:10:59.612Z","comments":true,"path":"posts/a8055618/","link":"","permalink":"http://spiedeman.github.io/posts/a8055618/","excerpt":"","text":"三七互娱共两道算法大题，总共就一个小时的笔试时间，总感觉时间不够用。最后一题确实因为时间不够没写完，好在思路有了用注释提了一下，不知道能不能酌情给分:joy:。第一题描述：给一个数组，其中 \\(1 \\le A[i]\\le n\\)。有些元素出现两次，有些出现一次，返回所有出现两次的元素。解答：12345678910#!/usr/bin/env python# coding=utf-8def solution(array): count = &#123;&#125; for a in array: if a not in array: count[a] = 1 else: count[a] += 1 return [key for key in count if count[key] == 2]第二题描述：小明有想设计一个随机算法来听歌，并且希望每首歌被选中的概率正比于它的豆瓣评分。如歌 A 和 B 的评分分别为 \\(8.5\\) 和 \\(9.3\\)，则这两首歌被选中的概率的比为 \\(85:93\\)。现给出 \\(1000\\) 首歌的豆瓣评分，请设计一个随机算法并实现它。解答：1234567891011121314151617181920212223#!/usr/bin/env python# coding=utf-8import randomdef solution(songs, scores): n = len(songs) # 假设评分只有一位小数 srange = [0] for i in range(n): srange.append(srange[-1] + int(scores[i] * 10)) # 生成 [0, srange[-1]] 范围的均匀随机数 rand rand = random.uniform(0, 1) rand = int(rand * srange[-1]) # 二分法查找 rand 落在 srange 的哪个区间中 i, j = 0, n m = (i + j) // 2 while i &lt; j: if srange[m] &lt;= rand &lt; srange[m+1]: return songs[m] if srange[m] &gt; rand: j = m else: i = m + 1 m = (i + j) // 2","categories":[{"name":"算法","slug":"算法","permalink":"http://spiedeman.github.io/categories/算法/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://spiedeman.github.io/tags/面试/"}]},{"title":"记小米一面算法题——人民币大写金额转换","slug":"interview-xiaomi","date":"2019-09-09T14:01:15.000Z","updated":"2021-09-18T02:10:59.612Z","comments":true,"path":"posts/8bd25443/","link":"","permalink":"http://spiedeman.github.io/posts/8bd25443/","excerpt":"","text":"30分钟小米算法工程师一面，由于没有项目经历面试官给了一道算法题，现撸代码。毫无意外，快速码代码向来不是我的强项。特此记录失败史题目描述根据人民币大写金额规范，将浮点数转换为人民币读法字符串需要注意以下几点： 1. 数字中间有连续一个或以上个 0 时，只写一个零。如 ¥ 140,090.3，应写作人民币十四万零玖拾元叁角。 2. 角位非 0 时，元后面可以不加零。如 ¥ 1690.32，可以写作人民币壹仟陆佰玖拾元叁角[零]贰分。 3. 角位是 0，分位不是 0 时，大写金额元后面应写零。如 ¥ 325.04，应写为人民币叁佰贰拾元零肆分。 4. 角和分都是 0 时，元后面应写上整或正。如 ¥ 1234.00，应写为人民币壹仟贰佰叁拾肆元（整/正）。注意：最小单位为分。题解中文数字读法以 4 个数字为一个组，辅以单位如万、亿、兆、京等。这里取到最高为亿。由于每组单位不同，一度不知如何处理。因为金额大小没有限制，所以数字位数可以很大，如果根据单位用if...else...语句，是行不通的。 后来发现，还是可以使用递归来解决问题。至于零的处理，可以设定字符串替换规则，使得处理后满足规范。代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566ch_num = ['零', '壹', '贰', '叁', '肆', '伍', '陆', '柒', '捌', '玖']ch_num = dict(zip('0123456789', ch_num))ch_unit = ['', '万', '亿']ch_unit = dict(zip(range(3), ch_unit)) def convert_int(intPart): \"\"\" 转换整数部分 intPart: str return: str \"\"\" if len(intPart) &lt;= 4: # 若长度小于 4， 则补足到 4 位。 ans = [ch_num[c] for c in '0'*(4-len(intPart))+intPart] if ans[-1] == ch_num['0']: ans = '&#123;&#125;仟&#123;&#125;佰&#123;&#125;拾'.format(*ans[:-1]) else: ans = '&#123;&#125;仟&#123;&#125;佰&#123;&#125;拾&#123;&#125;'.format(*ans) # 处理中间有 0 的情况 ans = ans.replace('零仟', ch_num['0']) ans = ans.replace('零佰', ch_num['0']) ans = ans.replace('零拾', ch_num['0']) # 处理中间连续多个 0，末尾有零的情况 ans = re.sub('零+', ch_num['0'], ans) ans = re.sub('零+$', ch_unit[0], ans) # 若开头有 0 且整数部分长度小于 4，则丢弃开头的’零‘（只有 1 个）。 return ans[4!=len(intPart):] else: # 金额数字长度可以写成 n = 4 * u + r u, r = len(intPart) // 4, len(intPart) % 4 # 若 r = 0，则 u = u - 1，至少先处理开头 4 位。之后再看 u， # 若 u &gt; 2，则先处理不包括最后 8 位的部分，否则就先只处理开头 4 位。 i = r * (r != 0) + 4 * (max(u - 2 - (r == 0), 0) + (r == 0)) # 于是分成两部分递归处理 intPart[:i] 和 intPart[i:] left, right = convert_int(intPart[:i]), convert_int(intPart[i:]) # 若左部分返回空字符串 ''，则不加单位，即 j = 0 and ch_unit[j] = ''。 # 又因为最大单位为“亿”，所以 0 &lt;= j &lt;= 2 j = min(u - (r == 0), 2) if left else 0 # 得到单位 unit = ch_unit[j] # 返回最终结果 return '&#123;&#125;&#123;&#125;&#123;&#125;'.format(left, unit, right)def convert_decimal(decimalPart): \"\"\" 处理小数部分，容易多了 decimalPart: str return: str \"\"\" ans = [ch_num[c] for c in decimalPart + '0' * (2 - len(decimalPart))] ans = '&#123;&#125;角&#123;&#125;分'.format(*ans) ans = ans.replace('零角', ch_num['0']) ans = ans.replace('零分', ch_unit[0]) ans = re.sub('零+$', ch_unit[0], ans) # 因为使用递归处理整数部分，所以整数部分单位“元”放在这里处理。 return '元&#123;&#125;'.format(ans or '整')def convert_RMB(money): \"\"\" 将浮点数转换为大写人民币规范读法 money: str return: str \"\"\" if '.' in money: intPart, decimalPart = money.split('.') else: intPart, decimalPart = money, ch_unit[0] return '人民币&#123;&#125;&#123;&#125;'.format(convert_int(intPart), convert_decimal(decimalPart))","categories":[{"name":"算法","slug":"算法","permalink":"http://spiedeman.github.io/categories/算法/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://spiedeman.github.io/tags/面试/"}]},{"title":"Vim 插件配置","slug":"vim-plugins-ale","date":"2019-09-02T02:18:29.000Z","updated":"2021-09-18T02:10:59.622Z","comments":true,"path":"posts/6e83abdb/","link":"","permalink":"http://spiedeman.github.io/posts/6e83abdb/","excerpt":"","text":"语法检查与代码格式化——ALE异步检查语法pycodestyle —— 前身为pep8，检查Python语法以及格式安装1pip install pycodestyle配置配置文件在 ~/.config/pycodestyle。代码格式化yapf —— Google出品的Python代码格式化工具isort —— 格式化 import 语句安装12pip install yapfpip install isort配置配置文件在 ~/.config/yapf/style 和 ~/.isort.cfg。","categories":[{"name":"Vim","slug":"Vim","permalink":"http://spiedeman.github.io/categories/Vim/"}],"tags":[{"name":"Vim-插件","slug":"Vim-插件","permalink":"http://spiedeman.github.io/tags/Vim-插件/"}]},{"title":"字符串匹配之KMP算法","slug":"algorithm-string-kmp","date":"2019-08-18T03:20:11.000Z","updated":"2021-09-18T02:10:59.542Z","comments":true,"path":"posts/b5ae7cab/","link":"","permalink":"http://spiedeman.github.io/posts/b5ae7cab/","excerpt":"","text":"问题：给定长度为 \\(n\\)，\\(m\\) 的目标字符串s和模式字符串p，判断p是否是s的子串。若是， 返回匹配位置；否则返回 \\(-1\\)。暴力算法模式串从目标串的第一个元素开始匹配匹配失败，则目标串右移一位重新判断是否匹配模式串最坏情况为 \\(O(mn)\\)。KMP通过观察我们可以提问： &gt; 是否遇到不匹配时，只能右移 一位 重新判断？当模式串的第 \\(k\\) 位失配时，前 \\(k-1\\) 位是已经匹配的。那么可以问这样一个问题： &gt; 右移多少位之后匹配的指针不必往前移动，在当前位置的基础上继续往后开始匹配，直到匹配成功或者再次遇到失配位？首先提出一个概念：字符串前缀和后缀的最大公共长度。假设最大公共长度为 \\(j\\)，字符串长度为 \\(n\\)，那么右移 \\(n-j\\) 位后，前 \\(j\\) 位是已经匹配了的。最大公共长度中的最大表示为了匹配需要右移的最少位数。也许右移更多位也能匹配，但可能会漏掉解。#### Next数组 现在我们清楚了，为了使匹配指针不往前移，有效利用已经获得的匹配信息，我们需要对模式串进行预处理。直观地说就是我们需要知道当匹配到模式串的第几个元素失配时，应该右移多少位。这就是Next数组的含义。在 \\(\\text{Python}\\) 中，数组下标从 \\(0\\) 开始，以此为前提。假设下标为 \\(j\\)（第 \\(j+1\\) 位）失配，则匹配长度为 \\(j\\)。又设最大公共长度为 \\(i\\)，则应右移 \\(j-i\\) 位，使失配位为模式串第 \\(i+1\\) 位，即下标为 \\(i\\)。故有 \\(\\text{next}[j]=i\\)。问题变为 如何快速计算最大公共长度 \\(i\\) ？Next数组的算法步骤如下图所示，稍后再详细讨论其过程。假设已知模式串 \\(\\text{P}\\) 有 \\(\\text{next}[q]=k\\)，说明前 \\(q\\) 位字符串的最大公共长度为 \\(k\\)。即有 \\(\\text{P}[0]=\\text{P}[q-k],\\cdots, \\text{P}[k-1]=\\text{P}[q-1]\\)。问 \\(\\text{next}[q+1]=?\\)若 \\(\\text{P}[q]=\\text{P}[k]\\)，则\\(\\text{next}[q+1]=\\text{next}[q]+1=k+1\\)。若 \\(\\text{P}[q]\\neq \\text{P}[k]\\)，那么 \\(\\text{next}[q]\\) 等于多少？假设 \\(\\text{next}[q+1]=j+1\\)，则有 \\[\\text{P}[0] = \\text{P}[q-j],\\cdots,\\text{P}[j-1]=\\text{P}[q-1],\\text{P}[j]=\\text{P}[q] \\] 又因为 \\(\\text{next}[q]=k\\)，所以有 \\[ \\text{P}[k-j]=\\text{P}[q-j],\\cdots,\\text{P}[k-1]=\\text{P}[q-1] \\] 由上面两式可知， \\[ \\text{P}[0]=\\text{P}[k-j],\\cdots,\\text{P}[j-1]=\\text{P}[k-1] \\]这说明 \\(j\\) 最大可以取到 \\(\\text{next}[k]\\)，也就是我们应该比较 \\(\\text{P}[q]\\) 和 \\(\\text{P}[\\text{next}[\\text{next}[q]]]\\)。经过一点思考可知，\\(\\text{P}[q]\\) 将依次与序列 \\(\\{\\text{P}[\\text{next}[q]],\\text{P}[\\text{next}[\\text{next}[q]]],\\cdots,\\text{P}[\\text{next}^{(n)}[q]] \\}\\) 中的元素进行比较，直到相等或\\(\\text{next}^{(n)}[q]=0\\)。Python 实现12345678910111213141516171819def Next(p): \"\"\" 返回模式串的Next（优化）数组 \"\"\" ans = [0 for _ in p] for i in range(1, len(p) - 1): k = ans[i] while k: if p[k] == p[i]: ans[i+1] = k + 1 else: k = ans[k] if ans[i+1] == 0 and p[0] == p[i]: ans[i+1] = 1 # 第二个for循环给出优化KMP算法的Next数组 for i in range(2, len(p)): if ans[i] == i - 1: ans[i] = 0 return ans1234567891011121314151617181920def KMP(s, p): \"\"\" 返回模式串 p 在目标串 s 中第一次出现的下标，否则返回 -1 \"\"\" _next = Next(p) i, j = 0, 0 ns, np = len(s), len(p) while i &lt; ns and j &lt; np: if s[i] == p[j]: i, j = i + 1, j + 1 else: if j == 0: i = i + 1 else: # 遇到失配时快速移动模式串，优于暴力算法的地方 j = _next[j] if j == np: return i - j return -1","categories":[{"name":"算法","slug":"算法","permalink":"http://spiedeman.github.io/categories/算法/"}],"tags":[{"name":"字符串匹配","slug":"字符串匹配","permalink":"http://spiedeman.github.io/tags/字符串匹配/"}]},{"title":"Python-数值积分初值常微分方程组","slug":"python-scipy-ode","date":"2019-07-09T09:27:35.000Z","updated":"2021-09-18T02:10:59.622Z","comments":true,"path":"posts/7f1dadbd/","link":"","permalink":"http://spiedeman.github.io/posts/7f1dadbd/","excerpt":"","text":"通常可以将常微分方程组的求解问题分成两类： - 初值问题 - 边界问题这里讨论初值常微分方程组的数值求解，用到的工具为scipy.integrate模块中的solve_ivp函数。接收的参数和返回值分别为参数： - fun: 函数一阶常微分方程组的右端，`dy / dt = f(t, y)`。`t`为标量，`y`可以是一维数组，或二维数组（每一列表示一个函数`y`）。若参数`vectorized`为真，则`y`可以是二维数组，这一矢量化的实现是为了在刚性问题中允许通过有限差分更快地估计雅可比矩阵。t_span: 长度为2的浮点数元组积分区间为[t0, tf]。y0: 一维数组系统初值。若要在复数域上求解，则使y0的data type为复数。 （以下为常用可选参数）method: 方法名积分方法有如下几种：RK45（默认）：45阶龙格库塔法。RK23：23阶龙格库塔法。Radau：5阶隐式龙格库塔法。RK23：23阶龙格库塔法。Radau：5阶隐式龙格库塔法。BDF：基于后向微分公式的隐式多步变阶法。LSODA：Adams/BDF方法，带有刚性检测和转换功能。非刚性问题使用 RK45或RK23，刚性问题使用Radau或BDF。也可以传递任意一个实现求解功能的OdeSolver的子类。dense_output: 布尔值是否计算连续解，默认为False。t_eval: 一维数组或None对解的值感兴趣的一组时刻。默认由solver决定。events: 函数或函数列表追踪的事件。默认为None，表示没有事件需要被追踪。每一个返回值为float的形如event(t, y)的函数都可以作为一个追踪器。solver会使用root-finding算法找到event(t, y) = 0的时刻t。每个事件函数可能拥有下面的两个属性： &gt; terminal: bool, optional &gt; &gt; 是否在事件发生时终止积分。无此属性等价于False。 &gt; direction: float, optional &gt; &gt; 表示穿过零点的方向。direction为正，则事件只会以负到正的方式穿过零点时才会被触发， &gt; 反之则direction为负。若为零，则已任意方式穿过零点都会被触发。无此属性等价于0。vectorized: 布尔值 函数是否以矢量化方式实现。返回值 - t: 数组`t_eval`对应的时刻。y: 数组解在时刻t的值。sol: OdeSolution 或 None如果dense_output为False，则为None，否则为找到的解，作为OdeSolution的一个实例。t_events: 列表 或 None包含一组数组，每个数组对应一个事件，包含所有该事件发生时的时刻。例子可在此处找到。","categories":[{"name":"数值计算","slug":"数值计算","permalink":"http://spiedeman.github.io/categories/数值计算/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://spiedeman.github.io/tags/Python/"},{"name":"Scipy","slug":"Scipy","permalink":"http://spiedeman.github.io/tags/Scipy/"},{"name":"数值计算","slug":"数值计算","permalink":"http://spiedeman.github.io/tags/数值计算/"}]},{"title":"次序统计量","slug":"order-statistics","date":"2019-05-28T00:59:11.000Z","updated":"2021-09-18T02:10:59.612Z","comments":true,"path":"posts/8a864e22/","link":"","permalink":"http://spiedeman.github.io/posts/8a864e22/","excerpt":"","text":"设 \\(X_1,\\dots,X_n\\) 独立同分布，概率密度函数与累积分布函数分别为 \\(f(x;\\theta)\\) 和 \\(F(x;\\theta)\\)，\\(\\theta\\) 为分布族的参数。为了简化表达式，后文将省略参数 \\(\\theta\\)，默认为已知常数。设 \\(X_{(1)}\\le \\dots\\le X_{(n)}\\)，为相应的次序统计量。\\(X_{(i)}\\) 不对应某个确定的 \\(X_j\\)，因为每次试验，\\(x_1,\\dots,x_n\\) 的相对大小关系都不同。再加上对 \\(X\\sim f(x)\\)绝对连续型分布的假设，即 \\(P(X_{(i)}=X_{(j)})=0,i\\ne j;P(X_{(1)}\\lt\\dots\\lt X_{(n)})=1\\)。下文将在前述基础上进行推导。积分恒等式 \\[ \\sum^n_{l=i}{n\\choose l}p^l(1-p)^{n-l}=i{n\\choose i}\\int^p_0dt\\ t^{i-1}(1-t)^{n-i},\\quad 0\\le t\\le p\\le 1. \\]概率密度函数 \\(f_{(i)}(x)\\)\\(f_{(i)}(x)\\) 表示 \\(X_{(i)}\\in[x,x+dx]\\) 的精确到一阶的概率。这对应这样一种情况：有一个 \\(X\\) 落在区间 \\([x,x+dx]\\)，\\(i-1\\) 个 \\(X\\) 落在区间 \\([-\\infty,x]\\)，\\(n-i\\) 个 \\(X\\) 落在区间 \\([x+dx,\\infty]\\)。二阶及高阶对应的情形为，有两个及以上的 \\(X\\) 落在区间 \\([x,x+dx]\\)，计算 \\(f_{(i)}(x)\\) 不需要考虑。因此有\\[ f_{(i)}(x)=n{n-1\\choose i-1}[F(x)]^{i-1}f(x)[1-F(x)]^{n-i} \\tag{1} \\]累积分布函数\\(F_{(i)}(x)\\)\\[ \\begin{aligned} F_{(i)}(x)&amp;=\\int^x_{-\\infty}dy\\ f_{(i)}(y) \\\\ &amp;=n{n-1\\choose i-1}\\int^{F(x)}_0dF(y)\\ F(y)^{i-1}[1-F(y)]^{n-i} \\\\ &amp;=n{n-1\\choose i-1}\\sum^n_{j=i}\\frac{(n-i)!}{(n-j)!}\\frac{(i-1)!}{j!}F(x)^j[1-F(x)]^{n-j}\\\\ &amp;=\\sum^n_{j=i}{n\\choose j}F(x)^j[1-F(x)]^{n-j} \\end{aligned} \\tag{2} \\]这个结果也很好理解，\\(F_{(i)}(x)\\) 表示概率 \\(\\text{P}_\\text{r}(X_{(i)}\\le x)\\)。\\(X_{(i)}\\le x\\) 表示至少有 \\(j\\ge i\\) 个 \\(X\\) 落在区间 \\([-\\infty,x]\\)，对每个 \\(j\\)，共有 \\({n\\choose j}\\) 个选择。概率密度函数 \\(f_{(i,j)}(x)\\)考虑 \\(X_{(i)},X_{(j)}\\) 的联合概率密度函数 \\(f_{(i,j)}(x,y)\\)，不妨设 \\(i\\lt j\\)。类似 \\(f_{(i)}(x)\\) 的推导，可以直接写出 \\(f_{(i,j)}(x,y)\\) \\[ f_{(i,j)}(x,y)=2{n\\choose i-1}{n-i+1\\choose n-j}{j-i+1\\choose 2}F(x)^{i-1}[1-F(x)]^{n-j}[F(y)-F(x)]^{j-i-1}f(x)f(y)I\\{x\\lt y\\} \\tag{3} \\]此处 \\[ I\\{x\\le y\\}= \\begin{cases} 1,&amp; x\\le y\\\\ 0,&amp; x\\gt y \\end{cases} \\tag{4} \\]累积分布函数 \\(F_{(i,j)}(x,y)\\)\\[ \\begin{aligned} F_{(i,j)}(x,y)&amp;=\\int^x_{-\\infty}dx\\int^y_{-\\infty}dy\\ f_{(i,j)}(x,y)\\\\ &amp;=2{n\\choose i-1}{n-i+1\\choose j-i+1}{n-j\\choose2} \\int^x_{-\\infty}ds\\int^y_{-\\infty}dt\\ F(s)^{i-1}[F(t)-F(s)]^{j-i-1}[1-F(t)]^{n-i}f(s)f(t) I\\{s\\lt t\\}\\\\ &amp;=2{n\\choose i-1}{n-i+1\\choose j-i+1}{n-j\\choose2} \\int^{F(x)}_0dF(s)\\ F(s)^{i-1}\\int^{F(y)}_{F(s)}dF(t)[F(t)-F(s)]^{j-i-1}[1-F(t)]^{n-j}I\\{s\\lt y\\}\\\\ &amp;=2{n\\choose i-1}{n-i+1\\choose j-i+1}{n-j\\choose2} \\int^{F(x)}_0dF(s)\\ F(s)^{i-1}\\sum^{n-j}_{k=0}\\frac{(n-j)!}{(n-j-k)!}\\frac{(j-i-1)!}{(j-i+k)!}[F(y)-F(s)]^{j-i+k}[1-F(y)]^{n-j-k}I\\{s\\lt y\\}\\\\ &amp;=i\\sum^n_{k=j}{n\\choose k}{k\\choose i}[1-F(y)]^{n-k} \\int^{F(x)}_0dF(s)\\ F(s)^{i-1}[F(y)-F(s)]^{k-i}I\\{x\\lt y\\}\\\\ &amp;=i\\sum^n_{k=j}{n\\choose k}{k\\choose i}[1-F(y)]^{n-k} \\sum^{k-i}_{l=0}\\frac{(k-i)!}{(k-i-l)!}\\frac{(i-1)!}{(i+l)!}F(x)^{i+l}[F(y)-F(x)]^{k-i-l}I\\{x\\lt y\\}\\\\ &amp;=\\sum^n_{k=j}\\sum^k_{l=i}\\frac{n!}{(n-k)!(k-l)!l!}F(x)^l[F(y)-F(x)]^{k-l}[1-F(y)]^{n-k} I\\{x\\lt y\\}\\\\ &amp;=\\sum^n_{k=j}{n\\choose k}[1-F(y)]^{n-k}\\sum^k_{l=i}{k\\choose l}F(x)^l[F(y)-F(x)]^{k-l}I\\{x\\lt y\\} \\end{aligned} \\tag{5} \\]同样，这个结果也很好理解，\\(F_{(i,j)}(x,y)=\\text{P}_\\text{r}(X_{(i)}\\le x,X_{(j)}\\le y)\\)。\\(X_{(j)}\\le y\\) 表示至少有 \\(k\\ge j\\) 个 \\(X\\) 落在区间 \\([-\\infty,y]\\)，对每个 \\(k\\)，共有 \\({n\\choose k}\\) 个选择。然后，\\(X_{(i)}\\le x\\) 表示至少有 \\(i\\le l\\le k\\) 个 \\(X\\) 落在区间 \\([-\\infty, x]\\)，对每个 \\(l\\)，共有 \\({k\\choose l}\\) 个选择。再考虑到需要满足 \\(x\\lt y\\)，即得 \\((5)\\) 中最后一个等式。","categories":[{"name":"算法","slug":"算法","permalink":"http://spiedeman.github.io/categories/算法/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://spiedeman.github.io/tags/数学/"},{"name":"统计","slug":"统计","permalink":"http://spiedeman.github.io/tags/统计/"}]},{"title":"在多台电脑上同步更新Hexo博客","slug":"hexo-on-multi-pc","date":"2019-04-20T08:04:50.000Z","updated":"2021-09-18T02:10:59.612Z","comments":true,"path":"posts/77781092/","link":"","permalink":"http://spiedeman.github.io/posts/77781092/","excerpt":"","text":"背景目前更新博客文章，只在自己的笔记本操作。一旦想要在办公室的台式机上写文章并发布到 Github Pages 上就变得很麻烦，一时不知从何下手。需求博客的源文件能在多个设备上同步更新，并且在任意设备上都能自如写文章并发布。方案利用 GitHub 的分支功能，将 Hexo建站的必备源文件以及博客文章的源文件备份到 source 分支上。而 hexo生成的静态博客文件仍然放在默认的 master 分支上。这样在任何设备上只需将source 分支克隆到本地，即可开始写新博客。之后通过 hexo命令即可将新生成的网站内容推送到 master 分支上。两个分支上的内容互不干扰，都能维持最新状态。操作创建新的分支新分支的命名没有要求，本文采用source。创建分支的方法有两种， - 在浏览器中登陆GitHub进行操作。 - 在本地通过命令行操作。由于浏览器操作比较简单，就不详细讨论了。重点记录一下终端操作过程。1、克隆仓库 username.github.io 到本地1git clone https://github.com/username/username.github.io Hexo2、进入该文件夹并创建新的分支1234cd username.github.io# 创建新的分支 sourcegit checkout -b source3、在 source 分支内删除原有的所有文件，然后将 Hexo 建站所需的必备文件以及所有的博客文章拷贝进来123456789# 删除所有的原有内容，.git 文件夹保留rm -rf *# 拷贝必要的文件到当前目录cp -r /path/to/hexo/source .cp -r /path/to/hexo/scaffolds .cp -r /path/to/hexo/themes .cp /path/to/hexo/_config.yml .cp /path/to/hexo/package.json .需要注意的是 themes 中可能存在 .git 文件夹，需要把它们全部删除。4、提交 source 分支 由于 Hexo 命令生成网站内容时会新建两个文件夹 public 和.deploy_git。public中包含的正是所有网站的源文件，这些内容并不需要保存在 source分支，因此提交时要忽略。.deploy_git 是 Hexo帮我们把网站内容推送到 master分支上所建的文件夹，故也可以忽略。另外不需要推送的一个文件夹，便是node_modules。这个文件夹里是 Hexo用到的所有插件，在本地安装一下就有了，不需要保存在 GitHub 上。因此，提交 source 分支前需要123echo 'node_modules' &gt;&gt; .gitignoreecho 'public' &gt;&gt; .gitignoreecho '.deploy_git' &gt;&gt; .gitignore现在可以提交了123git add .git commit -m \"update blog files\"git push origin source在新设备上的准备工作要在新设备上愉快地用 Hexo 写博客之前，需要做一些准备工作。1、安装 git，并将新设备上的 ssh key 添加到 GitHub 账户上。2、安装 Hexo3、把 souce 分支克隆到本地1234git clone -b source git@github.com:username/username.github.io.git Hexo# 若已将 source 分支设为默认分支，则可以简化命令git clone https://github.com/username/username.github.io Hexo4、安装所有依赖，生成 node_modules 目录1npm install5、创建新文章，生成博客的静态文件（即 public 目录）1234hexo new \"title\"# 文章写完之后hexo g6、将博客内容推送到 GitHub 上123# 博客的静态文件在 master 分支，其他的源文件在 source 分支# _config.yml 中 deploy 的 branch 值必须为 masterhexo d7、最后把修改推送到 source 分支123git add .git commit -m \"commit message\"git push origin source注意：在新设备上的所有操作都在 source 分支下完成。日常操作由于上一次更新博客有可能不是在手头的电脑上操作的。因此 GitHub 上的 source 分支可能比本地的更新，因此首先要更新本地的 source 分支。1git pull origin source接下来，按照正常流程写文章并用hexo部署到GitHub上。最后，把对源文件的修改推送到 source 分支上。参考资料： theqwang's blog","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://spiedeman.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://spiedeman.github.io/tags/Hexo/"}]},{"title":"GitBook 安装配置 & 导出 PDF","slug":"gitbook2pdf","date":"2019-04-18T11:46:20.000Z","updated":"2021-09-18T02:10:59.602Z","comments":true,"path":"posts/3741144490/","link":"","permalink":"http://spiedeman.github.io/posts/3741144490/","excerpt":"","text":"安装 GitBook12npm install -g gitbook-cligitbook -V # 查看版本使用 calibre 插件生成PDF123456brew cask install calibrecd path/to/book# 生成 pdfgitbook pdf . mypdf.pdf","categories":[{"name":"电子书","slug":"电子书","permalink":"http://spiedeman.github.io/categories/电子书/"}],"tags":[{"name":"GitBook","slug":"GitBook","permalink":"http://spiedeman.github.io/tags/GitBook/"}]},{"title":"Vim 技巧","slug":"vim-tips","date":"2019-02-18T02:11:19.000Z","updated":"2021-09-18T02:10:59.622Z","comments":true,"path":"posts/4131642440/","link":"","permalink":"http://spiedeman.github.io/posts/4131642440/","excerpt":"","text":"用法自定义映射正确使用option/Alt键option键在macOS下作为组合按键之一，对应于PC、Linux上的Alt键，但是功能不太一样。Mac上字母及一些标点符号与option组合会输出unicode字符。 原因在于按下按下option键发送的不是Escape Sequence。因此在vim,emacs等终端软件中，没法直接使用Alt键定义映射。找到原因就好办，解决方法分为两步： 1. 在终端中修改option/Alt键的行为 2. 在vim,emacs等运行于终端下的软件中进行可能必要的设置以终端程序kitty和alacritty为例，具体讨论解决方法中的第一步如何操作。 - kitty - 打开配置文件kitty.conf - 找到选项macos_option_as_alt no，将no改为yes - alacrity - 打开配置文件alacrity.yml - 定位到key_bindings - 添加需要的键位设置，例如 - { key: x, mods: Alt, chars: &quot;\\x1bx&quot; }以运行在终端下的vim为例，给出第二步中需要的具体操作。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162function! Terminal_MetaMode(mode) set ttimeout if $TMUX != '' set ttimeoutlen=30 elseif &amp;ttimeoutlen &gt; 80 || &amp;ttimeoutlen &lt;= 0 set ttimeoutlen=80 endif if has('nvim') || has('gui_running') || $TERM_PROGRAM =~? 'iTerm2' return endif \" 👆表示只有某些终端下的vim需要👇的设置 function! s:metacode(mode, key) \" 这个函数的作用是告诉vim，&lt;M-x&gt;的键盘序列码是多少 \" 这样vim将按照ttimeoutlen的设置来检查是否超时 \" 如果用 `noremap &lt;ESC&gt;x &lt;M-x&gt;` 然后 `noremap &lt;M-x&gt; ...`的方式， \" 则会使用timeoutlen来检查是否超时 \" 一般timeoutlen设置的相对更大，如果用它更容易误操作，降低使用体验 if a:mode == 0 exec \"set &lt;M-\".a:key.\"&gt;=\\e\".a:key else \"👇这条需要对终端进行更针对性的设置，写本节时只想到在alacrity中设置会容易些 exec \"set &lt;M-\".a:key.\"&gt;=\\e]&#123;0&#125;\".a:key.\"~\" endif endfunction \" 针对alacrity，还需设置几个功能键 if $TERM_PROGRAM =~? 'alacritty' exec \"set &lt;F1&gt;=\\eOP\" exec \"set &lt;F2&gt;=\\eOQ\" exec \"set &lt;F3&gt;=\\eOR\" exec \"set &lt;F4&gt;=\\eOS\" endif for i in range(10) call s:metacode(a:mode, nr2char(char2nr('0') + i)) endfor for i in range(26) call s:metacode(a:mode, nr2char(char2nr('a') + i)) call s:metacode(a:mode, nr2char(char2nr('A') + i)) endfor if a:mode != 0 for c in [',', '.', '/'. ';', '[', ']', '&#123;', '&#125;'] call s:metacode(a:mode, c) endfor for c in ['?', ':', '-', '_'] call s:metacode(a:mode, c) endfor else for c in [',', '.', '/', ';', '&#123;', '&#125;'] call s:metacode(a:mode, c) endfor for c in ['?', ':', '-', '_'] call s:metacode(a:mode, c) endfor endifendfunction\" 设置用户自定义命令command! -nargs=0 -bang VimMetaInit call Terminal_MetaMode(&lt;bang&gt;0)\" buffer 读入后自动进行设置augroup alt_key autocmd! autocmd BufReadPost * :VimMetaInitaugroup END用户自定义事件自定义了切换透明和背景的函数，并绑定了快捷键。同时主题栏使用的是lightline。 我为dark和light两种背景选取不同的lightline主题，为了使背景切换之后，主题栏的切换也生效，这里使用用户自定义事件来解决问题。 当然这不是唯一的方法。1234567891011function! ToggleBackground() \" A lot of stuff is happening here. \" 定义一个自定义事件 doautocmd User ToggleBackgroundExitendfunctionfunction! ToggleTransparent() \" A lot of stuff is happening here. \" 定义一个自定义事件 doautocmd User ToggleTransparentExitendfunction现在可以在切换背景和透明度执行完成后做任何想做的事：1autocmd User ToggleBackgroundExit call lightline#enable()插件插件管理器（vim-plug）vim-plug是一款异步插件管理器。具有安装速度快，延迟加载等特性。 这里要讨论的是刚发现的一个特性，可以让插件按照依赖关系进行加载。栗子🌰，我有三款用于markdown的插件，分别是plasticboy/vim-markdownjszakmeister/markdown2ctagsiamcco/markdown-preview.nvim原本可以在每个插件后面，用{'for':'markdown'}使其仅在编辑.md文件时才加载。但我发现 这种方法对第二款插件无效。因此想到这里的办法。vim-plug在调用函数plug#load()加载插件之后会以插件名定义一个用户自定义事件。可以利用这一事件触发对其有依赖的插件的调用。如下为具体的使用案例：1234567891011121314\" 以文件类型作为加载的依据Plug 'iamcco/markdown-preview.nvim', &#123;'for': 'markdown', 'do': 'cd app &amp; yarn install'&#125; \" 下面的插件无法按照文件类型进行加载 \" 故通过vim-plug 定义的用户自定义事件进行触发 Plug 'plasticboy/vim-markdown', &#123;'on' : []&#125; Plug 'jszakmeister/markdown2ctags', &#123;'on': []&#125; augroup vimplug_load_for_markdown autocmd! autocmd User markdown-preview.nvim plug#load( \\ 'vim-markdown', \\ 'markdown2ctags', \\ ) \\ | autocmd! vimplug_load_for_markdown augroup END进一步，针对一个插件的所有配置可以做到这样：在插件被加载前，不载入加载后，自动载入可以这样实现12345678910\" 仍然以上面的插件为例\" 在载入 vim-markdown之后自动加载相关配置。所有配置在函数SetVimmarkdown()之中function! SetVimmarkdown() \" all configurations for vim-markdown are at hereendfunctionaugroup load_for_vimmarkdown autocmd! autocmd User vim-markdown call SetVimmarkdown() | autocmd! load_for_vimmarkdownaugroup END中文输入法vim 的模式切换与中文输入法并不总能够和谐共处。 | | 英文 | 中文 | |--------|------|------| | normal | :) | :( | | insert | :) | :) |解决这个问题的方式大体上有两种，1、vim 提供中文输入法，那么这个问题就留给vim及其插件的开发者们去解决了；2、仍然使用外部中文输入法，如搜狗等， 那么关键在于以哪种方式自动切换输入法！这里沿用第二种思路。尝试过如下几种方式：通过 vim 内置函数模拟按键操作来切换输入法。没有成功，但不排除可行性。调用外部程序进行输入法切换。成功，但是并不完美。所以最终采取的方案是通过调用外部程序在进入和离开insert模式时只能切换输入法。实现方式具体看下面的vim配置。12345678910111213141516171819202122\" 定义缓冲区变量，使得可以对每个缓冲区单独监控输入法状态au BufEnter * let b:im=0\" 为了尽量不影响体验，通过异步机制来进行处理\" 下面的函数用于在 job 进行过程中处理返回信息fun! IMHandler(channel, msg) if a:msg !=? 'com.apple.keylayout.ABC' \" 切换到英文输入法之前保存当前状态 let b:im = 1 call job_start(['issw', 'com.apple.keylayout.ABC']) endifendfunfun! Lang2en() let job = job_start(['issw'], &#123;\"out_cb\": \"IMHandler\"&#125;)endfun\" 这里中文输入法的切换用了自己写的脚本，虽然也可以用上面的 issw 命令。fun! Lang2zh() if b:im == 1 call job_start(['switchim']) endifendfunautocmd InsertEnter * call Lang2zh()autocmd BufEnter,InsertLeave * call Lang2en()因为不想用破解软件来修改按键映射及快捷键，导致仍有不足之处：调用的外部程序切换输入法不够快，仍然有一定几率产生困扰。insert 模式下，如果要用搜狗输入法，从英文切换回中文比较麻烦。","categories":[{"name":"Vim","slug":"Vim","permalink":"http://spiedeman.github.io/categories/Vim/"}],"tags":[{"name":"Vim","slug":"Vim","permalink":"http://spiedeman.github.io/tags/Vim/"}]},{"title":"Graphviz 介绍","slug":"graphviz-introduction","date":"2019-02-16T08:46:44.000Z","updated":"2021-09-18T02:10:59.602Z","comments":true,"path":"posts/1414645917/","link":"","permalink":"http://spiedeman.github.io/posts/1414645917/","excerpt":"","text":"这篇文章参考自Drawing graphs with dot\\(dot\\) 通过\\(DOT\\)语言来作图。该语言描述了三大对象：图(graphs)，节点(nodes)，边(edges)。同时支持有向图和无向图，并支持图的嵌套(\\(subgraph\\))。 默认采用有向图的布局方式，有另一个独立的布局工具，neato，用于无向图。\\(dot\\) 编译的方式是按顺序一行一行地处理 *.dot 文件中内容。所以各种对象的属性的有效性从从属性设置语句所在行开始直到下一次属性设置语句所在行之前。完整的属性描述可以参考\\(Graphviz\\)官网的该页面。要素一幅图可以包含如下要素：注释双斜杠有向图 or 无向图节点之间的关系有向图：a-&gt;b，节点 a 指向节点 b无向图：a--b，节点 a 和节点 b连通定义节点属性形状，多边形polygon和record（不知道怎么翻译）颜色标签等等定义边的属性形状颜色文本等等定义结构(record)内部结构方向，水平或竖直排列标签样例12345678digraph G&#123; a -&gt; b -&gt; c; b -&gt; d; a [shape=polygon,sides=5,peripheries=3,color=lightblue,style=filled]; c [shape=polygon,sides=4,skew=.4,label=&quot;hello world&quot;] d [shape=invtriangle]; e [shape=polygon,sides=4,distortion=.7];&#125;12345678digraph structs&#123;node [shape=record]; struct1 [shape=record,label=&quot;&lt;f0&gt; left|&lt;f1&gt; mid\\ dle|&lt;f2&gt; right&quot;]; struct2 [shape=record,label=&quot;&lt;f0&gt; one|&lt;f1&gt; two&quot;]; struct3 [shape=record,label=&quot;hello\\nworld | &#123; b |&#123;c|&lt;here&gt; d|e&#125;| f&#125;|g|h &quot;]; struct1 -&gt; struct2; struct1 -&gt; struct3;&#125;123456789101112131415161718192021222324digraph G &#123; node[shape=record,height=.1]; //定义node样式 node0[label=&quot;&lt;f0&gt; |&lt;f1&gt; A|&lt;f2&gt; &quot;]; //具体的一个node，含三个属性，第二个属性有名字 node0[label=&quot;&lt;f0&gt; |&lt;f1&gt; B|&lt;f2&gt; &quot;]; node0[label=&quot;&lt;f0&gt; |&lt;f1&gt; C|&lt;f2&gt; &quot;]; node0[label=&quot;&lt;f0&gt; |&lt;f1&gt; D|&lt;f2&gt; &quot;]; node0[label=&quot;&lt;f0&gt; |&lt;f1&gt; E|&lt;f2&gt; &quot;]; node0[label=&quot;&lt;f0&gt; |&lt;f1&gt; F|&lt;f2&gt; &quot;]; node0[label=&quot;&lt;f0&gt; |&lt;f1&gt; H|&lt;f2&gt; &quot;]; node0[label=&quot;&lt;f0&gt; |&lt;f1&gt; I|&lt;f2&gt; &quot;]; node0[label=&quot;&lt;f0&gt; |&lt;f1&gt; J|&lt;f2&gt; &quot;]; node0[label=&quot;&lt;f0&gt; |&lt;f1&gt; K|&lt;f2&gt; &quot;]; &quot;node0&quot;:f2 -&gt; &quot;node1&quot;: f1; //node0的第三个属性指向node1的第二个属性 &quot;node1&quot;:f0 -&gt; &quot;node2&quot;: f1; &quot;node1&quot;:f1 -&gt; &quot;node3&quot;: f2; &quot;node3&quot;:f0 -&gt; &quot;node4&quot;: f0; &quot;node3&quot;:f1 -&gt; &quot;node5&quot;: f1; &quot;node3&quot;:f2 -&gt; &quot;node6&quot;: f2; &quot;node6&quot;:f1 -&gt; &quot;node7&quot;: f1; &quot;node7&quot;:f1 -&gt; &quot;node8&quot;: f0; &quot;node2&quot;:f2 -&gt; &quot;node9&quot;: f1;&#125;","categories":[{"name":"Graphviz","slug":"Graphviz","permalink":"http://spiedeman.github.io/categories/Graphviz/"}],"tags":[{"name":"Graphviz","slug":"Graphviz","permalink":"http://spiedeman.github.io/tags/Graphviz/"}]},{"title":"Ubuntu 16.04 LTS 开启BBR","slug":"vultr-ubuntu16-04-bbr","date":"2019-01-05T16:56:29.000Z","updated":"2021-09-18T02:10:59.622Z","comments":true,"path":"posts/3381164653/","link":"","permalink":"http://spiedeman.github.io/posts/3381164653/","excerpt":"","text":"Vultr 上安装 ubuntu 16.04 并开启BBR。更新内核BBR只支持4.9+的Linux内核版本，因此首先检查并更新内核。12345# 查看当前内核版本uname -r# 安装最新版内核sudo apt install linux-image-generic-hwe-16.04重启1sudo reboot开启BBR添加如下两行至文件/etc/sysctl.conf12net.ipv4.default_qdisc=fqnet.ipv4.tcp_congestion_control=bbr启动bbr1sysctl -p验证是否成功123lsmod | grep bbrtcp_bbr 20480 1","categories":[{"name":"科学上网","slug":"科学上网","permalink":"http://spiedeman.github.io/categories/科学上网/"}],"tags":[{"name":"BBR","slug":"BBR","permalink":"http://spiedeman.github.io/tags/BBR/"}]},{"title":"Python万物皆对象","slug":"python-type-and-object","date":"2018-12-14T11:33:45.000Z","updated":"2021-09-18T02:10:59.622Z","comments":true,"path":"posts/1949292692/","link":"","permalink":"http://spiedeman.github.io/posts/1949292692/","excerpt":"","text":"类与对象Python中有两种关系： - 类与对象，顶点为Type。 - 继承，顶点为Object。类与对象（Type）__class__方法查看当前对象所属的类，亦即由哪个类实例化得到。Python 中的对象可以分成两种 - 不是类的对象，例如手里的一个🍎。 - 亦是类的对象，例如🍎，作为水果这个类的一个实例（对象）。类比如下关系： &gt; 手里的🍎（创建自）🍎（创建自）水果（创建自）食物（创建自）... 顶点Python 版本 &gt; 不是类的对象（创建自）亦是类的对象（创建自）类的类（创建自）Type（顶点）继承（Object）__base__方法查看当前类的父类，亦即继承自哪个类。Python 中的类也可以分成两种 - 普通类，类继承链条的末端，其实例不是类。 - 元类，类继承链条的非末端，其实例依然是类。类比如下关系： &gt; 🍎（继承自）水果（继承自）食物（继承自）... 顶点Python 版本 &gt; 普通类（继承自）元类（继承自）...（继承自）Object（顶点）Type/ObjectType 作为 - 类，继承自 Object - 对象，创建自 Type（自身）Object 作为 - 类，继承自 Object（自身） - 对象，创建自 Type道生一，一生二，二生三，三生万物网上有人用它来理解 类对象 关系，觉得生动形象，故记录于此。 1、道 即 Type 2、一 即 元类 3、二 即 普通类 4、三 即 实例 5、万物 即 各种实例属性，方法","categories":[{"name":"Python","slug":"Python","permalink":"http://spiedeman.github.io/categories/Python/"}],"tags":[{"name":"类型与对象","slug":"类型与对象","permalink":"http://spiedeman.github.io/tags/类型与对象/"}]},{"title":"在集群（CentOS 6.6）上安装YouCompleteMe","slug":"YouCompleteMe-on-ITP","date":"2018-12-08T16:25:58.000Z","updated":"2021-09-18T02:10:59.542Z","comments":true,"path":"posts/3242500049/","link":"","permalink":"http://spiedeman.github.io/posts/3242500049/","excerpt":"","text":"准备工作获取动态库安装YouCompleteMe所需的其实只有一个动态库文件libclang.so.$version。由于YCM一直在升级，对clang的版本要求也越来越高。 无奈官网最新的几个版本都没有给出CentOS的预编译包，只能下载官网unknown-linux-gnu版本或自行编译clang得到库文件。实际尝试过后发现官网unknown-linux-gnu版本虽然可以编译通过，但是无法使用。因此只能选择自行编译clang，具体编译安装过程可以参考。配置gcc及g++版本由于集群默认gcc版本太低，故需切换高版本gcc并设置CC和CXX12345export CC=gccexport CXX=g++# 不做上述设置则需要添加 CMAKE 选项# -DCMAKE_C_COMPILER=gcc# —DCMAKE_CXX_COMPILER=g++设置python版本YouCompleteMe目前同时支持python2及python3，因此开启vim对python2/3的支持均可以。1234# 切换shell中python版本，使其与vim支持的一致pyenv shell 2.7.15# orpyenv shell 3.6.6问题：原本想编译vim使其同时支持python2和python3，但不知哪里出了问题，虽然显示同时支持，可实际上一个都不支持。安装 YCM方法一使用自带安装脚本install.py。12345678910# YCM 通过sha256来判断是否需要从官网下载需要的库文件# 为了避免自动下载，使其使用自行编译并打包的动态库# 需要修改如下文件cd $HOME/.vim/vim_plugin/YouCompleteMe/third_party/ycmd/cpp/ycm/vim CMakeLists.txt# 修改第74行，将该sha256值替换为自己的压缩文件的sha256值，保存并推出。# 将打包的库文件放到如下目录中mv /path/to/my/libclang-$version-*.tar.bz2 ../../clang_archive/方法二使用我自己写的脚本进行Full Installation。1234567891011121314151617181920# 自定义路径pathbuild=$HOME/ycm_buildpathdest=$HOME/.vim/vim_plugin/YouCompleteMe/third_party/ycmd/cpp# 新建目录 build[ -d $pathbuild ] &amp;&amp; rm -rf $pathbuildmkdir $pathbuild &amp;&amp; cd $pathbuild# 开始编译cmake -DCMAKE_C_COMPILER=gcc \\ -DCMAKE_CXX_COMPILER=g++ \\ -DUSE_PYTHON2='OFF' \\ -DPYTHON_INCLUDE_DIR=$HOME/.pyenv/versions/3.6.6/include/python3.6m \\ -DPYTHON_LIBRARY=$HOME/.pyenv/versions/3.6.6/lib/libpython3.6m.so \\ -G \"Unix Makefiles\" -DEXTERNAL_LIBCLANG_PATH=/path/to/libclang.so . $pathdestcmake --build . --target ycm_core --config Release# 删除目录 buildrm -rf $pathbuild","categories":[{"name":"Vim","slug":"Vim","permalink":"http://spiedeman.github.io/categories/Vim/"}],"tags":[{"name":"YouCompleteMe","slug":"YouCompleteMe","permalink":"http://spiedeman.github.io/tags/YouCompleteMe/"}]},{"title":"CentOS6.6编译安装Clang7.0.0","slug":"clang-from-source-on-centos6","date":"2018-12-08T07:52:16.000Z","updated":"2021-09-18T02:10:59.602Z","comments":true,"path":"posts/2372579481/","link":"","permalink":"http://spiedeman.github.io/posts/2372579481/","excerpt":"","text":"下载安装包编译安装Clang需要下载7个文件，分别是1、llvm-7.0.0.src.tar.xz 2、cfe-7.0.0.src.tar.xz1 3、clang-tools-extra-7.0.0.src.tar.xz 4、compiler-rt-7.0.0.src.tar.xz 5、libcxx-7.0.0.src.tar.xz 6、libcxxabi-7.0.0.src.tar.xz 7、libunwind-7.0.0.src.tar.xz1234567891011121314version=7.0.0url=http://releases.llvm.org/$versionfile1=llvm-$version.srcfile2=cfe-$version.srcfile3=clang-tools-extra-$version.srcfile4=compiler-rt-$version.srcfile5=libcxx-$version.srcfile6=libcxxabi-$version.srcfile7=libunwind-$version.srcfor file in $file&#123;1..7&#125;do [ -f $file.tar.xz ] || wget $url/$file.tar.xzdone编译安装12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 进入安装脚本所在的目录path=$PWD/$0cd $&#123;path%/*&#125;# 获取 clang 版本号for file in `ls .`do [[ $file =~ \"llvm\" ]] &amp;&amp; version=$filedoneversion=$&#123;version/*-&#125;version=$&#123;version%.src*&#125;# 新建 build 目录mkdir build &amp;&amp; cd build# 解压for file in $file&#123;1..7&#125;do tar xvf ../$file.tar.xzdone# 移动目录mv $file2 $file1/tools/clangmv $file3 $file1/tools/clang/tools/extramv $file4 $file1/projects/compiler-rtmv $file5 $file1/projects/libcxxmv $file6 $file1/projects/libcxxabimv $file7 $file1/projects/libunwind# 编译及安装# 由于集群上默认gcc版本太低，所以必须切换到较高版本。# 即便如此，仍需在shell中设定CC、CXX或者添加CMAKE选项指定C、CXX编译器才能通过检测export CC=gccexport CXX=g++# 若进行了上面的设置，则可省去选项 -DCMAKE_C_COMPILER 和 -DCMAKE_CXX_COMPILERcmake -G\"Unix Makefiles\" \\ -DCMAKE_CXX_COMPILER=/path/to/specified/g++ \\ -DCMAKE_C_COMPILER=/path/to/specified/gcc \\ -DCMAKE_INSTALL_PREFIX=/path/to/installation \\ -DCMAKE_BUILD_TYPE=Release \\ -DLLVM_TARGETS_TO_BUILD=\"X86\" \\ $file1 # -DCLANG_DEFAULT_CXX_STDLIB=libc++ \\make -j 4make installmake install-cxx install-cxxabi打包clang动态库手动安装clang的目的主要是为了安装YouCompleteMe，需要用到的其实就只有一个动态库文件libclang.so.7。1234mkdir libcp -l /path/to/installation/lib/libclang.so* libtar -cjf libclang-$version-x86_64-unknown-linux-gnu.tar.bz2 librm -rf lib","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://spiedeman.github.io/categories/编程语言/"}],"tags":[{"name":"Clang","slug":"Clang","permalink":"http://spiedeman.github.io/tags/Clang/"},{"name":"CentOS","slug":"CentOS","permalink":"http://spiedeman.github.io/tags/CentOS/"}]},{"title":"Vim 编译安装及配置","slug":"vim-install-from-source","date":"2018-12-08T06:56:12.000Z","updated":"2021-09-18T02:10:59.622Z","comments":true,"path":"posts/3465068350/","link":"","permalink":"http://spiedeman.github.io/posts/3465068350/","excerpt":"","text":"提前准备为了脚本能顺利运行，需要预先安装好如下几个软件： - curl - jq - wget下载源代码从github下载vim，好处是可以自由切换版本。12345678910# git clone https://github.com/vim/vim.git# 利用 curl、jq、awk 以及 GitHub 的 API 获取最新版本下载链接# 利用 wget 下载并保存为 vim-latest.tar.gzfile=vim-latest.tar.gzapi=\"https://api.github.com/repos/vim/vim/tags\"download_url=$(curl -s $api | jq -r \".[] | .tarball_url\" | awk 'NR==1&#123;print&#125;')latest_version=$(curl -s $api | jq -r \".[] | .name\" | awk 'NR==1&#123;print&#125;')wget -O $file $download_url解压，进入目录123456mkdir vim-latesttar -zxf vim-latest.tar.gz -C vim-latest --strip-components=1cd vim || exit# 查看当前版本git describe --tags编译安装1234567891011121314151617181920# 清除上次configure留下的痕迹make distclean# 重新configure./configure \\--prefix=$HOME/Program/vim/$&#123;latest_version##*v&#125; \\--enable-multibyte=yes \\--enable-gui=gtk2 \\--with-x \\--with-features=huge \\--enable-python3interp=yes \\--enable-perlinterp=yes \\--enable-rubyinterp=yes \\--enable-luainterp=yes \\--with-luajit \\--enable-cscope \\--with-compiledby=徐武涛 \\# 安装make -j 16 &amp;&amp; make install卸载vim的Makefile提供了uninstall选项，因此卸载很容易。1cd vim &amp;&amp; make uninstall","categories":[{"name":"Vim","slug":"Vim","permalink":"http://spiedeman.github.io/categories/Vim/"}],"tags":[{"name":"Vim","slug":"Vim","permalink":"http://spiedeman.github.io/tags/Vim/"}]},{"title":"Homebrew 使用方法","slug":"homebrew-guide","date":"2018-12-04T13:55:23.000Z","updated":"2021-09-18T02:10:59.612Z","comments":true,"path":"posts/319510325/","link":"","permalink":"http://spiedeman.github.io/posts/319510325/","excerpt":"","text":"查看已安装的包1brew list更新 Homebrew要获取最新的包列表，需先更新 Homebrew 自身。1brew update更新包（formula）查看哪些包有新版本1234brew outdatedbrew upgrade # 更新左右包brew upgrade $FORMULA # 更新指定包更新时自动清理旧版本，在brew upgrade前设置环境变量HOMEBREW_UPGRADE_CLEANUP。清理旧版本123brew cleanup # 清理所有包的旧版本brew cleanup $FORMULA # 清理指定包的旧版本brew cleanup -n # 查看可清理的旧版本包，不会执行清除操作彻底卸载，包括删除旧版本1brew uninstall formaula_name --force锁定包被锁定的包在更新时会被略过。12brew pin $FORMULA # 锁定brew unpin $FORMULA # 取消锁定切换版本时间一长，各个包可能都有多个版本并存。1brew switch $FORMULA $VERSION # 切换包到指定版本查看依赖关系1brew deps --installed --tree # 查看已安装的包的依赖关系","categories":[{"name":"MacOS","slug":"MacOS","permalink":"http://spiedeman.github.io/categories/MacOS/"}],"tags":[{"name":"Homebrew","slug":"Homebrew","permalink":"http://spiedeman.github.io/tags/Homebrew/"}]},{"title":"欧拉-拉格朗日方程","slug":"euler-lagrange-equation","date":"2018-12-02T12:12:33.000Z","updated":"2021-09-18T02:10:59.602Z","comments":true,"path":"posts/4141491110/","link":"","permalink":"http://spiedeman.github.io/posts/4141491110/","excerpt":"","text":"作用量作用量 \\(S\\) 是拉氏密度\\(\\mathcal{L}\\) 在四维时空中的积分，\\[ S = \\frac{1}{c}\\int d^4x \\mathcal{L}(\\phi,\\partial_\\mu\\phi) \\]场的变分对场的变分的贡献共来自两个方面，1、坐标无穷小变换；2、场自身的无穷小变换。下面分别讨论这两种情况。1、坐标无穷小变换 \\[ x^{\\mu}\\rightarrow x&#39;^{\\mu}= x^{\\mu} + \\delta x^{\\mu} \\]通常谈论的场的变分是指坐标不变时的变分 \\(\\bar{\\delta}\\)， \\[ \\bar{\\delta}\\phi(x) = \\phi&#39;(x) - \\phi(x) \\] 根据标量场 \\(\\phi(x)\\) 在坐标变换下的性质 \\(\\phi&#39;(x&#39;)=\\phi(x)\\)，容易得到 \\[ \\bar{\\delta}\\phi = -\\delta x^{\\mu}\\partial_{\\mu}\\phi \\]2、场自身的无穷小变换 在没有坐标变换的情况下，场 \\(\\phi\\) 产生了一个无穷小变换。此时坐标不变时的变分为 \\[ \\bar{\\delta}\\phi = \\phi&#39;(x) - \\phi(x) = \\delta\\phi \\] 注意到这里用 \\(\\delta\\) 表示场自身的变分。通常情况下遇到的变分就是这种情况。3、一般情况 如果同时考虑到坐标变换以及场自身的变分，则标量场 \\(\\phi(x)\\) 满足的性质需修改为 \\[ \\phi&#39;(x&#39;) = \\phi(x) + \\delta\\phi(x) \\] 故坐标不变时的变分为 \\[ \\begin{aligned} \\bar{\\delta}\\phi(x) &amp;= \\phi&#39;(x) - \\phi(x) \\\\ &amp;= \\phi(x-\\delta{x}) + \\delta\\phi(x-\\delta{x}) - \\phi(x) \\\\ &amp;\\approx \\delta\\phi(x) - \\delta{x^\\mu}\\partial_{\\mu}\\phi(x) \\\\ \\end{aligned} \\]根据上述讨论可知，场自身的变分一般情况下并非坐标不变时的变分 (\\(\\bar{\\delta} \\neq \\delta\\))， 只有当不存在坐标变换的情况下两者才相等 (\\(\\bar{\\delta} = \\delta\\))。拉氏密度的变分一般情况下，作为标量场的拉氏密度的坐标不变时的变分为 \\[ \\begin{aligned} \\bar{\\delta}\\mathcal{L}(x) &amp;= \\mathcal{L}&#39;(x) - \\mathcal{L}(x) \\\\ &amp;= \\mathcal{L}(x-\\delta x) - \\delta\\mathcal{L}(x-\\delta x) - \\mathcal{L}(x) \\\\ &amp;= \\delta\\mathcal{L}(x) - \\delta{x^\\mu}\\partial_{\\mu}\\mathcal{L} \\\\ &amp;= \\frac{\\partial\\mathcal{L}}{\\partial\\phi}\\bar{\\delta}\\phi + \\frac{\\partial\\mathcal{L}}{\\partial\\partial_{\\mu}\\phi}\\bar{\\delta}\\partial_{\\mu}\\phi \\end{aligned} \\]作用量的变分\\[ \\begin{aligned} \\delta S &amp;= \\int \\delta(d^4 x)\\mathcal{L} + \\int d^4 x\\, \\delta{\\mathcal{L}} \\\\ &amp;= \\int d^4x \\left(\\bar{\\delta}\\mathcal{L}+\\delta x^{\\mu}\\partial_{\\mu}{\\mathcal{L}} + \\mathcal{L}\\partial_{\\mu}\\delta{x^\\mu}\\right) \\\\ &amp;= \\int d^4x \\left(\\bar{\\delta}\\mathcal{L} + \\partial_{\\mu}(\\mathcal{L}\\delta x^{\\mu})\\right) \\\\ &amp;= \\int d^4x \\left(\\frac{\\partial\\mathcal{L}}{\\partial\\phi}\\bar{\\delta}\\phi + \\frac{\\partial\\mathcal{L}}{\\partial\\partial_{\\mu}\\phi}\\bar{\\delta}\\partial_{\\mu}\\phi + \\partial_{\\mu}(\\mathcal{L}\\delta x^{\\mu})\\right) \\\\ &amp;= \\int d^4x \\left[\\left(\\frac{\\partial\\mathcal{L}}{\\partial\\phi} - \\partial_{\\mu}\\frac{\\partial\\mathcal{L}}{\\partial\\partial_{\\mu}\\phi}\\right)\\bar{\\delta}\\phi + \\partial_{\\mu}\\left(\\frac{\\partial\\mathcal{L}}{\\partial\\partial_{\\mu}\\phi}\\bar{\\delta}\\phi+\\mathcal{L}\\delta x^{\\mu}\\right) \\right] \\end{aligned} \\]拉格朗日方程假设坐标不变，只考虑场量的变分，则有 \\[ \\begin{aligned} &amp; \\bar{\\delta}\\phi = \\delta\\phi \\\\ &amp; \\delta x^{\\mu} = 0 \\end{aligned} \\]由表面项在4维时空边界上为零及变分 \\(\\bar{\\delta}\\phi\\) 任意，作用量的变分取极值的条件给出拉格朗日方程 \\[ \\partial_{\\mu}\\frac{\\partial\\mathcal{L}}{\\partial\\partial_{\\mu}\\phi} - \\frac{\\partial\\mathcal{L}}{\\partial\\phi} = 0 \\]诺特定理若场 \\(\\phi(x)\\) 满足拉格朗日方程，则作用量的变分为某个表面项的4维积分。若场在变换（包括坐标变换和自身变换）前后均满足拉格朗日方程，且保持作用量不变。则 由 \\[ \\delta S = \\frac{1}{c} \\int d^4x \\partial_{\\mu}j^{\\mu} = 0 \\] 以及 \\[ j^{\\mu} = \\frac{\\partial\\mathcal{L}}{\\partial\\partial_{\\mu}\\phi}\\bar{\\delta}\\phi + \\mathcal{L}\\delta x^{\\mu} \\] 得到一个对应该变换的守恒流 \\(j^{\\mu}\\)。将 \\(j^{\\mu}\\) 改写为 \\[ j^{\\mu} = \\frac{\\partial\\mathcal{L}}{\\partial\\partial_{\\mu}\\phi}\\delta\\phi - \\left(\\frac{\\partial\\mathcal{L}}{\\partial\\partial_{\\mu}\\phi}\\partial_{\\nu} - \\mathcal{L}g^{\\mu}_{\\nu}\\right)\\delta x^{\\nu} \\]\\(\\delta\\phi\\) 和 \\(\\delta x^{\\mu}\\) 现在是保持拉格朗日方程不变的变换。","categories":[{"name":"物理","slug":"物理","permalink":"http://spiedeman.github.io/categories/物理/"}],"tags":[{"name":"最小作用量","slug":"最小作用量","permalink":"http://spiedeman.github.io/tags/最小作用量/"},{"name":"诺特定理","slug":"诺特定理","permalink":"http://spiedeman.github.io/tags/诺特定理/"}]},{"title":"Mac下安装Python版CAMB","slug":"camb-with-python-on-mac","date":"2018-11-26T09:48:03.000Z","updated":"2021-09-18T02:10:59.602Z","comments":true,"path":"posts/3538923028/","link":"","permalink":"http://spiedeman.github.io/posts/3538923028/","excerpt":"","text":"安装过程遇到的坑camb的最新版已经支持Intel Fortran编译器进行编译。然而编译python版本camb的过程中会遇到不少问题。1、编译选项冲突 查看Makefile发现，MacOS平台下camb共享库camblib.so的编译选项中SFFLAGS保持默认会出现编译错误。123# -fminshared 与 -fpic 选项冲突# 修改为SFFLAGS = -dynamiclib2、动态库加载错误 修改Makefile之后，编译没有问题，但是在Python中import时会出现库未加载的错误。1234OSError:dlopen(/Users/xuwutao/.pyenv/versions/3.7.1/envs/science/lib/python3.7/site-packages/camb/camblib.so, 6): Library not loaded: @rpath/libiomp5.dylib Referenced from : /Users/xuwutao/.pyenv/versions/3.7.1/envs/science/lib/python3.7/site-packages/camb/camblib.so Reason: image not found解决办法： 将libiomp5.dylib所在的目录加入@rpath中。1install_name_tool -add_rpath /Users/xuwutao/Program/intel/2018/compilers_and_libraries_2018.1.126/mac/compiler/lib /Users/xuwutao/.pyenv/versions/3.7.1/envs/science/lib/python3.7/site-packages/camb/camblib.so疑问原以为设置好DYLD_LIBRARY_PATH就没有问题，没想到还需要设置@rpath。估计和Mac下动态库的加载机制有关，详细情况以后有时间再研究吧。","categories":[{"name":"Python","slug":"Python","permalink":"http://spiedeman.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://spiedeman.github.io/tags/Python/"},{"name":"CAMB","slug":"CAMB","permalink":"http://spiedeman.github.io/tags/CAMB/"}]},{"title":"Jupyter-With-Virtualenv","slug":"jupyter-with-virtualenv","date":"2018-11-26T05:36:56.000Z","updated":"2021-09-18T02:10:59.612Z","comments":true,"path":"posts/3264731549/","link":"","permalink":"http://spiedeman.github.io/posts/3264731549/","excerpt":"","text":"添加内核终端切换python版本很容易，但在jupyter中应该如何切换环境？假如有一个虚拟环境science，将其导入jupyter的过程如下：1、进入虚拟环境science1pyenv active science2、安装ipykernel1pip install ipykernel3、为jupyter安装新内核1ipython kernel install --user --name science --display-name \"python3 (science)\"4、查看可用内核12345jupyter-kernelspec listAvailable kernerls: science /Users/xuwutao/Library/Jupyter/kernels/science python3 /Users/xuwutao/.pyenv/versions/3.7.1/Python.framework/Versions/3.7/share/jupyter/kernels/python3修改内核内核在jupyter中以json文件方式存在。每新建一个内核，jupyter会在系统的特定位置新建文件夹，存储相应的json文件。这些位置分布如下：UnixWindowsSystem/usr/share/jupyter/kernels/usr/local/share/jupyter/kernels%PROGRAMDATA\\jupyter\\kernelsEnv{sys.prefix}/share/jupyter/kernelsUser~/Library/Jupyter/kernels (Mac)~/.local/share/jupyter/kernels (Linux)%APPDATA%\\jupyter\\kernels","categories":[{"name":"Python","slug":"Python","permalink":"http://spiedeman.github.io/categories/Python/"}],"tags":[{"name":"Jupyter","slug":"Jupyter","permalink":"http://spiedeman.github.io/tags/Jupyter/"},{"name":"Virtualenv","slug":"Virtualenv","permalink":"http://spiedeman.github.io/tags/Virtualenv/"}]},{"title":"树莓派新手指南","slug":"raspberry-install","date":"2018-11-18T11:12:14.000Z","updated":"2021-09-18T02:10:59.622Z","comments":true,"path":"posts/2712929324/","link":"","permalink":"http://spiedeman.github.io/posts/2712929324/","excerpt":"","text":"刻录系统选好合适的系统镜像之后，用dd命令刻录系统到 sd 卡中。1dd bs=16M if=/path/to/img of=/dev/sdcMac系统下类似，主要注意输出文件是/dev/sdc而不是sd卡上的分区。开启SSH最新版树莓派系统默认不开启ssh服务。没有显示器的情况下，这是不能忍的。好在有一个简单的办法可以解决，系统刻录完成后在boot分区下新建名为ssh的空白文件。12# 挂载并进入boot分区touch ssh启动树莓派用网线连接树莓派和Mac，打开Mac终端，通过ssh连接树莓派。12345# 搜索raspberrypi的ip地址arp -a# 将公钥加入远程主机的 authorized_keys 文件中，实现无密码登陆ssh-copy-id pi@raspberrypi更新源将文件/etc/apt/sources.list中的raspbian.raspberrypi.org替换为mirrors.ustc.edu.cn/raspbian。树莓派的archive.raspberrypi.org软件源，也即/etc/apt/sources.list.d/raspi.list。是由树莓派基金会提供的软件源，包括ui相关程序（如Raspbian的桌面环境PIXEL DE）及部分由树莓派基金会为树莓派编写的软件，通常与archive.raspbian.org一起使用。将archive.raspberrypi.org/替换为mirrors.ustc.edu.cn/archive.raspberrypi.org/。初始化配置输入命令 sudo raspi-config 进入配置模式。常用的有扩展系统分区，修改密码，启动设置等。修改swap空间大小12345# 修改文件sudo vim /etc/dphys-swapfile# 把 CONF_SWAPSIZE=100 改成需要的大小，单位是m# 重启dphys-swapfile服务sudo service dphys-swapfile restart查看当前swap空间1free -mVNC 远程桌面树莓派自带VNC服务器，通过配置实现远程图形化界面登陆。树莓派官方VNC教程debian 安装后必做的几件事1、安装shadowsocks。注意pip安装时不要--user选项。配置服务，开机自启动。12# 安装最新版 shadowsockspip install https://github.com/shadowsocks/shadowsocks/archive/master.zippip更新之后可能会遇到问题can not import name main 修改 /usr/bin/pip 文件。123456789# 修改前from pip import mainif __name__ == '__main__': sys.exit(main())# 修改后from pip import __main__if __name__ == '__main__': sys.exit(__main__.main())2、安装pyenv1git clone https://github.com/pyenv/pyenv.git ~/.pyenv详细内容参见文章 pyenv基础教程3、安装字体，VNC连接时视觉上不能遭罪。","categories":[{"name":"树莓派","slug":"树莓派","permalink":"http://spiedeman.github.io/categories/树莓派/"}],"tags":[{"name":"Raspberrypi","slug":"Raspberrypi","permalink":"http://spiedeman.github.io/tags/Raspberrypi/"}]},{"title":"矢量函数分解","slug":"vector-tensor-decomposition","date":"2018-10-08T08:34:27.000Z","updated":"2021-09-18T02:10:59.622Z","comments":true,"path":"posts/2388637373/","link":"","permalink":"http://spiedeman.github.io/posts/2388637373/","excerpt":"","text":"结论：纵向无旋，横向无源任意给定一个矢量函数 \\(w(\\boldsymbol{x})=(w_1(\\boldsymbol{x}),w_2(\\boldsymbol{x}),w_3(\\boldsymbol{x}))\\)。在傅立叶空间中，\\(\\boldsymbol{k}\\)模式的系数\\(w(\\boldsymbol{k})=(w_1(\\boldsymbol{k}),w_2(\\boldsymbol{k}),w_3(\\boldsymbol{k}))\\) 可以分解为动量\\(k\\)的平行和垂直方向。\\[ w = w^{\\parallel} + w^{\\bot} \\]且有 \\(w^{\\parallel} // \\boldsymbol{k}\\) 及 \\(w^{\\bot}\\cdot{\\boldsymbol{k}} = 0\\)回到实空间中，发现 \\(w(\\boldsymbol{x})\\) 可以分解为纵向和横向两部分，\\(w^{\\parallel}(\\boldsymbol{x})\\) 和 \\(w^{\\bot}(\\boldsymbol{x})\\)。分别有如下性质：纵向无旋\\[ \\nabla \\times w^{\\parallel}(\\boldsymbol{x}) = 0 \\]横向无源\\[ \\nabla \\cdot w^{\\bot}(\\boldsymbol{x}) = 0 \\]投影算符傅立叶空间中，\\(\\boldsymbol{k}\\) 模的纵向（横向）投影算符分别为\\[ \\begin{aligned} P^{\\parallel}(\\boldsymbol{k}) &amp;= \\boldsymbol{\\hat{k}}\\otimes\\boldsymbol{\\hat{k}} \\\\ P^{\\perp}(\\boldsymbol{k}) &amp;= 1 - \\boldsymbol{\\hat{k}}\\otimes\\boldsymbol{\\hat{k}} \\\\ \\end{aligned} \\] 或者分量表示 \\[ \\begin{aligned} P^{\\parallel}_{ij}(\\boldsymbol{k}) &amp;= \\boldsymbol{\\hat{k}}_i\\boldsymbol{\\hat{k}}_j \\\\ P^{\\perp}_{ij}(\\boldsymbol{k}) &amp;= \\delta_{ij} - \\boldsymbol{\\hat{k}}_i\\boldsymbol{\\hat{k}}_j \\\\ \\end{aligned} \\]","categories":[{"name":"数学","slug":"数学","permalink":"http://spiedeman.github.io/categories/数学/"}],"tags":[]},{"title":"Pyenv基础教程","slug":"pyenv-guide","date":"2018-09-30T08:52:46.000Z","updated":"2021-09-18T02:10:59.622Z","comments":true,"path":"posts/1952119038/","link":"","permalink":"http://spiedeman.github.io/posts/1952119038/","excerpt":"","text":"pyenv 是一个python版本管理软件。受到ruby的同类软件 rbenv和 ruby-build的启发。安装 pyenvMacOS使用homebrew安装12brew updatebrew install pyenvLinux1git clone https://github.com/pyenv/pyenv.git ~/.pyenv配置在.bashrc中添加下列内容：1234export PYENV_ROOT=\"$home/.pyenv\"export PATH=\"$PYENV_ROOT/bin:$path\"# 上面两行不需要，如果采用homebrew安装方式eval \"$(pyenv init -)\"依赖环境pyenv可以用于安装多个python版本，并对其进行管理。为了避免出现可能的错误，安装之前需要准备好依赖环境。macos1brew install openssl readline sqlite xz zlib如果运行 Mojave 或更高版本，还需额外安装1sudo installer -pkg /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg -target /Debian/Ubuntu1apt-get install -y make build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev在服务器上import pandas as pd可能会出现lzma module could not found, your python was incomplete这样的错误。解决办法是安装库liblzma-dev。1apt install liblzma-dev安装pythonpyenv install命令用于安装指定python版本。为了添加framework支持，安装代码应如下1234# MacOSenv python_configure_opts=\"--enable-framework\" pyenv install 3.6.6# Linuxenv python_configure_opts=\"--enable-shared\" pyenv install 3.6.6若提示错误no module named pyexpat，则用如下方式安装1SDKROOT=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.14.sdk MACOSX_DEPLOYMENT_TARGET=10.14 pyenv install 2.7.16参考命令查看已安装python版本12345pyenv versions system* 2.7.15 (set by /users/xuwutao/.python-version) 3.6.6版本切换pyenv总共设置了三个命令用于python的版本控制，按优先级由高到低以此为pyenv shellpyenv localpyenv globalpyenv shell效果等价于设定环境变量pyenv_version。1234pyenv shell 3.6.6# unsetpyenv shell --unsetpyenv local在当前目录下新建文件.python-version，记录python版本号，一行一个。如果当前目录下没有该文件，则一路往上寻找直到系统根目录。123pyenv local 2.7.15# 等价于touch .python-version &amp;&amp; echo '2.7.15' &gt; !$pyenv global和pyenv global对应的文件为$(pyenv root)/version。123pyenv global 2.7.10# 等价于touch ~/.pyenv/version &amp;&amp; echo '2.7.10' &gt; !$有一个特殊的版本名system是指pyenv之外的python（macos自带，homebrew安装版本等）。三个命令都可以后接多个版本号。","categories":[{"name":"Python","slug":"Python","permalink":"http://spiedeman.github.io/categories/Python/"}],"tags":[{"name":"Pyenv","slug":"Pyenv","permalink":"http://spiedeman.github.io/tags/Pyenv/"}]},{"title":"阻尼振动","slug":"physics-oscillation","date":"2018-09-24T02:32:26.000Z","updated":"2021-09-18T02:10:59.612Z","comments":true,"path":"posts/3976093928/","link":"","permalink":"http://spiedeman.github.io/posts/3976093928/","excerpt":"","text":"参考以弹簧为模型讨论，当考虑空气阻力时，运动方程为 \\[ ma = -kx - bv \\] 阻尼系数\\(b\\)可以随时间变化阻尼振动的结果振动为周期运动，周期由劲度系数\\(k\\)和阻尼系数\\(b\\)共同决定 \\(\\omega = \\sqrt{\\dfrac{k}{m}}\\rightarrow \\omega_N = \\sqrt{\\dfrac{k}{m}-\\dfrac{\\gamma^2}{4}}\\)振幅随时间减小\\(A \\rightarrow A_N = Ae^{-\\gamma t / 2}\\)图像表示定量分析运动方程可以改写为\\(\\dfrac{d^2x}{dt^2} + \\gamma\\dfrac{dx}{dt} + \\omega^2x = 0\\)， \\(\\gamma=\\dfrac{b}{m}\\)和\\(\\omega=\\sqrt{\\dfrac{k}{m}}\\)考虑同形式的复数方程\\(\\dfrac{d^2Z}{dt^2} + \\gamma\\dfrac{dZ}{dt} + \\omega^2Z = 0\\)，\\(Z\\) 的实数部分即为阻尼方程的解。令\\(Z = Ce^{At}\\)，\\(A\\)和\\(C\\)为复常数，代入上式得到\\(A\\)的方程\\(A^2 + \\gamma A + \\omega^2 = 0\\)\\(A\\)的解为\\(A=-\\gamma/2\\pm i\\sqrt{\\omega^2-\\dfrac{\\gamma^2}{4}}\\)， 假设阻力不大，即\\(\\omega\\gt\\gamma/2\\)\\(Z\\)的通解为\\(Z=e^{-\\gamma t/2}(C_1e^{+i\\omega_N t} + C_2e^{-i\\omega_N t})\\)故阻尼方程的解为\\(x = Re(Z) = e^{-\\gamma t/2}[D\\cos(\\omega_N t) - E\\sin(\\omega_N t)]\\)，\\(D\\) 和 \\(E\\) 为常数。令初始相位为\\(\\theta_0=\\tan^{-1}(\\dfrac{D}{E})\\)，\\(L=\\sqrt{D^2-E^2}\\)，\\(x\\)可以化简为\\(x = Le^{-\\gamma t/2}\\cos(\\omega_N t + \\theta_0)\\)","categories":[{"name":"物理","slug":"物理","permalink":"http://spiedeman.github.io/categories/物理/"}],"tags":[{"name":"Physics","slug":"Physics","permalink":"http://spiedeman.github.io/tags/Physics/"},{"name":"Oscillation","slug":"Oscillation","permalink":"http://spiedeman.github.io/tags/Oscillation/"}]},{"title":"Pandas 简介","slug":"pandas-guide","date":"2018-09-21T06:22:14.000Z","updated":"2021-09-18T02:10:59.612Z","comments":true,"path":"posts/1982572123/","link":"","permalink":"http://spiedeman.github.io/posts/1982572123/","excerpt":"","text":"学习目标大致了解pandas库的DataFrame和Series数据结构存取和处理DataFrame和Series中的数据将CSV数据导入pandas库的DataFrame对DataFrame重建索引来随机打乱数据pandas 是一种存列数据分析API。它是用于处理和分析输入数据的强大工具，很多机器学习框架都支持将pandas数据结构作为输入。本文只介绍它的核心概念。有关更完整的参考，请访问 pandas文档网站。基本概念导入pandas API 并输出相应的 API 版本：1234from __future__ import print_functionimport pandas as pdpd.__version__1u'0.22.2'pandas中主要的数据被实现为以下两类：DataFrame，可以想象成一个Excel表，包含多个行和已命名的列。Series，它是单一列。DataFrame 中包含一个或多个 Series，每个 Series 均有一个名称。数据框架是用于 数据操控的一种常用抽象实现形式。 Spark和 R中也有类似的实现。创建 Series 的一种方法时构建 Series 对象。例如：1pd.Series(['San Francisco', 'San Jose', 'Sacramento'])DataFrame 和字典很像，Series 对应字典的 键-值对，Series 的名称为键，数据为值。例如像下面这样创建 DataFrame 对象：1234city_names = pd.Series(['San Francisco', 'San Jose', 'Sacramento'])population = pd.Series([852469, 1015785, 485199])pd.DataFrame(&#123;'City name': city_names, 'Population': population&#125;)但在大多数情况下，是将整个文件加载到 DataFrame 中。1data = pd.read_csv('path or url', *args, **kwargs)访问数据前面提到，DataFrame 和字典很像，还体现在访问数据的方式上。123cities['City name'] # 返回名称为 City name 的 Seriescities[0:2] # 返回所有 Series 的前两个值构建的 DataFrame此外，pandas针对高级 索引和选择提供了机器丰富的 API。操控数据可以向 Series 应用 Python 的基本运算指令。例如：1population / 1000.Numpy是一种用于进行科学计算的常用工具包。pandas Series 可用作大多数 Numpy 函数的参数：12import numpy as npnp.log(population)对于更复杂的单列转换，可以使用 Series.apply。像 Python 映射函数一样，Series.apply 将以参数形式接受 lambda函数，而该函数会应用于每个值。 下面的示例创建了一个指明 population 是否超过 100 万的新 Series：123456population.apply(lambda val: val &gt; 1000000)0 False1 True2 Falsedtype: boolDataFrame 的修改方式也非常简单。例如，以下代码向现有 DataFrame 添加了两个 Series：123cities['Area square miles'] = pd.Series([46.87, 176.53, 97.92])cities['Population density'] = cities['Population'] / cities['Area square miles']cities","categories":[{"name":"Python","slug":"Python","permalink":"http://spiedeman.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://spiedeman.github.io/tags/Python/"},{"name":"Pandas","slug":"Pandas","permalink":"http://spiedeman.github.io/tags/Pandas/"}]},{"title":"Matplotlib 技巧","slug":"matplotlib-tips","date":"2018-09-19T08:04:13.000Z","updated":"2021-09-18T02:10:59.612Z","comments":true,"path":"posts/1362387800/","link":"","permalink":"http://spiedeman.github.io/posts/1362387800/","excerpt":"","text":"收集各种技巧、解决问题的办法。不断加深理解、熟悉matplotlib的使用。中文查看支持的中文字体运行如下代码123456789101112131415from matplotlib.font_manager import FontManagerimport subprocessfm = FontManager()mat_fonts = set(f.name for f in fm.ttflist)output = subprocess.check_output( 'fc-list :lang=zh -f \"%&#123;family&#125;\\n\"', shell=True)zh_fonts = set(f.split(',', 1)[0] for f in output.split('\\n'))available = mat_fonts &amp; zh_fonts# 可用中文字体for f in available: print f尝试发现matplotlib自带了一个可以显示中文的字体Arial Unicode MS。于是可以如下设置，不用下载字体，不用修改matplotlib配置文件。12from matplotlib import rcParamsrcParams['font.sans-serif'] = ['Arial Unicode MS']搞定中文乱码！Figure设置图片大小px(pixel), inch, pt(point)三者之间的关系为1231 px = constant size on screen1 inch = dpi px # dpi is variable1 inch = 72 pt # 确定关系Figure size (figsize) 决定figure的尺寸，单位为inches。默认大小为[6.4, 4.8]。Dots per inches (dpi) 决定figure包含多少像素。默认大小为100。设置为figsize=(w,h)的figure包含123px, py = w * dpi, h * dpi # pixels# e.g.# 6.4 inches * 100 dpi = 640 pixels因此若要获得例如(1200, 600)大小的figure，单位为pixel，可以有各种不同的组合方式1234figsize = (15. 7.5), dpi = 80figsize = (12. 6) , dpi = 100figsize = (8, 4) , dpi = 150figsize = (6, 3) , dpi = 200以上组合方式的不同之处在哪里？差异在图形中线条、文字的粗细不同。figure中大多数元素如线条、标记、文本的size的单位为points。Matplotlib设置 Points per inch (ppi) 等于72。因此无论 dpi 等于多少，一英寸只画72个点。或者说 dpi 决定线条粗细，figsize决定内容多少。","categories":[{"name":"Python","slug":"Python","permalink":"http://spiedeman.github.io/categories/Python/"}],"tags":[{"name":"Matplotlib","slug":"Matplotlib","permalink":"http://spiedeman.github.io/tags/Matplotlib/"}]},{"title":"波的性质","slug":"cosmology","date":"2018-09-19T03:00:38.000Z","updated":"2021-09-18T02:10:59.602Z","comments":true,"path":"posts/3384466728/","link":"","permalink":"http://spiedeman.github.io/posts/3384466728/","excerpt":"","text":"Note波数 \\(k\\) 和波长 \\(\\lambda\\) 的关系：\\(k=2\\pi/\\lambda\\) 角速度 \\(\\omega\\) 和周期 \\(T\\) 的关系：\\(\\omega=2\\pi/T=2\\pi f\\) 波速 \\(c\\) 和波长 \\(\\lambda\\) 的关系：\\(cT=\\lambda\\) 波数 \\(k\\) 和角速度 \\(\\omega\\) 的关系：\\(ck=\\omega=2\\pi f\\) 频率 \\(f\\) 和波数 \\(k\\) 的关系：\\(f=ck/(2\\pi)=c/\\lambda\\)","categories":[{"name":"物理","slug":"物理","permalink":"http://spiedeman.github.io/categories/物理/"}],"tags":[{"name":"Cosmology","slug":"Cosmology","permalink":"http://spiedeman.github.io/tags/Cosmology/"}]},{"title":"Sed 学习笔记","slug":"bash-sed","date":"2018-09-18T07:09:07.000Z","updated":"2021-09-18T02:10:59.602Z","comments":true,"path":"posts/2825119572/","link":"","permalink":"http://spiedeman.github.io/posts/2825119572/","excerpt":"","text":"sed 简介sed 是强大的文本编辑工具。所有的操作都在模式空间进行，且每次只会将一行文本复制到其中等待 sed 命令对其操作。因此，从第二条命令开始，操作的对象都是上一条命令作用后的文本。命令格式1sed [option] 'COMMANDS' file常用的option有123-e 表明后接 sed 命令。命令多于一条时不能省略-i 直接对文件进行操作。-f 后接包含一列 sed 命令的脚本文件。命令COMMANDS 通常格式为1'address[,address]cmd[options]' # 三部分组成：地址、命令、具体操作地址：右行号、正则表达式给出，用于指定需要操作的行。有些命令只能操作单行，有些可以操作连续多行。地址对所有的命令都是可选项，如果不指定，则作用在所有的行上。命令：有追加（a）、改变（c）、插入（i）、替换（s）等最常用。选项：格式由前面的命令决定。替换（s）options的格式为/pattern/replacement/flags。pattern与replacement都支持正则表达式。flags选项有n：1~512的整数，表示只替换第n个匹配项。g：替换全部匹配项默认替换第一个匹配项技巧pattern和replacement中包含Shell变量$var。如果命令用单引号括起来，那么美元符号$分别表示行尾和符号本身。只有用双引号，$var才会被替换为变量值。12345678#!/bin/bashvar=LINUXsed 's/linux/$var/' sonfile...$var... # linux 被替换为 $varvar=LINUXsed \"s/linux/$var\" somefile...LINUX... # linux 被替换为 LINUX替换命令（s）格式中的斜杠/作为定界符，可以换成任何其它符号（好像有一个例外），并且必须出现三次。通常当匹配项或替换项中出现斜杠/时会变更定界符，如#。1's#pattern#replacement#'例子删除空白行sed -i '/^$/d' input.xxx # -i，修改源文件输出某一行到其他文件sed -n '3p' input.xxx &gt;&gt; output.xxx","categories":[{"name":"脚本","slug":"脚本","permalink":"http://spiedeman.github.io/categories/脚本/"}],"tags":[{"name":"Bash","slug":"Bash","permalink":"http://spiedeman.github.io/tags/Bash/"},{"name":"Sed","slug":"Sed","permalink":"http://spiedeman.github.io/tags/Sed/"}]},{"title":"hexo 建站及使用建议","slug":"hexo-guide","date":"2018-09-17T07:03:18.000Z","updated":"2021-09-18T02:10:59.612Z","comments":true,"path":"posts/1795312736/","link":"","permalink":"http://spiedeman.github.io/posts/1795312736/","excerpt":"","text":"建站依赖node.jsgit安装 node.js以及git12brew install nodebrew install git安装 Hexo12# 全局安装 hexo 命令行工具npm install -g hexo-cli新建博客根目录1234567891011hexo init /path/to/blogcd /path/to/blognpm install# 博客根目录如下：# |—— _config.yml# |—— node_modules# |—— package.json# |—— scaffolds# |—— source# | |—— _posts# |—— themes博客配置文件/path/to/blog/_config.yml通常搭配主题进行配置，只要不更换主题可以一直使用，顶多需要稍作修改。安装主题经过一番挑选之后，个人选择使用pure主题。1git clone https://github.com/cofess/hexo-theme-pure.git themes/pure修改主题的配置文件theme/pure/_config.yml。这个文件比较重要，配置过后可以一直使用，每次主题版本更新之后最多只需稍作修改即可。安装插件配合pure主题使用的插件有123456npm install gitment --savenpm install hexo-wordcount --savenpm install hexo-generator-json-content --savenpm install hexo-generator-feed --savenpm install hexo-generator-sitemap --savenpm install hexo-neat --savepure主题使用Katex渲染数学公式，目前最新版本号为0.10.1。为了使用Katex，需要替换默认的markdown渲染引擎为markdown-it-plus12npm un hexo-renderer-marked --savenpm install hexo-renderer-markdown-it-plus --save本地不需要安装Katex插件，但是需要修改模版中的一处地方。1234cd themes/pure/layout/_commonvim head.ejs# 定位到 katex，将版本号0.9.0修改为最新0.10.1# 保存退出推送到GitHub，需要安装插件hexo-deployer-git。1npm install hexo-deployer-git --save以上是利用Hexo建立个人静态博客的基本过程，并已将大部分操作保存在了脚本中hexo.sh。使用建议Hexo 使用的 markdown 语法与标准的 markdown 语法有所差别。图片当需要同时插入多张图片时，就遇到了排版问题。next主题有 gp属性 可以做到。 pure主题没有相似的命令，所以只能直接用html标记语言。居中123456&lt;div align=\"center\"&gt; &lt;!-- 分作两行的话中间会有缝隙 --&gt; &lt;!-- 由于插件 hexo-abbrlink 的使用，路径的获取最好用下面第二种方式 --&gt; &lt;img src=\"path/to/image\" [width=\"200\"] [height=\"300\"] [title]&gt; &lt;img src=\"&#123;% asset_path slug %&#125;\" [width=\"200\"] [height=\"300\"] [title]&gt;&lt;/div&gt;效果由于图片过大可能会导致无法并排放两张图片，所以需要在插入时调整尺寸。hexo中插入命令asset_img没有size选项，因此按照上例插入图片或使用标签插件。参考资料Hexo 官方中文文档 Hexo 主题文档（中文）","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://spiedeman.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://spiedeman.github.io/tags/Hexo/"}]},{"title":"元类（Metaclass）","slug":"python-metaclass","date":"2017-12-31T16:00:00.000Z","updated":"2021-09-18T02:10:59.622Z","comments":true,"path":"posts/2704906340/","link":"","permalink":"http://spiedeman.github.io/posts/2704906340/","excerpt":"","text":"Metaclass面向对象编程语言中，元类是指实例为类的类。定义确定的类及其实例的行为。并非所有面向对象的语言都支持元类。每一种语言都拥有他自己的元对象原型，为一系列描述对象、类、元类之间如何相互作用的规则。Python example在Python里，内置的类type是一个元类。考虑这样一个简单的Python类：1234567891011class Car(object): def __init__(self, make, model, year, color): self.make = make self.model = model self.year = year self.color = color @property def description(self): \"\"\" Return a description of this car. \"\"\" return \"%s %s %s %s\" % (self.color, self.year, self.make, self.model)在程序运行时，Car本身是类type的一个实例，类Car的源代码如上所示，有很多内容没有直接呈现出来，例如Car对象的大小、在内存中的二进制布局、它们是如何被分配内存的、每当一个Car实例被创建时初始化__init__方法会被自动调用等等。这些细节不仅在一个新的Car实例被创建时，还会在每次访问car的属性时起作用。没有元类的语言，这些细节是被语言本身所确定的，且无法被重载。在Python中，元类type控制了这些细节是实现的方式。具体的控制方式可以用另一个元类代替type来改变。12345678910111213class AttributeInitType(type): def __call__(self, *args, **kwargs): \"\"\" Create a new instance. \"\"\" # First, create the object in the normal default way. obj = type.__call__(self, *args) # Additionally, set attributes on the new object. for name, value in kwargs.items(): setattr(obj, name, value) # Return the new object. return obj这个元类只重载了类的创建方式，类的其他方面及对象的行为仍然由type进行处理。 现在类Car可以使用新定义的元类重写。在Python2中通过在类定义中赋值给__metaclass__来实现：1234567class Car(object): __metaclass__ = AttributeInitType @property def description(self): \"\"\" Return a description of this car. \"\"\" return \" \".join(str(getattr(self, attr, \"Unknown\")) for attr in self.__dict__)在Python3中需要提供一个命名参数：12345class Car(object, mateclass=AttributeInitType): @property def description(self): \"\"\" Return a description of this car. \"\"\" return \" \".join(str(value) for value in self.__dict__.values())Car的实例于是可以像下面这样实例化：12new_car = Car(make='Toyota', model='Prius', year=2005, color='Green')old_car = Car(make='Ford', model='Prefect', year=1979)关键字参数实例化的效果也可以不用元类实现：1234567class Car(object): def __init__(self, **kwargs): for name, value in kwargs.items(): setattr(self, name, value) @property def description(self): return \" \".join(str(value) for value in self.__dict__.values())","categories":[{"name":"Python","slug":"Python","permalink":"http://spiedeman.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://spiedeman.github.io/tags/python/"}]},{"title":"The second article","slug":"article2","date":"2017-12-12T16:00:00.000Z","updated":"2021-09-18T02:10:59.542Z","comments":true,"path":"posts/386283100/","link":"","permalink":"http://spiedeman.github.io/posts/386283100/","excerpt":"","text":"intra-site link examples/posts/386283100/buffon_needle.gifMath Formula\\(e^{i\\pi}=1\\)Here is the Buffon's Needle experiment for calculating \\(\\pi\\).","categories":[{"name":"article","slug":"article","permalink":"http://spiedeman.github.io/categories/article/"}],"tags":[]},{"title":"Bash-技巧","slug":"bash-tips","date":"2017-06-09T06:54:21.000Z","updated":"2021-09-18T02:10:59.602Z","comments":true,"path":"posts/3452120969/","link":"","permalink":"http://spiedeman.github.io/posts/3452120969/","excerpt":"","text":"持续更新 Bash 小技巧检测程序是否已安装123456789101112131415#!/bin/bashcheck_software()&#123; local software=(vim git tmux npm) # 待测程序名 for soft in $&#123;software[@]&#125; do type $soft 2&gt;&amp;1 &gt; /dev/null # 已安装，则返回零 if [ $? -ne 0 ]; then echo \"ERROR: **$soft** is not installed!\" exit 1 fi echo \"Checking $soft...ok!\" done&#125;check_software123456运行结果bash check_software.shChecking vim...ok!Checking git...ok!Checking tmux...ok!Checking npm...ok!","categories":[{"name":"脚本","slug":"脚本","permalink":"http://spiedeman.github.io/categories/脚本/"}],"tags":[{"name":"Bash","slug":"Bash","permalink":"http://spiedeman.github.io/tags/Bash/"}]}],"categories":[{"name":"工作","slug":"工作","permalink":"http://spiedeman.github.io/categories/工作/"},{"name":"物理","slug":"物理","permalink":"http://spiedeman.github.io/categories/物理/"},{"name":"i3","slug":"i3","permalink":"http://spiedeman.github.io/categories/i3/"},{"name":"科学上网","slug":"科学上网","permalink":"http://spiedeman.github.io/categories/科学上网/"},{"name":"算法","slug":"算法","permalink":"http://spiedeman.github.io/categories/算法/"},{"name":"Vim","slug":"Vim","permalink":"http://spiedeman.github.io/categories/Vim/"},{"name":"数值计算","slug":"数值计算","permalink":"http://spiedeman.github.io/categories/数值计算/"},{"name":"Hexo","slug":"Hexo","permalink":"http://spiedeman.github.io/categories/Hexo/"},{"name":"电子书","slug":"电子书","permalink":"http://spiedeman.github.io/categories/电子书/"},{"name":"Graphviz","slug":"Graphviz","permalink":"http://spiedeman.github.io/categories/Graphviz/"},{"name":"Python","slug":"Python","permalink":"http://spiedeman.github.io/categories/Python/"},{"name":"编程语言","slug":"编程语言","permalink":"http://spiedeman.github.io/categories/编程语言/"},{"name":"MacOS","slug":"MacOS","permalink":"http://spiedeman.github.io/categories/MacOS/"},{"name":"树莓派","slug":"树莓派","permalink":"http://spiedeman.github.io/categories/树莓派/"},{"name":"数学","slug":"数学","permalink":"http://spiedeman.github.io/categories/数学/"},{"name":"脚本","slug":"脚本","permalink":"http://spiedeman.github.io/categories/脚本/"},{"name":"article","slug":"article","permalink":"http://spiedeman.github.io/categories/article/"}],"tags":[{"name":"远程办公","slug":"远程办公","permalink":"http://spiedeman.github.io/tags/远程办公/"},{"name":"Cosmology","slug":"Cosmology","permalink":"http://spiedeman.github.io/tags/Cosmology/"},{"name":"Physics","slug":"Physics","permalink":"http://spiedeman.github.io/tags/Physics/"},{"name":"触摸板","slug":"触摸板","permalink":"http://spiedeman.github.io/tags/触摸板/"},{"name":"手势操作","slug":"手势操作","permalink":"http://spiedeman.github.io/tags/手势操作/"},{"name":"VPS","slug":"VPS","permalink":"http://spiedeman.github.io/tags/VPS/"},{"name":"Trojan","slug":"Trojan","permalink":"http://spiedeman.github.io/tags/Trojan/"},{"name":"V2Ray","slug":"V2Ray","permalink":"http://spiedeman.github.io/tags/V2Ray/"},{"name":"面试","slug":"面试","permalink":"http://spiedeman.github.io/tags/面试/"},{"name":"Vim-插件","slug":"Vim-插件","permalink":"http://spiedeman.github.io/tags/Vim-插件/"},{"name":"字符串匹配","slug":"字符串匹配","permalink":"http://spiedeman.github.io/tags/字符串匹配/"},{"name":"Python","slug":"Python","permalink":"http://spiedeman.github.io/tags/Python/"},{"name":"Scipy","slug":"Scipy","permalink":"http://spiedeman.github.io/tags/Scipy/"},{"name":"数值计算","slug":"数值计算","permalink":"http://spiedeman.github.io/tags/数值计算/"},{"name":"数学","slug":"数学","permalink":"http://spiedeman.github.io/tags/数学/"},{"name":"统计","slug":"统计","permalink":"http://spiedeman.github.io/tags/统计/"},{"name":"Hexo","slug":"Hexo","permalink":"http://spiedeman.github.io/tags/Hexo/"},{"name":"GitBook","slug":"GitBook","permalink":"http://spiedeman.github.io/tags/GitBook/"},{"name":"Vim","slug":"Vim","permalink":"http://spiedeman.github.io/tags/Vim/"},{"name":"Graphviz","slug":"Graphviz","permalink":"http://spiedeman.github.io/tags/Graphviz/"},{"name":"BBR","slug":"BBR","permalink":"http://spiedeman.github.io/tags/BBR/"},{"name":"类型与对象","slug":"类型与对象","permalink":"http://spiedeman.github.io/tags/类型与对象/"},{"name":"YouCompleteMe","slug":"YouCompleteMe","permalink":"http://spiedeman.github.io/tags/YouCompleteMe/"},{"name":"Clang","slug":"Clang","permalink":"http://spiedeman.github.io/tags/Clang/"},{"name":"CentOS","slug":"CentOS","permalink":"http://spiedeman.github.io/tags/CentOS/"},{"name":"Homebrew","slug":"Homebrew","permalink":"http://spiedeman.github.io/tags/Homebrew/"},{"name":"最小作用量","slug":"最小作用量","permalink":"http://spiedeman.github.io/tags/最小作用量/"},{"name":"诺特定理","slug":"诺特定理","permalink":"http://spiedeman.github.io/tags/诺特定理/"},{"name":"CAMB","slug":"CAMB","permalink":"http://spiedeman.github.io/tags/CAMB/"},{"name":"Jupyter","slug":"Jupyter","permalink":"http://spiedeman.github.io/tags/Jupyter/"},{"name":"Virtualenv","slug":"Virtualenv","permalink":"http://spiedeman.github.io/tags/Virtualenv/"},{"name":"Raspberrypi","slug":"Raspberrypi","permalink":"http://spiedeman.github.io/tags/Raspberrypi/"},{"name":"Pyenv","slug":"Pyenv","permalink":"http://spiedeman.github.io/tags/Pyenv/"},{"name":"Oscillation","slug":"Oscillation","permalink":"http://spiedeman.github.io/tags/Oscillation/"},{"name":"Pandas","slug":"Pandas","permalink":"http://spiedeman.github.io/tags/Pandas/"},{"name":"Matplotlib","slug":"Matplotlib","permalink":"http://spiedeman.github.io/tags/Matplotlib/"},{"name":"Bash","slug":"Bash","permalink":"http://spiedeman.github.io/tags/Bash/"},{"name":"Sed","slug":"Sed","permalink":"http://spiedeman.github.io/tags/Sed/"},{"name":"python","slug":"python","permalink":"http://spiedeman.github.io/tags/python/"}]}